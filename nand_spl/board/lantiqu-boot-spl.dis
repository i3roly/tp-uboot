
/Volumes/xtoolshit/misc/dd-wrt/src/router/tools/ax50v1_GPL_3/intel_GRX350/sdk/7.5.1.50/UGW-7.5.1.50/build_dir/xRX500_BootCore/build_dir/target-mips-openwrt-linux-uclibc_grx_350_550_wave600_bootcore_sample/linux-lantiq_xrx500_4kec/u-boot-2010.06/nand_spl/board/lantiqu-boot-spl:     file format elf32-tradbigmips


Disassembly of section .text:

a0001000 <__reset_vector>:
   	.globl __exception_vector_int
   	.text
LEAF(__reset_vector)
_start:
	/* RESET entry */
   	b     reset
a0001000:	1000009d 	b	a0001278 <reset>
   	nop
a0001004:	00000000 	nop
	...
   	nop
   	nop
END(__reset_vector)
.org 0x200 /* General exception. */
    li      k0, (GIC_SH_WEDGE | GIC_BASE_ADDR)
a0001200:	3c1ab232 	lui	k0,0xb232
a0001204:	375a0280 	ori	k0,k0,0x280
    mfc0    k1, CP0_EBASE                // Get cp0 EBase = $15
a0001208:	401b7801 	mfc0	k1,c0_ebase
    ext     k1, k1, 0, 10                               // Extract CPUNum
a000120c:	7f7b4800 	ext	k1,k1,0x0,0xa
    li      v0, 1
a0001210:	24020001 	li	v0,1
    li      v1, 1
a0001214:	24030001 	li	v1,1
    bne     k1, v0, 1f
a0001218:	17620004 	bne	k1,v0,a000122c <__reset_vector+0x22c>
    add     v0, v1
a000121c:	00431020 	add	v0,v0,v1
    li      k1, 20
a0001220:	241b0014 	li	k1,20
    b       ipi_calculation_done
a0001224:	10000009 	b	a000124c <ipi_calculation_done>
    nop
a0001228:	00000000 	nop

1:  bne     k1, v0, 1f
a000122c:	17620004 	bne	k1,v0,a0001240 <__reset_vector+0x240>
    add     v0, v1
a0001230:	00431020 	add	v0,v0,v1
    li      k1, 21
a0001234:	241b0015 	li	k1,21
    b       ipi_calculation_done
a0001238:	10000004 	b	a000124c <ipi_calculation_done>
    nop
a000123c:	00000000 	nop

1:  li      k1, 85
a0001240:	241b0055 	li	k1,85
    b       ipi_calculation_done
a0001244:	10000001 	b	a000124c <ipi_calculation_done>
    nop
a0001248:	00000000 	nop

a000124c <ipi_calculation_done>:

ipi_calculation_done:
    sw      k1, 0(k0)                                   // Clear this IPI.
a000124c:	af5b0000 	sw	k1,0(k0)
    

    li      k0, INTMSG
a0001250:	3c1aa000 	lui	k0,0xa000
a0001254:	375aff10 	ori	k0,k0,0xff10
    mfc0    k1, CP0_EBASE                                // Get cp0 EBase
a0001258:	401b7801 	mfc0	k1,c0_ebase
    ext     k1, k1, 0, 10                               // Extract CPUNum
a000125c:	7f7b4800 	ext	k1,k1,0x0,0xa
    sll     k1, k1, 2                                   // k1 = k1*4
a0001260:	001bd880 	sll	k1,k1,0x2
    addu    k0, k0, k1                                  // index into CMP global "C" variable start_test
a0001264:	035bd021 	addu	k0,k0,k1
    li      k1, 1
a0001268:	241b0001 	li	k1,1
    sw      k1, 0(k0)                                   // Release "cpu"/vpe to execute "C" test code.
a000126c:	af5b0000 	sw	k1,0(k0)
    eret
a0001270:	42000018 	eret
    nop
a0001274:	00000000 	nop

a0001278 <reset>:

reset:
        /* Initialize GOT pointer.
        */
        bal     1f
a0001278:	04110002 	bal	a0001284 <reset+0xc>
        nop
a000127c:	00000000 	nop
a0001280:	a0005940 	sb	zero,22848(zero)
        .word   _GLOBAL_OFFSET_TABLE_
1:
        move    gp, ra
a0001284:	03e0e021 	move	gp,ra
        lw      t1, 0(ra)
a0001288:	8fe90000 	lw	t1,0(ra)
        move    gp, t1
a000128c:	0120e021 	move	gp,t1

    	/* Only set GOT for IAP Core 1 and abv */
	    mfc0    k1, CP0_PRID             
a0001290:	401b7800 	mfc0	k1,c0_prid
	    ext     k1, k1, 8, 16       /* Company ID & Processor ID */
a0001294:	7f7b7a00 	ext	k1,k1,0x8,0x10
	    li      k0, 0x0190          /* 4Kec ID*/
a0001298:	241a0190 	li	k0,400
    	beq     k0, k1, start_init	/* jmp if 4Kec */
a000129c:	135b001d 	beq	k0,k1,a0001314 <start_init>
	    nop
a00012a0:	00000000 	nop

		/* CPU core 0, we shall ignore and jmp away */
	    mfc0    k0, CP0_EBASE       // Read CP0 EBase
a00012a4:	401a7801 	mfc0	k0,c0_ebase
	    ext     k1, k0, 0, 4        // Extract CPUNum
a00012a8:	7f5b1800 	ext	k1,k0,0x0,0x4
    	beq     k1, 0, start_init	/* jmp if core 0 */
a00012ac:	13600019 	beqz	k1,a0001314 <start_init>
    	nop	
a00012b0:	00000000 	nop

		/* Check if the core is in EVA mode */
    	mfc0	v0, CP0_CONFIG5	
a00012b4:	40028005 	mfc0	v0,$16,5
		li      v1, 0x40000000
a00012b8:	3c034000 	lui	v1,0x4000
		and		v0, v0, v1
a00012bc:	00431024 	and	v0,v0,v1
		beqz	v0, start_init		/* if EVA bit is not set, we are in legacy mode. hence no need 	*/
a00012c0:	10400014 	beqz	v0,a0001314 <start_init>
		nop							/* to change the GOT table location							 	*/
a00012c4:	00000000 	nop

		/* Re-adjust GOT when in EVA mode */
        bal     1f
a00012c8:	04110002 	bal	a00012d4 <reset+0x5c>
        nop
a00012cc:	00000000 	nop
a00012d0:	00000118 	0x118
        .word   got_size
1:
        move    t1, ra
a00012d4:	03e04821 	move	t1,ra
        lw      t1, 0(t1)
a00012d8:	8d290000 	lw	t1,0(t1)

        move    t0, gp
a00012dc:	03804021 	move	t0,gp
        add     t1, t0, t1
a00012e0:	01094820 	add	t1,t0,t1
        addi    t0, 8 /*skip first 2 entries*/
a00012e4:	21080008 	addi	t0,t0,8
		
		/* Check if we need to add the GOT back to 0xA0000000 range */
		lw		t2, 0(t0)
a00012e8:	8d0a0000 	lw	t2,0(t0)
		and		t2, t2, 0x70000000	/* mask value */
a00012ec:	3c017000 	lui	at,0x7000
a00012f0:	01415024 	and	t2,t2,at
		bnez	t2, start_init		/* if GOT already in 0xA000000 range, skip */
a00012f4:	15400007 	bnez	t2,a0001314 <start_init>
		nop
a00012f8:	00000000 	nop
		
		/* Remap GOT table to 0xA000XXXX region */
2:
        lw      t2, 0(t0)
a00012fc:	8d0a0000 	lw	t2,0(t0)
        addu    t2, 0x20000000
a0001300:	3c012000 	lui	at,0x2000
a0001304:	01415021 	addu	t2,t2,at
        sw      t2, 0(t0)
a0001308:	ad0a0000 	sw	t2,0(t0)
        bne     t0, t1, 2b
a000130c:	1509fffb 	bne	t0,t1,a00012fc <reset+0x84>
        addi    t0, t0, 4
a0001310:	21080004 	addi	t0,t0,4

a0001314 <start_init>:

start_init:
        la      a2,  set_gpr_boot_values             // Fill register file boot info. r23_cpu_num = 8 for 4KEc
a0001314:	8f860008 	lw	a2,8(gp)
        jalr    a2
a0001318:	00c0f809 	jalr	a2
        nop
a000131c:	00000000 	nop

        la          a2, init_cp0                    // Init CP0 Status, Count, Compare, Watch*, and Cause.
a0001320:	8f86000c 	lw	a2,12(gp)
        jalr        a2
a0001324:	00c0f809 	jalr	a2
        nop
a0001328:	00000000 	nop
#ifdef CONFIG_LTQ_SECURE_BOOT 
        li              k0, 8
        beq             k0, r23_cpu_num, init_done     // CPUNum = 8 = 4KEc
        nop
#endif        
        la          a2, init_gic                    // Configure the global interrupt controller.
a000132c:	8f860010 	lw	a2,16(gp)
        jalr        a2
a0001330:	00c0f809 	jalr	a2
        nop
a0001334:	00000000 	nop
        
        la          a2, init_exception
a0001338:	8f860014 	lw	a2,20(gp)
        jalr        a2
a000133c:	00c0f809 	jalr	a2
        nop
a0001340:	00000000 	nop

        la			a2,	ipi_reconfig			// reconfigure IPI interrupts for VPE1-VPE3
a0001344:	8f860018 	lw	a2,24(gp)
        jalr		a2
a0001348:	00c0f809 	jalr	a2
        nop
a000134c:	00000000 	nop
        
        bnez        r9_vpe_num, init_done   // If we are not vpe0 then we are done.
a0001350:	15200024 	bnez	t1,a00013e4 <init_done>
        nop
a0001354:	00000000 	nop

        la          a2, disable_L23                 // Disable L2/L3 caches
a0001358:	8f86001c 	lw	a2,28(gp)
        jalr        a2
a000135c:	00c0f809 	jalr	a2
        nop
a0001360:	00000000 	nop

        la          a2, sys_init_icache                 // Initialize the L1 instruction cache. (Executing using I$ on return.)
a0001364:	8f860020 	lw	a2,32(gp)
        jalr        a2
a0001368:	00c0f809 	jalr	a2
        nop
a000136c:	00000000 	nop

        la          a2, change_k0_cca
a0001370:	8f860024 	lw	a2,36(gp)
        jalr        a2
a0001374:	00c0f809 	jalr	a2
        nop
a0001378:	00000000 	nop

        la          a2, sys_init_dcache                 // Initialize the L1 data cache
a000137c:	8f860028 	lw	a2,40(gp)
        jalr        a2
a0001380:	00c0f809 	jalr	a2
        nop
a0001384:	00000000 	nop

        li              k0, 8
a0001388:	241a0008 	li	k0,8
        beq             k0, r23_cpu_num, init_done     // CPUNum = 8 = 4KEc
a000138c:	13570015 	beq	k0,s7,a00013e4 <init_done>
        nop
a0001390:	00000000 	nop

        bgtz            r23_cpu_num, init_sys_resources_done
a0001394:	1ee0000d 	bgtz	s7,a00013cc <init_sys_resources_done>
        nop
a0001398:	00000000 	nop

a000139c <init_sys_resources>:

init_sys_resources:
        /*interAptiv start to initialize system resources*/
        la          a2, init_cpc                    // Initialize the CPS CPC (Cluster Power Controller.)
a000139c:	8f86002c 	lw	a2,44(gp)
        jalr        a2
a00013a0:	00c0f809 	jalr	a2
        nop
a00013a4:	00000000 	nop

        la          a2, init_cm                             // Initialize the CPS CM (Coherence Manager.)
a00013a8:	8f860030 	lw	a2,48(gp)
        jalr        a2
a00013ac:	00c0f809 	jalr	a2
        nop
a00013b0:	00000000 	nop

        la          a2, init_L23                    // Initialize the unified L2 and L3 caches
a00013b4:	8f860034 	lw	a2,52(gp)
        jalr        a2
a00013b8:	00c0f809 	jalr	a2
        nop
a00013bc:	00000000 	nop
        
        la          a2, release_mp                  // Release other cores to execute this boot code.
a00013c0:	8f860038 	lw	a2,56(gp)
        jalr        a2
a00013c4:	00c0f809 	jalr	a2
        nop
a00013c8:	00000000 	nop

a00013cc <init_sys_resources_done>:
init_sys_resources_done:
        la          a2, join_domain                 // Join the Coherence  domain. (OK to use D$ on return.)
a00013cc:	8f86003c 	lw	a2,60(gp)
        jalr        a2
a00013d0:	00c0f809 	jalr	a2
        nop
a00013d4:	00000000 	nop

        la          a2, init_vpe1                   // Set up MT ASE vpe1 to execute this boot code also.
a00013d8:	8f860040 	lw	a2,64(gp)
        jalr        a2
a00013dc:	00c0f809 	jalr	a2
        nop
a00013e0:	00000000 	nop

a00013e4 <init_done>:

init_done:
        la          a2, init_legacy                 // init cpu into non-eva mode
a00013e4:	8f860044 	lw	a2,68(gp)
        jalr        a2
a00013e8:	00c0f809 	jalr	a2
        nop
a00013ec:	00000000 	nop

	/* Set up temporary stack.
	 */

        li              k1, (CONFIG_NAND_SPL_TEXT_BASE | 0x8000)
a00013f0:	3c1ba000 	lui	k1,0xa000
a00013f4:	377b9000 	ori	k1,k1,0x9000
        li              k0, 8
a00013f8:	241a0008 	li	k0,8
        beq             k0, r23_cpu_num, change_got_table
a00013fc:	13570005 	beq	k0,s7,a0001414 <change_got_table>
        nop
a0001400:	00000000 	nop
        addi            k1, 0x2000
a0001404:	237b2000 	addi	k1,k1,8192
        ins             k1, r23_cpu_num, STACK_SIZE_LOG2, 2 
a0001408:	7efb7344 	ins	k1,s7,0xd,0x2
        b               change_got_table_done
a000140c:	10000011 	b	a0001454 <change_got_table_done>
        nop
a0001410:	00000000 	nop

a0001414 <change_got_table>:
               
change_got_table:
        bal     1f
a0001414:	04110002 	bal	a0001420 <change_got_table+0xc>
              nop
a0001418:	00000000 	nop
a000141c:	00000118 	0x118
        .word   got_size
1:
        move    t1, ra
a0001420:	03e04821 	move	t1,ra
        lw      t1, 0(t1)
a0001424:	8d290000 	lw	t1,0(t1)

        move    t0, gp
a0001428:	03804021 	move	t0,gp
        add     t1, t0, t1
a000142c:	01094820 	add	t1,t0,t1
        addi    t0, 8 /*skip first 2 entries*/
a0001430:	21080008 	addi	t0,t0,8
2:
        lw      t2, 0(t0)
a0001434:	8d0a0000 	lw	t2,0(t0)
        subu    t2, 0x20000000
a0001438:	3c012000 	lui	at,0x2000
a000143c:	01415023 	subu	t2,t2,at
        sw      t2, 0(t0)
a0001440:	ad0a0000 	sw	t2,0(t0)
        bne     t0, t1, 2b
a0001444:	1509fffb 	bne	t0,t1,a0001434 <change_got_table+0x20>
        addi    t0, t0, 4
a0001448:	21080004 	addi	t0,t0,4

        subu    gp, 0x20000000
a000144c:	3c012000 	lui	at,0x2000
a0001450:	0381e023 	subu	gp,gp,at

a0001454 <change_got_table_done>:
        li      sp, 0x9fc87ff0
        j       stack_done
        nop
iap_stack:
#endif
        la      sp, 0(k1)
a0001454:	277d0000 	addiu	sp,k1,0
#if defined(CONFIG_LTQ_SECURE_BOOT)
stack_done:
#endif

    move    a0, r23_cpu_num                     // main(arg0) is the "cpu" number (cp0 EBase[CPUNUM].)
a0001458:	02e02021 	move	a0,s7
    move    a1, r8_core_num                     // main(arg1) is the core number.
a000145c:	01002821 	move	a1,t0
    move    a2, r9_vpe_num                      // main(arg2) is the vpe number.
a0001460:	01203021 	move	a2,t1
	la	t9, main
a0001464:	8f990048 	lw	t9,72(gp)

	j	t9
a0001468:	03200008 	jr	t9
	nop
a000146c:	00000000 	nop

a0001470 <cgu_init>:
 * void cgu_init(long)
 */
  .globl  cgu_init
  .ent  cgu_init
cgu_init:
    li  t2, CGU_SYS
a0001470:	3c0abf10 	lui	t2,0xbf10
a0001474:	354a300c 	ori	t2,t2,0x300c
    lw  t2, 0(t2)
a0001478:	8d4a0000 	lw	t2,0(t2)
    bne t2, CONFIG_AR10_CGU_SYS_VALUE, 1f /*check if CGU_SYS is correct*/
a000147c:	24010013 	li	at,19
a0001480:	15410014 	bne	t2,at,a00014d4 <freq_up2date+0x8>
    nop
a0001484:	00000000 	nop

    li  a0, CONFIG_AR10_CGU_CLKFSR_VALUE
a0001488:	3c040002 	lui	a0,0x2
    bne a0, PPE432M_CONFIG, 3f /* check if ppe config to 432M */
a000148c:	3c010002 	lui	at,0x2
a0001490:	14810009 	bne	a0,at,a00014b8 <cgu_init+0x48>
    nop
a0001494:	00000000 	nop

    li   t2, GRX390_ID
a0001498:	3c0abf10 	lui	t2,0xbf10
a000149c:	354a7348 	ori	t2,t2,0x7348
    lw   t2, 0(t2)
a00014a0:	8d4a0000 	lw	t2,0(t2)
    andi t2, t2, 0x1 /* check if grx387/grx39X or ar10 */
a00014a4:	314a0001 	andi	t2,t2,0x1
    beq  t2, 0x1, 3f
a00014a8:	24010001 	li	at,1
a00014ac:	11410002 	beq	t2,at,a00014b8 <cgu_init+0x48>
    nop
a00014b0:	00000000 	nop
 
    /* if ar10 & ppe clk config to 432M */
    li a0, PPE400M_CONFIG /* config to max 400M if chip is ar10 */
a00014b4:	3c041004 	lui	a0,0x1004

3:
    li  t2, CGU_CLKFSR
a00014b8:	3c0abf10 	lui	t2,0xbf10
a00014bc:	354a3010 	ori	t2,t2,0x3010
    lw  t2, 0(t2)
a00014c0:	8d4a0000 	lw	t2,0(t2)
    bne t2, a0, 1f /*check if CGU_CLKFSR is correct*/
a00014c4:	15440003 	bne	t2,a0,a00014d4 <freq_up2date+0x8>
    nop
a00014c8:	00000000 	nop

a00014cc <freq_up2date>:

freq_up2date:
    j ra
a00014cc:	03e00008 	jr	ra
	nop
a00014d0:	00000000 	nop
   andi t2, t2, 0x02
   bne t2, 0x2, 2b
   nop
#endif

   li  t2, CGU_SYS
a00014d4:	3c0abf10 	lui	t2,0xbf10
a00014d8:	354a300c 	ori	t2,t2,0x300c
   li  a0, CONFIG_AR10_CGU_SYS_VALUE
a00014dc:	24040013 	li	a0,19
   addi a0, a0, 0x80
a00014e0:	20840080 	addi	a0,a0,128
   sw  a0, 0(t2)    /*store predefined value to CGU_SYS*/
a00014e4:	ad440000 	sw	a0,0(t2)

   li  a0, CONFIG_AR10_CGU_CLKFSR_VALUE
a00014e8:	3c040002 	lui	a0,0x2
   bne a0, PPE432M_CONFIG, 4f /* check if ppe config to 432M */
a00014ec:	3c010002 	lui	at,0x2
a00014f0:	14810009 	bne	a0,at,a0001518 <freq_up2date+0x4c>
   nop
a00014f4:	00000000 	nop

   li   t2, GRX390_ID
a00014f8:	3c0abf10 	lui	t2,0xbf10
a00014fc:	354a7348 	ori	t2,t2,0x7348
   lw   t2, 0(t2)
a0001500:	8d4a0000 	lw	t2,0(t2)
   andi t2, t2, 0x1 /* check if grx387/grx39X or ar10 */
a0001504:	314a0001 	andi	t2,t2,0x1
   beq  t2, 0x1, 4f
a0001508:	24010001 	li	at,1
a000150c:	11410002 	beq	t2,at,a0001518 <freq_up2date+0x4c>
   nop
a0001510:	00000000 	nop
 
   /* if ar10 & ppe clk config to 432M */
   li a0, PPE400M_CONFIG /* config to max 400M if chip is ar10 */
a0001514:	3c041004 	lui	a0,0x1004

4:
   li  t2, CGU_CLKFSR
a0001518:	3c0abf10 	lui	t2,0xbf10
a000151c:	354a3010 	ori	t2,t2,0x3010
   sw  a0, 0(t2)
a0001520:	ad440000 	sw	a0,0(t2)

   li  t2, PLL0_CFG
a0001524:	3c0abf10 	lui	t2,0xbf10
a0001528:	354a3004 	ori	t2,t2,0x3004
   li  a0, CONFIG_AR10_PLL0_CFG_VALUE /*store predefined value to PLL0_CFG*/
a000152c:	3c0400b0 	lui	a0,0xb0
a0001530:	34842c49 	ori	a0,a0,0x2c49
   sw  a0, 0(t2)
a0001534:	ad440000 	sw	a0,0(t2)

   li  t2, CGU_UPDATE
a0001538:	3c0abf10 	lui	t2,0xbf10
a000153c:	354a3020 	ori	t2,t2,0x3020
   li  a0, 1
a0001540:	24040001 	li	a0,1
   sw  a0, 0(t2) /*write 0x1 to CGU_UPDATE*/
a0001544:	ad440000 	sw	a0,0(t2)

   li  t2, RST_REQ
a0001548:	3c0abf20 	lui	t2,0xbf20
a000154c:	354a3010 	ori	t2,t2,0x3010
   li  a0, 0x40000000
a0001550:	3c044000 	lui	a0,0x4000
   sw  a0, 0(t2)  /*issue global software reset*/
a0001554:	ad440000 	sw	a0,0(t2)

a0001558 <wait_reset>:
wait_reset:
    b   wait_reset
a0001558:	1000ffff 	b	a0001558 <wait_reset>
    nop
a000155c:	00000000 	nop

a0001560 <ddrram_init>:
  .globl  lowlevel_init
  .ent  lowlevel_init
lowlevel_init:
  /* EBU, CGU and SDRAM/DDR-RAM Initialization.
   */
  move  t0, ra
a0001560:	03e04021 	move	t0,ra

#ifdef CONFIG_GRX390_CPUFREQ_AUTO_DETECT
  bal cgu_auto_select
#else
  bal cgu_init
a0001564:	0411ffc2 	bal	a0001470 <cgu_init>
#endif /* CONFIG_GRX390_CPUFREQ_AUTO_DETECT */
  nop
a0001568:	00000000 	nop
 
  move  ra, t0
a000156c:	0100f821 	move	ra,t0
  j ra
a0001570:	03e00008 	jr	ra
  nop
a0001574:	00000000 	nop
	...

a0001580 <nand_command.constprop.2>:
}
#else
/*
 * NAND command for large page NAND devices (2k)
 */
static int nand_command(struct mtd_info *mtd, int block, int page, int offs, u8 cmd)
a0001580:	27bdffc8 	addiu	sp,sp,-56
a0001584:	afb3002c 	sw	s3,44(sp)
a0001588:	afb20028 	sw	s2,40(sp)
a000158c:	afb10024 	sw	s1,36(sp)
a0001590:	afbf0034 	sw	ra,52(sp)
a0001594:	afb40030 	sw	s4,48(sp)
a0001598:	afb00020 	sw	s0,32(sp)
{
	struct nand_chip *this = mtd->priv;
a000159c:	8c9000a0 	lw	s0,160(a0)
	int page_addr = page + block * CONFIG_SYS_NAND_PAGE_COUNT;
a00015a0:	00052980 	sll	a1,a1,0x6
}
#else
/*
 * NAND command for large page NAND devices (2k)
 */
static int nand_command(struct mtd_info *mtd, int block, int page, int offs, u8 cmd)
a00015a4:	00808821 	move	s1,a0
{
	struct nand_chip *this = mtd->priv;
	int page_addr = page + block * CONFIG_SYS_NAND_PAGE_COUNT;

	if (this->dev_ready)
a00015a8:	8e020030 	lw	v0,48(s0)
}
#else
/*
 * NAND command for large page NAND devices (2k)
 */
static int nand_command(struct mtd_info *mtd, int block, int page, int offs, u8 cmd)
a00015ac:	00e09821 	move	s3,a3
{
	struct nand_chip *this = mtd->priv;
	int page_addr = page + block * CONFIG_SYS_NAND_PAGE_COUNT;

	if (this->dev_ready)
a00015b0:	1040000b 	beqz	v0,a00015e0 <nand_command.constprop.2+0x60>
a00015b4:	00c59021 	addu	s2,a2,a1
		while (!this->dev_ready(mtd))
a00015b8:	8e190030 	lw	t9,48(s0)
a00015bc:	0320f809 	jalr	t9
a00015c0:	02202021 	move	a0,s1
a00015c4:	5040fffd 	beqzl	v0,a00015bc <nand_command.constprop.2+0x3c>
a00015c8:	8e190030 	lw	t9,48(s0)
			;
	else
		CONFIG_SYS_NAND_READ_DELAY;

	/* Emulate NAND_CMD_READOOB */
	if (cmd == NAND_CMD_READOOB) {
a00015cc:	24020050 	li	v0,80
a00015d0:	1262000b 	beq	s3,v0,a0001600 <nand_command.constprop.2+0x80>
a00015d4:	0000a021 	move	s4,zero
		offs += CONFIG_SYS_NAND_PAGE_SIZE;
		cmd = NAND_CMD_READ0;
	}

	/* Begin command latch cycle */
	this->cmd_ctrl(mtd, cmd, NAND_CTRL_CLE | NAND_CTRL_CHANGE);
a00015d8:	1000000c 	b	a000160c <nand_command.constprop.2+0x8c>
a00015dc:	8e190028 	lw	t9,40(s0)
static int nand_command(struct mtd_info *mtd, int block, int page, int offs, u8 cmd)
{
	struct nand_chip *this = mtd->priv;
	int page_addr = page + block * CONFIG_SYS_NAND_PAGE_COUNT;

	if (this->dev_ready)
a00015e0:	00001021 	move	v0,zero
		while (!this->dev_ready(mtd))
			;
	else
		CONFIG_SYS_NAND_READ_DELAY;
a00015e4:	24032710 	li	v1,10000
a00015e8:	afa2001c 	sw	v0,28(sp)
a00015ec:	24420001 	addiu	v0,v0,1
a00015f0:	1443fffd 	bne	v0,v1,a00015e8 <nand_command.constprop.2+0x68>
a00015f4:	00000000 	nop

	/* Emulate NAND_CMD_READOOB */
	if (cmd == NAND_CMD_READOOB) {
a00015f8:	1000fff5 	b	a00015d0 <nand_command.constprop.2+0x50>
a00015fc:	24020050 	li	v0,80
		offs += CONFIG_SYS_NAND_PAGE_SIZE;
		cmd = NAND_CMD_READ0;
a0001600:	00009821 	move	s3,zero
	else
		CONFIG_SYS_NAND_READ_DELAY;

	/* Emulate NAND_CMD_READOOB */
	if (cmd == NAND_CMD_READOOB) {
		offs += CONFIG_SYS_NAND_PAGE_SIZE;
a0001604:	24140800 	li	s4,2048
		cmd = NAND_CMD_READ0;
	}

	/* Begin command latch cycle */
	this->cmd_ctrl(mtd, cmd, NAND_CTRL_CLE | NAND_CTRL_CHANGE);
a0001608:	8e190028 	lw	t9,40(s0)
a000160c:	02202021 	move	a0,s1
a0001610:	02602821 	move	a1,s3
a0001614:	0320f809 	jalr	t9
a0001618:	24060083 	li	a2,131
	/* Set ALE and clear CLE to start address cycle */
	/* Column address */
	this->cmd_ctrl(mtd, offs & 0xff,
a000161c:	8e190028 	lw	t9,40(s0)
a0001620:	02202021 	move	a0,s1
a0001624:	00002821 	move	a1,zero
a0001628:	0320f809 	jalr	t9
a000162c:	24060085 	li	a2,133
		       NAND_CTRL_ALE | NAND_CTRL_CHANGE); /* A[7:0] */
	this->cmd_ctrl(mtd, (offs >> 8) & 0xff, NAND_CTRL_ALE); /* A[11:9] */
a0001630:	8e190028 	lw	t9,40(s0)
a0001634:	02202021 	move	a0,s1
a0001638:	00142a02 	srl	a1,s4,0x8
a000163c:	0320f809 	jalr	t9
a0001640:	24060005 	li	a2,5
	/* Row address */
	this->cmd_ctrl(mtd, (page_addr & 0xff), NAND_CTRL_ALE); /* A[19:12] */
a0001644:	8e190028 	lw	t9,40(s0)
a0001648:	02202021 	move	a0,s1
a000164c:	324500ff 	andi	a1,s2,0xff
a0001650:	0320f809 	jalr	t9
a0001654:	24060005 	li	a2,5
	this->cmd_ctrl(mtd, ((page_addr >> 8) & 0xff),
a0001658:	8e190028 	lw	t9,40(s0)
a000165c:	02202021 	move	a0,s1
a0001660:	7e453a00 	ext	a1,s2,0x8,0x8
a0001664:	0320f809 	jalr	t9
a0001668:	24060005 	li	a2,5
		       NAND_CTRL_ALE); /* A[27:20] */
#ifdef CONFIG_SYS_NAND_5_ADDR_CYCLE
	/* One more address cycle for devices > 128MiB */
	this->cmd_ctrl(mtd, (page_addr >> 16) & 0x0f,
a000166c:	8e190028 	lw	t9,40(s0)
a0001670:	02202021 	move	a0,s1
a0001674:	7e451c00 	ext	a1,s2,0x10,0x4
a0001678:	0320f809 	jalr	t9
a000167c:	24060005 	li	a2,5
		       NAND_CTRL_ALE); /* A[31:28] */
#endif
	/* Latch in address */
	this->cmd_ctrl(mtd, NAND_CMD_READSTART,
a0001680:	8e190028 	lw	t9,40(s0)
a0001684:	02202021 	move	a0,s1
a0001688:	24050030 	li	a1,48
a000168c:	0320f809 	jalr	t9
a0001690:	24060083 	li	a2,131
		       NAND_CTRL_CLE | NAND_CTRL_CHANGE);
	this->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
a0001694:	8e190028 	lw	t9,40(s0)
a0001698:	02202021 	move	a0,s1
a000169c:	2405ffff 	li	a1,-1
a00016a0:	0320f809 	jalr	t9
a00016a4:	24060081 	li	a2,129

	/*
	 * Wait a while for the data to be ready
	 */
	if (this->dev_ready)
a00016a8:	8e020030 	lw	v0,48(s0)
a00016ac:	10400008 	beqz	v0,a00016d0 <nand_command.constprop.2+0x150>
a00016b0:	00001021 	move	v0,zero
		while (!this->dev_ready(mtd))
a00016b4:	8e190030 	lw	t9,48(s0)
a00016b8:	0320f809 	jalr	t9
a00016bc:	02202021 	move	a0,s1
a00016c0:	5040fffd 	beqzl	v0,a00016b8 <nand_command.constprop.2+0x138>
a00016c4:	8e190030 	lw	t9,48(s0)
			;
	else
		CONFIG_SYS_NAND_READ_DELAY;

	return 0;
}
a00016c8:	10000006 	b	a00016e4 <nand_command.constprop.2+0x164>
a00016cc:	8fbf0034 	lw	ra,52(sp)
	 */
	if (this->dev_ready)
		while (!this->dev_ready(mtd))
			;
	else
		CONFIG_SYS_NAND_READ_DELAY;
a00016d0:	24032710 	li	v1,10000
a00016d4:	afa20018 	sw	v0,24(sp)
a00016d8:	24420001 	addiu	v0,v0,1
a00016dc:	1443fffd 	bne	v0,v1,a00016d4 <nand_command.constprop.2+0x154>
a00016e0:	8fbf0034 	lw	ra,52(sp)

	return 0;
}
a00016e4:	8fb40030 	lw	s4,48(sp)
a00016e8:	8fb3002c 	lw	s3,44(sp)
a00016ec:	8fb20028 	lw	s2,40(sp)
a00016f0:	8fb10024 	lw	s1,36(sp)
a00016f4:	8fb00020 	lw	s0,32(sp)
a00016f8:	00001021 	move	v0,zero
a00016fc:	03e00008 	jr	ra
a0001700:	27bd0038 	addiu	sp,sp,56

a0001704 <nand_boot>:
 * The main entry for NAND booting. It's necessary that SDRAM is already
 * configured and available since this code loads the main U-Boot image
 * from NAND into SDRAM and starts it from there.
 */
void nand_boot(void)
{
a0001704:	3c1c0000 	lui	gp,0x0
a0001708:	279c423c 	addiu	gp,gp,16956
a000170c:	0399e021 	addu	gp,gp,t9
a0001710:	27bdfbd0 	addiu	sp,sp,-1072
#if defined(CONFIG_DRIVER_GRX500) && !defined(CONFIG_GRX500_BOOT_4KEC_ONLY)
    /* Since IAP has already initialised the H/W, we do not want to 
     * reset the nand datapath when 4kec boots. Otherwise, there will
     * be an unknown state for the controller when IAP access the EBU bus 
     */
    if (!cpu_is_cps())
a0001714:	8f99004c 	lw	t9,76(gp)
 * The main entry for NAND booting. It's necessary that SDRAM is already
 * configured and available since this code loads the main U-Boot image
 * from NAND into SDRAM and starts it from there.
 */
void nand_boot(void)
{
a0001718:	afbc0010 	sw	gp,16(sp)
a000171c:	afbf042c 	sw	ra,1068(sp)
a0001720:	afbe0428 	sw	s8,1064(sp)
a0001724:	afb70424 	sw	s7,1060(sp)
a0001728:	afb60420 	sw	s6,1056(sp)
a000172c:	afb5041c 	sw	s5,1052(sp)
a0001730:	afb40418 	sw	s4,1048(sp)
a0001734:	afb30414 	sw	s3,1044(sp)
a0001738:	afb20410 	sw	s2,1040(sp)
a000173c:	afb1040c 	sw	s1,1036(sp)
#if defined(CONFIG_DRIVER_GRX500) && !defined(CONFIG_GRX500_BOOT_4KEC_ONLY)
    /* Since IAP has already initialised the H/W, we do not want to 
     * reset the nand datapath when 4kec boots. Otherwise, there will
     * be an unknown state for the controller when IAP access the EBU bus 
     */
    if (!cpu_is_cps())
a0001740:	0320f809 	jalr	t9
a0001744:	afb00408 	sw	s0,1032(sp)
a0001748:	10400017 	beqz	v0,a00017a8 <nand_boot+0xa4>
a000174c:	8fbc0010 	lw	gp,16(sp)
        goto cpy_bootcore;
#endif

	memset(&nand_chip, 0, sizeof(struct nand_chip));
a0001750:	8f990050 	lw	t9,80(gp)
a0001754:	27b00018 	addiu	s0,sp,24
a0001758:	02002021 	move	a0,s0
a000175c:	00002821 	move	a1,zero
a0001760:	0320f809 	jalr	t9
a0001764:	24060328 	li	a2,808
a0001768:	8fbc0010 	lw	gp,16(sp)
	/*
	 * Init board specific nand support
	 */
	nand_info.priv = &nand_chip;
	
	nand_chip.IO_ADDR_R = nand_chip.IO_ADDR_W = (void  __iomem *)CONFIG_SYS_NAND_BASE;
a000176c:	3c02b7c0 	lui	v0,0xb7c0

	memset(&nand_chip, 0, sizeof(struct nand_chip));
	/*
	 * Init board specific nand support
	 */
	nand_info.priv = &nand_chip;
a0001770:	afb003e0 	sw	s0,992(sp)
	
	nand_chip.IO_ADDR_R = nand_chip.IO_ADDR_W = (void  __iomem *)CONFIG_SYS_NAND_BASE;
	nand_chip.dev_ready = NULL;	/* preset to NULL */
	board_nand_init(&nand_chip);
a0001774:	8f990054 	lw	t9,84(gp)
	/*
	 * Init board specific nand support
	 */
	nand_info.priv = &nand_chip;
	
	nand_chip.IO_ADDR_R = nand_chip.IO_ADDR_W = (void  __iomem *)CONFIG_SYS_NAND_BASE;
a0001778:	afa2001c 	sw	v0,28(sp)
a000177c:	afa20018 	sw	v0,24(sp)
	nand_chip.dev_ready = NULL;	/* preset to NULL */
a0001780:	afa00048 	sw	zero,72(sp)
	board_nand_init(&nand_chip);
a0001784:	0320f809 	jalr	t9
a0001788:	02002021 	move	a0,s0

	if (nand_chip.select_chip)
a000178c:	8fb90034 	lw	t9,52(sp)
a0001790:	13200005 	beqz	t9,a00017a8 <nand_boot+0xa4>
a0001794:	8fbc0010 	lw	gp,16(sp)
		nand_chip.select_chip(&nand_info, 0);
a0001798:	27a40340 	addiu	a0,sp,832
a000179c:	0320f809 	jalr	t9
a00017a0:	00002821 	move	a1,zero
a00017a4:	8fbc0010 	lw	gp,16(sp)
	nand_ecc_pos = &ecc->eccpos;
#endif

cpy_bootcore:
#if !defined(CONFIG_GRX500_BOOT_4KEC_ONLY) && defined(CONFIG_DRIVER_GRX500)
    if (cpu_is_cps()) {
a00017a8:	8f99004c 	lw	t9,76(gp)
a00017ac:	0320f809 	jalr	t9
a00017b0:	00000000 	nop
a00017b4:	10400071 	beqz	v0,a000197c <nand_boot+0x278>
a00017b8:	8fbc0010 	lw	gp,16(sp)
#ifdef CONFIG_NAND_SPL_BBT	
	if(bbt_valid){
      return nand_isbad_bbt(mtd, block<<this->bbt_erase_shift, 1);
	}else{
#endif	
	 nand_command(mtd, block, 0, CONFIG_SYS_NAND_BAD_BLOCK_POS, NAND_CMD_READOOB);
a00017bc:	8f960058 	lw	s6,88(gp)
	nand_ecc_pos = &ecc->eccpos;
#endif

cpy_bootcore:
#if !defined(CONFIG_GRX500_BOOT_4KEC_ONLY) && defined(CONFIG_DRIVER_GRX500)
    if (cpu_is_cps()) {
a00017c0:	2411000c 	li	s1,12
a00017c4:	3c138020 	lui	s3,0x8020
a00017c8:	24150002 	li	s5,2
a00017cc:	00009021 	move	s2,zero
#ifdef CONFIG_NAND_SPL_BBT	
	if(bbt_valid){
      return nand_isbad_bbt(mtd, block<<this->bbt_erase_shift, 1);
	}else{
#endif	
	 nand_command(mtd, block, 0, CONFIG_SYS_NAND_BAD_BLOCK_POS, NAND_CMD_READOOB);
a00017d0:	26d61580 	addiu	s6,s6,5504
}
#endif

static int nand_is_bad_block(struct mtd_info *mtd, int block)
{
	struct nand_chip *this = mtd->priv;
a00017d4:	8fb403e0 	lw	s4,992(sp)
#ifdef CONFIG_NAND_SPL_BBT	
	if(bbt_valid){
      return nand_isbad_bbt(mtd, block<<this->bbt_erase_shift, 1);
	}else{
#endif	
	 nand_command(mtd, block, 0, CONFIG_SYS_NAND_BAD_BLOCK_POS, NAND_CMD_READOOB);
a00017d8:	27b00340 	addiu	s0,sp,832
a00017dc:	02002021 	move	a0,s0
a00017e0:	02402821 	move	a1,s2
a00017e4:	00003021 	move	a2,zero
a00017e8:	02c0c821 	move	t9,s6
a00017ec:	0320f809 	jalr	t9
a00017f0:	24070050 	li	a3,80

	 /*
	 * Read one byte
	 */
	if (readb(this->IO_ADDR_R) != 0xff)
a00017f4:	8e820000 	lw	v0,0(s4)
#ifdef CONFIG_NAND_SPL_BBT	
	if(bbt_valid){
      return nand_isbad_bbt(mtd, block<<this->bbt_erase_shift, 1);
	}else{
#endif	
	 nand_command(mtd, block, 0, CONFIG_SYS_NAND_BAD_BLOCK_POS, NAND_CMD_READOOB);
a00017f8:	8fbc0010 	lw	gp,16(sp)

	 /*
	 * Read one byte
	 */
	if (readb(this->IO_ADDR_R) != 0xff)
a00017fc:	90430000 	lbu	v1,0(v0)
a0001800:	240200ff 	li	v0,255
a0001804:	306300ff 	andi	v1,v1,0xff
a0001808:	54620050 	bnel	v1,v0,a000194c <nand_boot+0x248>
a000180c:	26b50001 	addiu	s5,s5,1
    int eccsteps = CONFIG_SYS_NAND_ECCSTEPS;

	uint8_t *p = dst;
	int stat;

	nand_command(mtd, block, page, 0, NAND_CMD_READ0);
a0001810:	8f990058 	lw	t9,88(gp)
a0001814:	02002021 	move	a0,s0
a0001818:	02402821 	move	a1,s2
a000181c:	02203021 	move	a2,s1
a0001820:	00003821 	move	a3,zero
a0001824:	27391580 	addiu	t9,t9,5504
a0001828:	0260a021 	move	s4,s3
a000182c:	3c1e8001 	lui	s8,0x8001
a0001830:	0320f809 	jalr	t9
a0001834:	8fb703e0 	lw	s7,992(sp)
	ecc_calc = (u_char *)(CONFIG_SYS_SDRAM_BASE + 0x10000);
	ecc_code = ecc_calc + 0x10000;
	oob_data = ecc_calc + 0x20000;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
		this->ecc.hwctl(mtd, NAND_ECC_READ);
a0001838:	8ef902c0 	lw	t9,704(s7)
a000183c:	02002021 	move	a0,s0
a0001840:	0320f809 	jalr	t9
a0001844:	00002821 	move	a1,zero
		this->read_buf(mtd, p, eccsize);
a0001848:	8ef90014 	lw	t9,20(s7)
a000184c:	02802821 	move	a1,s4
a0001850:	02002021 	move	a0,s0
a0001854:	0320f809 	jalr	t9
a0001858:	24060100 	li	a2,256
		this->ecc.calculate(mtd, p, &ecc_calc[i]);
a000185c:	8ef902c4 	lw	t9,708(s7)
a0001860:	02802821 	move	a1,s4
a0001864:	03c03021 	move	a2,s8
a0001868:	0320f809 	jalr	t9
a000186c:	02002021 	move	a0,s0
	 */
	ecc_calc = (u_char *)(CONFIG_SYS_SDRAM_BASE + 0x10000);
	ecc_code = ecc_calc + 0x10000;
	oob_data = ecc_calc + 0x20000;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
a0001870:	3c028001 	lui	v0,0x8001
a0001874:	27de0003 	addiu	s8,s8,3
a0001878:	34420018 	ori	v0,v0,0x18
a000187c:	17c2ffee 	bne	s8,v0,a0001838 <nand_boot+0x134>
a0001880:	26940100 	addiu	s4,s4,256
		this->ecc.hwctl(mtd, NAND_ECC_READ);
		this->read_buf(mtd, p, eccsize);
		this->ecc.calculate(mtd, p, &ecc_calc[i]);
	}
	this->read_buf(mtd, oob_data, CONFIG_NAND_SPL_OOBSIZE);
a0001884:	8ef90014 	lw	t9,20(s7)
a0001888:	02002021 	move	a0,s0
a000188c:	24060040 	li	a2,64
a0001890:	0320f809 	jalr	t9
a0001894:	3c058003 	lui	a1,0x8003
a0001898:	3c028002 	lui	v0,0x8002
a000189c:	8fbc0010 	lw	gp,16(sp)
a00018a0:	3c07fff8 	lui	a3,0xfff8

	/* Pick the ECC bytes out of the oob data */
	for (i = 0; i < CONFIG_SYS_NAND_ECCTOTAL; i++) {
		ecc_code[i] = oob_data[nand_ecc_pos[i]];
a00018a4:	3c068003 	lui	a2,0x8003
		this->ecc.calculate(mtd, p, &ecc_calc[i]);
	}
	this->read_buf(mtd, oob_data, CONFIG_NAND_SPL_OOBSIZE);

	/* Pick the ECC bytes out of the oob data */
	for (i = 0; i < CONFIG_SYS_NAND_ECCTOTAL; i++) {
a00018a8:	24440018 	addiu	a0,v0,24
	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
		this->ecc.hwctl(mtd, NAND_ECC_READ);
		this->read_buf(mtd, p, eccsize);
		this->ecc.calculate(mtd, p, &ecc_calc[i]);
	}
	this->read_buf(mtd, oob_data, CONFIG_NAND_SPL_OOBSIZE);
a00018ac:	8f830058 	lw	v1,88(gp)
a00018b0:	00022880 	sll	a1,v0,0x2
a00018b4:	24635340 	addiu	v1,v1,21312
a00018b8:	00652821 	addu	a1,v1,a1
a00018bc:	00a72821 	addu	a1,a1,a3
a00018c0:	24420001 	addiu	v0,v0,1

	/* Pick the ECC bytes out of the oob data */
	for (i = 0; i < CONFIG_SYS_NAND_ECCTOTAL; i++) {
		ecc_code[i] = oob_data[nand_ecc_pos[i]];
a00018c4:	8ca50000 	lw	a1,0(a1)
a00018c8:	00c52821 	addu	a1,a2,a1
a00018cc:	90a50000 	lbu	a1,0(a1)
		this->ecc.calculate(mtd, p, &ecc_calc[i]);
	}
	this->read_buf(mtd, oob_data, CONFIG_NAND_SPL_OOBSIZE);

	/* Pick the ECC bytes out of the oob data */
	for (i = 0; i < CONFIG_SYS_NAND_ECCTOTAL; i++) {
a00018d0:	1444fff6 	bne	v0,a0,a00018ac <nand_boot+0x1a8>
a00018d4:	a045ffff 	sb	a1,-1(v0)
		ecc_code[i] = oob_data[nand_ecc_pos[i]];
	}

	eccsteps = this->ecc.steps;
a00018d8:	8ee802a0 	lw	t0,672(s7)
a00018dc:	02604821 	move	t1,s3
a00018e0:	3c148002 	lui	s4,0x8002
a00018e4:	3c0affff 	lui	t2,0xffff
	p = dst;

	for (i = 0; eccsteps > 0; eccsteps--, i += eccbytes, p += eccsize) {
a00018e8:	1900000f 	blez	t0,a0001928 <nand_boot+0x224>
a00018ec:	028a3821 	addu	a3,s4,t2
		/* No chance to do something with the possible error message
		 * from correct_data(). We just hope that all possible errors
		 * are corrected by this routine.
		 */
		stat = this->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
a00018f0:	8ef902c8 	lw	t9,712(s7)
a00018f4:	01202821 	move	a1,t1
a00018f8:	02803021 	move	a2,s4
a00018fc:	afa803fc 	sw	t0,1020(sp)
a0001900:	afa903f8 	sw	t1,1016(sp)
a0001904:	afaa0400 	sw	t2,1024(sp)
a0001908:	0320f809 	jalr	t9
a000190c:	02002021 	move	a0,s0
a0001910:	26940003 	addiu	s4,s4,3
a0001914:	8fbc0010 	lw	gp,16(sp)
		if (stat < 0)
a0001918:	8fa803fc 	lw	t0,1020(sp)
a000191c:	8fa903f8 	lw	t1,1016(sp)
a0001920:	04410007 	bgez	v0,a0001940 <nand_boot+0x23c>
a0001924:	8faa0400 	lw	t2,1024(sp)
			 * Skip bad blocks
			 */
			while (page < CONFIG_SYS_NAND_PAGE_COUNT) {
				nand_read_page(mtd, block, page, dst);
				dst += CONFIG_SYS_NAND_PAGE_SIZE;
				page++;
a0001928:	26310001 	addiu	s1,s1,1
	while (block <= lastblock) {
				if (!nand_is_bad_block(mtd,block)){
			/*
			 * Skip bad blocks
			 */
			while (page < CONFIG_SYS_NAND_PAGE_COUNT) {
a000192c:	2e220040 	sltiu	v0,s1,64
a0001930:	1440ffb7 	bnez	v0,a0001810 <nand_boot+0x10c>
a0001934:	26730800 	addiu	s3,s3,2048
				nand_read_page(mtd, block, page, dst);
				dst += CONFIG_SYS_NAND_PAGE_SIZE;
				page++;
			}

			page = 0;
a0001938:	10000004 	b	a000194c <nand_boot+0x248>
a000193c:	00008821 	move	s1,zero
	}

	eccsteps = this->ecc.steps;
	p = dst;

	for (i = 0; eccsteps > 0; eccsteps--, i += eccbytes, p += eccsize) {
a0001940:	2508ffff 	addiu	t0,t0,-1
a0001944:	1000ffe8 	b	a00018e8 <nand_boot+0x1e4>
a0001948:	25290100 	addiu	t1,t1,256
			page = 0;
		} else {
			lastblock++;
		}

		block++;
a000194c:	26520001 	addiu	s2,s2,1
	 */
	block = offs / CONFIG_SYS_NAND_BLOCK_SIZE;
	lastblock = (offs + uboot_size - 1) / CONFIG_SYS_NAND_BLOCK_SIZE;
	page = (offs % CONFIG_SYS_NAND_BLOCK_SIZE) / CONFIG_SYS_NAND_PAGE_SIZE;

	while (block <= lastblock) {
a0001950:	02b2102b 	sltu	v0,s5,s2
a0001954:	1040ffa0 	beqz	v0,a00017d8 <nand_boot+0xd4>
a0001958:	8fb403e0 	lw	s4,992(sp)
	nand_load(&nand_info, CONFIG_ENV_OFFSET_REDUND, CONFIG_ENV_SIZE,
		  (uchar *)CONFIG_NAND_ENV_DST + CONFIG_ENV_SIZE);
#endif /* CONFIG_ENV_OFFSET_REDUND */
#endif /* CONFIG_NAND_ENV_DST */

	if (nand_chip.select_chip)
a000195c:	8fb90034 	lw	t9,52(sp)
a0001960:	13200003 	beqz	t9,a0001970 <nand_boot+0x26c>
a0001964:	02002021 	move	a0,s0
		nand_chip.select_chip(&nand_info, -1);
a0001968:	0320f809 	jalr	t9
a000196c:	2405ffff 	li	a1,-1

       asm("sync");
a0001970:	0000000f 	sync
#endif /* CONFIG_MANUBOOT */
	/*
	 * Jump to U-Boot image
	 */
	uboot = (void *)CONFIG_SYS_NAND_U_BOOT_START;
	(*uboot)();
a0001974:	10000024 	b	a0001a08 <nand_boot+0x304>
a0001978:	3c198020 	lui	t9,0x8020
    } else {
        ulong load_address;
        ulong jump_address;
		ulong ddr_address, bootcore_size;

		asm("sync");
a000197c:	0000000f 	sync
		load_address = REG32(MPS_LOAD_ADDR); /* 4Kec load addr */
a0001980:	3c02bf80 	lui	v0,0xbf80
        bootrom_auth((u32)ddr_address);

        /* safeguard , but shall never come here in first place*/
        while(1);
        #else /* defined(CONFIG_LTQ_SECURE_BOOT) && !defined(CONFIG_MANUBOOT) */
		memcpy((unsigned char *) load_address, 
a0001984:	8f99005c 	lw	t9,92(gp)
        ulong load_address;
        ulong jump_address;
		ulong ddr_address, bootcore_size;

		asm("sync");
		load_address = REG32(MPS_LOAD_ADDR); /* 4Kec load addr */
a0001988:	8c507f0c 	lw	s0,32524(v0)
		ddr_address = REG32(MPS_DDR_LOC);	 /* ddr where TOS is copied to */
a000198c:	8c457f04 	lw	a1,32516(v0)
		bootcore_size = REG32(MPS_SIZE_LOC); /* size of TOS/bootcore img */
a0001990:	8c467f08 	lw	a2,32520(v0)
        bootrom_auth((u32)ddr_address);

        /* safeguard , but shall never come here in first place*/
        while(1);
        #else /* defined(CONFIG_LTQ_SECURE_BOOT) && !defined(CONFIG_MANUBOOT) */
		memcpy((unsigned char *) load_address, 
a0001994:	0320f809 	jalr	t9
a0001998:	02002021 	move	a0,s0
    u32 ret_check, checksum = 0;
	u32 hdr_len, load_addr;
	image_header_t *pimg_header = (image_header_t *)src;
    
	/* check magic number */
	if (ntohl(pimg_header->ih_magic) != IH_MAGIC)
a000199c:	3c022705 	lui	v0,0x2705
a00019a0:	8e030000 	lw	v1,0(s0)
a00019a4:	24421956 	addiu	v0,v0,6486
a00019a8:	14620019 	bne	v1,v0,a0001a10 <nand_boot+0x30c>
a00019ac:	8fbc0010 	lw	gp,16(sp)
		return -1;

	asm("sync");
a00019b0:	0000000f 	sync
	/* mkimage type kernel without the 8B offset */
	image_start = (u8 *)pimg_header + sizeof(image_header_t);
a00019b4:	26130040 	addiu	s3,s0,64
    image_len = ntohl(pimg_header->ih_size);
a00019b8:	8e12000c 	lw	s2,12(s0)
	load_addr = ntohl(pimg_header->ih_load);
a00019bc:	8e110010 	lw	s1,16(s0)
	*jmp_addr = load_addr;
	asm("sync");
a00019c0:	0000000f 	sync

	hdr_len = sizeof(image_header_t);
	checksum = ntohl(pimg_header->ih_hcrc);
a00019c4:	8e140004 	lw	s4,4(s0)
	pimg_header->ih_hcrc = 0;
a00019c8:	ae000004 	sw	zero,4(s0)

	asm("sync");
a00019cc:	0000000f 	sync
	ret_check = crc32(0, (unsigned char *) src, hdr_len);
a00019d0:	8f990060 	lw	t9,96(gp)
a00019d4:	00002021 	move	a0,zero
a00019d8:	02002821 	move	a1,s0
a00019dc:	0320f809 	jalr	t9
a00019e0:	24060040 	li	a2,64
	if (ret_check != checksum)
a00019e4:	1454000a 	bne	v0,s4,a0001a10 <nand_boot+0x30c>
a00019e8:	8fbc0010 	lw	gp,16(sp)
		return -1;

	asm("sync");
a00019ec:	0000000f 	sync
	memcpy((u32 *) load_addr, (u32 *)image_start, image_len);
a00019f0:	8f99005c 	lw	t9,92(gp)
a00019f4:	02202021 	move	a0,s1
a00019f8:	02602821 	move	a1,s3
a00019fc:	0320f809 	jalr	t9
a0001a00:	02403021 	move	a2,s2
								bootcore_size);
		if (ret)
			while(1); // if img is bad, we prevent 4kec from loading it

        uboot = (void*)jump_address;
        (*uboot)();
a0001a04:	0220c821 	move	t9,s1
a0001a08:	0320f809 	jalr	t9
a0001a0c:	00000000 	nop
a0001a10:	1000ffff 	b	a0001a10 <nand_boot+0x30c>
a0001a14:	00000000 	nop
	...

a0001a20 <lq_enable_hwecc>:
#else
extern int nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code);
extern int nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc);
#endif
static void lq_enable_hwecc(struct mtd_info *mtd, int mode)
{
a0001a20:	03e00008 	jr	ra
a0001a24:	00000000 	nop

a0001a28 <NanD_WaitReady>:


static int NanD_WaitReady(struct mtd_info *mtd)
{
      struct nand_chip *nand = mtd->priv;
	  NAND_WAIT_READY(nand);
a0001a28:	3c03b6f0 	lui	v1,0xb6f0
a0001a2c:	8c6200b4 	lw	v0,180(v1)
a0001a30:	30420001 	andi	v0,v0,0x1
a0001a34:	1040fffd 	beqz	v0,a0001a2c <NanD_WaitReady+0x4>
a0001a38:	24020001 	li	v0,1
	  return 1;
}
a0001a3c:	03e00008 	jr	ra
a0001a40:	00000000 	nop

a0001a44 <ifx_nand_read_byte>:
 */
static u_char ifx_nand_read_byte(struct mtd_info *mtd)
{
      struct nand_chip *nand = mtd->priv;
      u_char ret;
      asm("sync");
a0001a44:	0000000f 	sync
      NAND_READ(READ_DATA, ret); 
a0001a48:	3c02b7c0 	lui	v0,0xb7c0
a0001a4c:	3c04b6f0 	lui	a0,0xb6f0
a0001a50:	90420010 	lbu	v0,16(v0)
a0001a54:	304200ff 	andi	v0,v0,0xff
a0001a58:	8c8300b4 	lw	v1,180(a0)
a0001a5c:	30630008 	andi	v1,v1,0x8
a0001a60:	1060fffd 	beqz	v1,a0001a58 <ifx_nand_read_byte+0x14>
a0001a64:	00000000 	nop
      asm("sync");
a0001a68:	0000000f 	sync
      //printf("read_byte: %02x\n",ret);
      return ret;
}
a0001a6c:	03e00008 	jr	ra
a0001a70:	00000000 	nop

a0001a74 <ifx_nand_read_buf>:
static void ifx_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
{
        int i;
        struct nand_chip *chip = mtd->priv;

        for (i = 0; i < len; i++){
a0001a74:	00001021 	move	v0,zero
		         NAND_READ(READ_DATA, buf[i]);
a0001a78:	3c04b7c0 	lui	a0,0xb7c0
a0001a7c:	3c07b6f0 	lui	a3,0xb6f0
static void ifx_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
{
        int i;
        struct nand_chip *chip = mtd->priv;

        for (i = 0; i < len; i++){
a0001a80:	0046182a 	slt	v1,v0,a2
a0001a84:	1060000a 	beqz	v1,a0001ab0 <ifx_nand_read_buf+0x3c>
a0001a88:	00000000 	nop
		         NAND_READ(READ_DATA, buf[i]);
a0001a8c:	90880010 	lbu	t0,16(a0)
a0001a90:	00a21821 	addu	v1,a1,v0
a0001a94:	a0680000 	sb	t0,0(v1)
a0001a98:	8ce300b4 	lw	v1,180(a3)
a0001a9c:	30630008 	andi	v1,v1,0x8
a0001aa0:	1060fffd 	beqz	v1,a0001a98 <ifx_nand_read_buf+0x24>
a0001aa4:	00000000 	nop
static void ifx_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
{
        int i;
        struct nand_chip *chip = mtd->priv;

        for (i = 0; i < len; i++){
a0001aa8:	1000fff5 	b	a0001a80 <ifx_nand_read_buf+0xc>
a0001aac:	24420001 	addiu	v0,v0,1
		         NAND_READ(READ_DATA, buf[i]);
				}

}
a0001ab0:	03e00008 	jr	ra
a0001ab4:	00000000 	nop

a0001ab8 <ifx_nand_cmd_ctrl>:
#define NAND_ECC_STATUS_2_BIT_ERR       0x10
#define NAND_ECC_STATUS_3_BIT_ERR       0x08
#define NAND_ECC_STATUS_4_BIT_ERR       0x18

static void ifx_nand_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)
{
a0001ab8:	3c1c0000 	lui	gp,0x0
a0001abc:	279c3e88 	addiu	gp,gp,16008
a0001ac0:	0399e021 	addu	gp,gp,t9
     struct nand_chip *chip = mtd->priv;
	 unsigned int oob_features = 0;

     if(ctrl & NAND_CTRL_CHANGE){
a0001ac4:	30c20080 	andi	v0,a2,0x80
a0001ac8:	10400029 	beqz	v0,a0001b70 <ifx_nand_cmd_ctrl+0xb8>
a0001acc:	2402ffff 	li	v0,-1
        if( ctrl & NAND_ALE ){
a0001ad0:	30c20004 	andi	v0,a2,0x4
a0001ad4:	1040000d 	beqz	v0,a0001b0c <ifx_nand_cmd_ctrl+0x54>
a0001ad8:	8f830058 	lw	v1,88(gp)
				 NAND_CLRCLE;
a0001adc:	3c02b6f0 	lui	v0,0xb6f0
a0001ae0:	3c06fff7 	lui	a2,0xfff7
a0001ae4:	8c4700b0 	lw	a3,176(v0)
a0001ae8:	34c6ffff 	ori	a2,a2,0xffff
a0001aec:	00e63024 	and	a2,a3,a2
a0001af0:	ac4600b0 	sw	a2,176(v0)
        	     NAND_SETALE;
a0001af4:	8c4700b0 	lw	a3,176(v0)
a0001af8:	3c060004 	lui	a2,0x4
a0001afc:	00e63025 	or	a2,a3,a2
a0001b00:	ac4600b0 	sw	a2,176(v0)
		         latchcmd = WRITE_ADDR;
a0001b04:	10000018 	b	a0001b68 <ifx_nand_cmd_ctrl+0xb0>
a0001b08:	24020014 	li	v0,20
a0001b0c:	3c07fffb 	lui	a3,0xfffb
		        }
		    else if( ctrl & NAND_CLE ){
a0001b10:	30c60002 	andi	a2,a2,0x2
a0001b14:	34e7ffff 	ori	a3,a3,0xffff
a0001b18:	10c0000a 	beqz	a2,a0001b44 <ifx_nand_cmd_ctrl+0x8c>
a0001b1c:	3c02b6f0 	lui	v0,0xb6f0
		    	   NAND_CLRALE;
a0001b20:	8c4600b0 	lw	a2,176(v0)
a0001b24:	00c73824 	and	a3,a2,a3
		    	   NAND_SETCLE;
a0001b28:	3c060008 	lui	a2,0x8
				 NAND_CLRCLE;
        	     NAND_SETALE;
		         latchcmd = WRITE_ADDR;
		        }
		    else if( ctrl & NAND_CLE ){
		    	   NAND_CLRALE;
a0001b2c:	ac4700b0 	sw	a3,176(v0)
		    	   NAND_SETCLE;
a0001b30:	8c4700b0 	lw	a3,176(v0)
a0001b34:	00e63025 	or	a2,a3,a2
a0001b38:	ac4600b0 	sw	a2,176(v0)
		         latchcmd = WRITE_CMD;
a0001b3c:	1000000a 	b	a0001b68 <ifx_nand_cmd_ctrl+0xb0>
a0001b40:	24020018 	li	v0,24
		        }
           else{
		       NAND_CLRALE;
a0001b44:	8c4600b0 	lw	a2,176(v0)
a0001b48:	00c73824 	and	a3,a2,a3
			     NAND_CLRCLE;
a0001b4c:	3c06fff7 	lui	a2,0xfff7
		    	   NAND_CLRALE;
		    	   NAND_SETCLE;
		         latchcmd = WRITE_CMD;
		        }
           else{
		       NAND_CLRALE;
a0001b50:	ac4700b0 	sw	a3,176(v0)
			     NAND_CLRCLE;
a0001b54:	8c4700b0 	lw	a3,176(v0)
a0001b58:	34c6ffff 	ori	a2,a2,0xffff
a0001b5c:	00e63024 	and	a2,a3,a2
a0001b60:	ac4600b0 	sw	a2,176(v0)
			     latchcmd = WRITE_DATA;
a0001b64:	24020010 	li	v0,16
a0001b68:	ac625a60 	sw	v0,23136(v1)
		       }
	   }
	   if(cmd!=NAND_CMD_NONE){
a0001b6c:	2402ffff 	li	v0,-1
a0001b70:	10a2000c 	beq	a1,v0,a0001ba4 <ifx_nand_cmd_ctrl+0xec>
a0001b74:	30a500ff 	andi	a1,a1,0xff
 * Default write function for 8it buswith
 */
static void ifx_nand_write_byte(struct mtd_info *mtd, u_char byte)
{
      struct nand_chip *this = mtd->priv;
      *(volatile u8*)((u32)this->IO_ADDR_W | latchcmd)=byte;
a0001b78:	8c8200a0 	lw	v0,160(a0)
a0001b7c:	8c430004 	lw	v1,4(v0)
a0001b80:	8f820058 	lw	v0,88(gp)
a0001b84:	8c425a60 	lw	v0,23136(v0)
a0001b88:	00621025 	or	v0,v1,v0
a0001b8c:	a0450000 	sb	a1,0(v0)
      while((*EBU_NAND_WAIT & 0x08) == 0);
a0001b90:	3c03b6f0 	lui	v1,0xb6f0
a0001b94:	8c6200b4 	lw	v0,180(v1)
a0001b98:	30420008 	andi	v0,v0,0x8
a0001b9c:	1040fffd 	beqz	v0,a0001b94 <ifx_nand_cmd_ctrl+0xdc>
a0001ba0:	00000000 	nop
a0001ba4:	03e00008 	jr	ra
a0001ba8:	00000000 	nop

a0001bac <ifx_nand_select_chip>:
 */
static void ifx_nand_select_chip(struct mtd_info *mtd, int chip)
{
      struct nand_chip *nand = mtd->priv;

        switch (chip) {
a0001bac:	2402ffff 	li	v0,-1
a0001bb0:	10a20005 	beq	a1,v0,a0001bc8 <ifx_nand_select_chip+0x1c>
a0001bb4:	240305f3 	li	v1,1523
a0001bb8:	10a00009 	beqz	a1,a0001be0 <ifx_nand_select_chip+0x34>
a0001bbc:	3c02b6f0 	lui	v0,0xb6f0
a0001bc0:	03e00008 	jr	ra
a0001bc4:	00000000 	nop
        case -1:
                NAND_CE_CLEAR;
a0001bc8:	3c02b6f0 	lui	v0,0xb6f0
a0001bcc:	ac4300b0 	sw	v1,176(v0)
				*EBU_NAND_CON &=~(0x1);
a0001bd0:	8c4400b0 	lw	a0,176(v0)
a0001bd4:	2403fffe 	li	v1,-2
a0001bd8:	10000006 	b	a0001bf4 <ifx_nand_select_chip+0x48>
a0001bdc:	00831824 	and	v1,a0,v1
			    break;
        case 0:
		        *EBU_NAND_CON |=(0x1);
a0001be0:	8c4300b0 	lw	v1,176(v0)
a0001be4:	34630001 	ori	v1,v1,0x1
a0001be8:	ac4300b0 	sw	v1,176(v0)
				NAND_CE_SET;
a0001bec:	3c0300f4 	lui	v1,0xf4
a0001bf0:	246305f3 	addiu	v1,v1,1523
a0001bf4:	ac4300b0 	sw	v1,176(v0)
a0001bf8:	03e00008 	jr	ra
a0001bfc:	00000000 	nop

a0001c00 <board_nand_init>:
 *   explanation
 * Members with a "?" were not set in the merged testing-NAND branch,
 * so they are not set here either.
 */
int board_nand_init(struct nand_chip *nand)
{
a0001c00:	3c1c0000 	lui	gp,0x0
a0001c04:	279c3d40 	addiu	gp,gp,15680
a0001c08:	0399e021 	addu	gp,gp,t9
a0001c0c:	27bdffe0 	addiu	sp,sp,-32
{
         volatile unsigned char tmpc[5];
         volatile unsigned char buf;
         int i;

		 nand_gpio_init();
a0001c10:	8f990064 	lw	t9,100(gp)
 *   explanation
 * Members with a "?" were not set in the merged testing-NAND branch,
 * so they are not set here either.
 */
int board_nand_init(struct nand_chip *nand)
{
a0001c14:	afbf001c 	sw	ra,28(sp)
a0001c18:	afb00018 	sw	s0,24(sp)
a0001c1c:	afbc0010 	sw	gp,16(sp)
{
         volatile unsigned char tmpc[5];
         volatile unsigned char buf;
         int i;

		 nand_gpio_init();
a0001c20:	0320f809 	jalr	t9
a0001c24:	00808021 	move	s0,a0

#ifdef CONFIG_NAND_CS0
         *EBU_CON_0    = 0x40c7fe;
         *EBU_NAND_CON = 0x000000F2; 
#else
		 *EBU_ADDR_SEL_1 = (NAND_BASE_ADDRESS&0x1fffff00)|0x31;
a0001c28:	3c0317c0 	lui	v1,0x17c0
a0001c2c:	24630031 	addiu	v1,v1,49
a0001c30:	3c02b6f0 	lui	v0,0xb6f0
{
         volatile unsigned char tmpc[5];
         volatile unsigned char buf;
         int i;

		 nand_gpio_init();
a0001c34:	8fbc0010 	lw	gp,16(sp)

#ifdef CONFIG_NAND_CS0
         *EBU_CON_0    = 0x40c7fe;
         *EBU_NAND_CON = 0x000000F2; 
#else
		 *EBU_ADDR_SEL_1 = (NAND_BASE_ADDRESS&0x1fffff00)|0x31;
a0001c38:	ac430024 	sw	v1,36(v0)
		 /* byte swap;minimum
          * delay*/
		 *EBU_CON_1	= 0x40F295;
a0001c3c:	3c030040 	lui	v1,0x40
a0001c40:	3463f295 	ori	v1,v1,0xf295
a0001c44:	ac430064 	sw	v1,100(v0)
	     *EBU_NAND_CON = 0x000005F2;
a0001c48:	240305f2 	li	v1,1522
a0001c4c:	ac4300b0 	sw	v1,176(v0)
 */
int board_nand_init(struct nand_chip *nand)
{
	 ifx_nand_chip_init();
	 /* insert callbacks */
   nand->IO_ADDR_R = NAND_BASE_ADDRESS;
a0001c50:	3c02b7c0 	lui	v0,0xb7c0
	nand->ecc.read_subpage = nand_read_subpage_benand;
#else
   nand->ecc.mode=NAND_ECC_SOFT;
#endif
   //nand->ecc.mode=NAND_ECC_NONE;
   nand->options|=NAND_USE_FLASH_BBT;
a0001c54:	8e030050 	lw	v1,80(s0)
 */
int board_nand_init(struct nand_chip *nand)
{
	 ifx_nand_chip_init();
	 /* insert callbacks */
   nand->IO_ADDR_R = NAND_BASE_ADDRESS;
a0001c58:	ae020000 	sw	v0,0(s0)
   nand->IO_ADDR_W = NAND_BASE_ADDRESS;
a0001c5c:	ae020004 	sw	v0,4(s0)
	 
   nand->read_byte=ifx_nand_read_byte;
a0001c60:	8f820058 	lw	v0,88(gp)
   nand->ecc.calculate = nand_calculate_ecc;
   nand->ecc.correct = nand_correct_data;
#endif
#endif
	return 0;
}
a0001c64:	8fbf001c 	lw	ra,28(sp)
	 ifx_nand_chip_init();
	 /* insert callbacks */
   nand->IO_ADDR_R = NAND_BASE_ADDRESS;
   nand->IO_ADDR_W = NAND_BASE_ADDRESS;
	 
   nand->read_byte=ifx_nand_read_byte;
a0001c68:	24421a44 	addiu	v0,v0,6724
a0001c6c:	ae020008 	sw	v0,8(s0)
   nand->read_buf=ifx_nand_read_buf;
a0001c70:	8f820058 	lw	v0,88(gp)
a0001c74:	24421a74 	addiu	v0,v0,6772
a0001c78:	ae020014 	sw	v0,20(s0)
   nand->write_buf=ifx_nand_write_buf;
   nand->verify_buf=ifx_nand_verify_buf;
#endif   
   //nand->hwcontrol=ifx_nand_hwcontrol;
   //nand->block_bad = ifx_nand_block_bad;
   nand->cmd_ctrl=ifx_nand_cmd_ctrl;
a0001c7c:	8f820058 	lw	v0,88(gp)
a0001c80:	24421ab8 	addiu	v0,v0,6840
a0001c84:	ae020028 	sw	v0,40(s0)
   nand->dev_ready=NanD_WaitReady;
a0001c88:	8f820058 	lw	v0,88(gp)
a0001c8c:	24421a28 	addiu	v0,v0,6696
a0001c90:	ae020030 	sw	v0,48(s0)
   nand->select_chip=ifx_nand_select_chip;
a0001c94:	8f820058 	lw	v0,88(gp)
a0001c98:	24421bac 	addiu	v0,v0,7084
a0001c9c:	ae02001c 	sw	v0,28(s0)
#elif defined(CONFIG_NAND_BENAND)
	nand->ecc.mode = NAND_ECC_BENAND;
	nand->ecc.read_page = nand_read_page_benand;		
	nand->ecc.read_subpage = nand_read_subpage_benand;
#else
   nand->ecc.mode=NAND_ECC_SOFT;
a0001ca0:	24020001 	li	v0,1
a0001ca4:	ae02029c 	sw	v0,668(s0)
#endif
   //nand->ecc.mode=NAND_ECC_NONE;
   nand->options|=NAND_USE_FLASH_BBT;
a0001ca8:	3c020001 	lui	v0,0x1
a0001cac:	00621025 	or	v0,v1,v0
a0001cb0:	ae020050 	sw	v0,80(s0)
   //nand->options|=NAND_SKIP_BBTSCAN;
#ifdef CONFIG_NAND_SPL
   nand->ecc.hwctl = lq_enable_hwecc;
a0001cb4:	8f820058 	lw	v0,88(gp)
a0001cb8:	24421a20 	addiu	v0,v0,6688
a0001cbc:	ae0202c0 	sw	v0,704(s0)
#if defined (CONFIG_NAND_ECC_BCH) && defined(CONFIG_DRIVER_GRX500)
   nand->ecc.calculate = nand_bch_calculate_ecc;
   nand->ecc.correct = nand_bch_correct_data;
#elif defined(CONFIG_NAND_ECC_SOFT)
   nand->ecc.calculate = nand_calculate_ecc;
a0001cc0:	8f820068 	lw	v0,104(gp)
a0001cc4:	ae0202c4 	sw	v0,708(s0)
   nand->ecc.correct = nand_correct_data;
a0001cc8:	8f82006c 	lw	v0,108(gp)
a0001ccc:	ae0202c8 	sw	v0,712(s0)
#endif
#endif
	return 0;
}
a0001cd0:	8fb00018 	lw	s0,24(sp)
a0001cd4:	00001021 	move	v0,zero
a0001cd8:	03e00008 	jr	ra
a0001cdc:	27bd0020 	addiu	sp,sp,32

a0001ce0 <cpu_is_cps>:
#if defined(CONFIG_MANUBOOT_OTP_SUPPORT)
extern int otp_prog_execute(void);
#endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) */

int cpu_is_cps(void)
{
a0001ce0:	3c1c0000 	lui	gp,0x0
a0001ce4:	279c3c60 	addiu	gp,gp,15456
a0001ce8:	0399e021 	addu	gp,gp,t9
a0001cec:	27bdffe0 	addiu	sp,sp,-32
    int ret=0;
    if(get_cpu_id()==0xa1) ret=1;
a0001cf0:	8f990070 	lw	t9,112(gp)
#if defined(CONFIG_MANUBOOT_OTP_SUPPORT)
extern int otp_prog_execute(void);
#endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) */

int cpu_is_cps(void)
{
a0001cf4:	afbf001c 	sw	ra,28(sp)
a0001cf8:	afbc0010 	sw	gp,16(sp)
    int ret=0;
    if(get_cpu_id()==0xa1) ret=1;
a0001cfc:	0320f809 	jalr	t9
a0001d00:	00000000 	nop
    return ret;
}
a0001d04:	8fbf001c 	lw	ra,28(sp)
#endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) */

int cpu_is_cps(void)
{
    int ret=0;
    if(get_cpu_id()==0xa1) ret=1;
a0001d08:	384200a1 	xori	v0,v0,0xa1
    return ret;
}
a0001d0c:	2c420001 	sltiu	v0,v0,1
a0001d10:	03e00008 	jr	ra
a0001d14:	27bd0020 	addiu	sp,sp,32

a0001d18 <malloc>:
}
#else
void *malloc(unsigned int size)
{
	return NULL;
}
a0001d18:	03e00008 	jr	ra
a0001d1c:	00001021 	move	v0,zero

a0001d20 <config_gpio>:
#endif /* CONFIG_NAND_ECC_BCH */

void config_gpio(u32 pin, int dir, u32 func_num)
{
    u32 portmux_base = pin>31?GPIO_PAD_CTRL_PORTMUXC32:GPIO_PAD_CTRL_PORTMUXC0;
a0001d20:	2c820020 	sltiu	v0,a0,32
a0001d24:	1040001c 	beqz	v0,a0001d98 <config_gpio+0x78>
a0001d28:	3c07b6c8 	lui	a3,0xb6c8
    u32 dir_base = pin>31?GPIO_FUNCTION_DIR_1:GPIO_FUNCTION_DIR_0;
    u32 od_base = pin>31?GPIO_PAD_CTRL_OD_1:GPIO_PAD_CTRL_OD_0;
a0001d2c:	3c03b6c8 	lui	v1,0xb6c8
#endif /* CONFIG_NAND_ECC_BCH */

void config_gpio(u32 pin, int dir, u32 func_num)
{
    u32 portmux_base = pin>31?GPIO_PAD_CTRL_PORTMUXC32:GPIO_PAD_CTRL_PORTMUXC0;
    u32 dir_base = pin>31?GPIO_FUNCTION_DIR_1:GPIO_FUNCTION_DIR_0;
a0001d30:	3c02b6c0 	lui	v0,0xb6c0
    u32 od_base = pin>31?GPIO_PAD_CTRL_OD_1:GPIO_PAD_CTRL_OD_0;
a0001d34:	24630094 	addiu	v1,v1,148
#endif /* CONFIG_NAND_ECC_BCH */

void config_gpio(u32 pin, int dir, u32 func_num)
{
    u32 portmux_base = pin>31?GPIO_PAD_CTRL_PORTMUXC32:GPIO_PAD_CTRL_PORTMUXC0;
    u32 dir_base = pin>31?GPIO_FUNCTION_DIR_1:GPIO_FUNCTION_DIR_0;
a0001d38:	24420008 	addiu	v0,v0,8
    u32 od_base = pin>31?GPIO_PAD_CTRL_OD_1:GPIO_PAD_CTRL_OD_0;
    u32 rel_port_num = pin>31?(pin-32):pin;

    REG32(portmux_base + (rel_port_num<<2)) = func_num;
a0001d3c:	00044080 	sll	t0,a0,0x2
a0001d40:	01073821 	addu	a3,t0,a3
a0001d44:	ace60000 	sw	a2,0(a3)

    if(dir == GPIO_OUTPUT)
a0001d48:	24060001 	li	a2,1
a0001d4c:	14a6000b 	bne	a1,a2,a0001d7c <config_gpio+0x5c>
a0001d50:	00000000 	nop
    {
        REG32(dir_base)|= (1<<rel_port_num);
a0001d54:	8c460000 	lw	a2,0(v0)
a0001d58:	00852004 	sllv	a0,a1,a0
a0001d5c:	00862825 	or	a1,a0,a2
        REG32(od_base) &=~(1<<rel_port_num);
a0001d60:	00042027 	nor	a0,zero,a0

    REG32(portmux_base + (rel_port_num<<2)) = func_num;

    if(dir == GPIO_OUTPUT)
    {
        REG32(dir_base)|= (1<<rel_port_num);
a0001d64:	ac450000 	sw	a1,0(v0)
        REG32(od_base) &=~(1<<rel_port_num);
a0001d68:	8c620000 	lw	v0,0(v1)
a0001d6c:	00822024 	and	a0,a0,v0
a0001d70:	ac640000 	sw	a0,0(v1)
a0001d74:	03e00008 	jr	ra
a0001d78:	00000000 	nop
    }else{
        REG32(dir_base)&= ~(1<<rel_port_num);
a0001d7c:	8c430000 	lw	v1,0(v0)
a0001d80:	00862004 	sllv	a0,a2,a0
a0001d84:	00042027 	nor	a0,zero,a0
a0001d88:	00832024 	and	a0,a0,v1
a0001d8c:	ac440000 	sw	a0,0(v0)
a0001d90:	03e00008 	jr	ra
a0001d94:	00000000 	nop
#endif /* CONFIG_NAND_ECC_BCH */

void config_gpio(u32 pin, int dir, u32 func_num)
{
    u32 portmux_base = pin>31?GPIO_PAD_CTRL_PORTMUXC32:GPIO_PAD_CTRL_PORTMUXC0;
    u32 dir_base = pin>31?GPIO_FUNCTION_DIR_1:GPIO_FUNCTION_DIR_0;
a0001d98:	3c02b6c0 	lui	v0,0xb6c0
    u32 od_base = pin>31?GPIO_PAD_CTRL_OD_1:GPIO_PAD_CTRL_OD_0;
a0001d9c:	24e30194 	addiu	v1,a3,404
    u32 rel_port_num = pin>31?(pin-32):pin;
a0001da0:	2484ffe0 	addiu	a0,a0,-32
#endif /* CONFIG_NAND_ECC_BCH */

void config_gpio(u32 pin, int dir, u32 func_num)
{
    u32 portmux_base = pin>31?GPIO_PAD_CTRL_PORTMUXC32:GPIO_PAD_CTRL_PORTMUXC0;
    u32 dir_base = pin>31?GPIO_FUNCTION_DIR_1:GPIO_FUNCTION_DIR_0;
a0001da4:	24420108 	addiu	v0,v0,264
a0001da8:	1000ffe4 	b	a0001d3c <config_gpio+0x1c>
a0001dac:	24e70100 	addiu	a3,a3,256

a0001db0 <nand_gpio_init>:
    }
}


void nand_gpio_init(void)
{
a0001db0:	3c1c0000 	lui	gp,0x0
a0001db4:	279c3b90 	addiu	gp,gp,15248
a0001db8:	0399e021 	addu	gp,gp,t9
a0001dbc:	27bdffe0 	addiu	sp,sp,-32
     config_gpio(13, GPIO_OUTPUT, 1);
a0001dc0:	8f990074 	lw	t9,116(gp)
a0001dc4:	2404000d 	li	a0,13
    }
}


void nand_gpio_init(void)
{
a0001dc8:	afbf001c 	sw	ra,28(sp)
a0001dcc:	afbc0010 	sw	gp,16(sp)
     config_gpio(13, GPIO_OUTPUT, 1);
a0001dd0:	24050001 	li	a1,1
a0001dd4:	0320f809 	jalr	t9
a0001dd8:	24060001 	li	a2,1
a0001ddc:	8fbc0010 	lw	gp,16(sp)
     config_gpio(23, GPIO_OUTPUT, 1);
a0001de0:	24040017 	li	a0,23
a0001de4:	24050001 	li	a1,1
a0001de8:	8f990074 	lw	t9,116(gp)
a0001dec:	0320f809 	jalr	t9
a0001df0:	24060001 	li	a2,1
a0001df4:	8fbc0010 	lw	gp,16(sp)
     config_gpio(24, GPIO_OUTPUT, 1);
a0001df8:	24040018 	li	a0,24
a0001dfc:	24050001 	li	a1,1
a0001e00:	8f990074 	lw	t9,116(gp)
a0001e04:	0320f809 	jalr	t9
a0001e08:	24060001 	li	a2,1
a0001e0c:	8fbc0010 	lw	gp,16(sp)
     config_gpio(48, GPIO_INPUT,  1);
a0001e10:	24040030 	li	a0,48
a0001e14:	00002821 	move	a1,zero
a0001e18:	8f990074 	lw	t9,116(gp)
a0001e1c:	0320f809 	jalr	t9
a0001e20:	24060001 	li	a2,1
a0001e24:	8fbc0010 	lw	gp,16(sp)
     config_gpio(49, GPIO_OUTPUT, 1);
a0001e28:	24040031 	li	a0,49
a0001e2c:	24050001 	li	a1,1
a0001e30:	8f990074 	lw	t9,116(gp)
a0001e34:	0320f809 	jalr	t9
a0001e38:	24060001 	li	a2,1
a0001e3c:	8fbc0010 	lw	gp,16(sp)
     config_gpio(50, GPIO_OUTPUT, 1);
a0001e40:	24040032 	li	a0,50
a0001e44:	24050001 	li	a1,1
a0001e48:	8f990074 	lw	t9,116(gp)
a0001e4c:	0320f809 	jalr	t9
a0001e50:	24060001 	li	a2,1
a0001e54:	8fbc0010 	lw	gp,16(sp)
     config_gpio(51, GPIO_OUTPUT, 1);
a0001e58:	24040033 	li	a0,51
a0001e5c:	24050001 	li	a1,1
a0001e60:	8f990074 	lw	t9,116(gp)
a0001e64:	0320f809 	jalr	t9
a0001e68:	24060001 	li	a2,1
a0001e6c:	8fbc0010 	lw	gp,16(sp)
     config_gpio(52, GPIO_OUTPUT, 1);
a0001e70:	24040034 	li	a0,52
a0001e74:	24050001 	li	a1,1
a0001e78:	8f990074 	lw	t9,116(gp)
a0001e7c:	0320f809 	jalr	t9
a0001e80:	24060001 	li	a2,1
a0001e84:	8fbc0010 	lw	gp,16(sp)
     config_gpio(53, GPIO_OUTPUT, 1);
a0001e88:	24040035 	li	a0,53
a0001e8c:	24050001 	li	a1,1
a0001e90:	8f990074 	lw	t9,116(gp)
a0001e94:	0320f809 	jalr	t9
a0001e98:	24060001 	li	a2,1
a0001e9c:	8fbc0010 	lw	gp,16(sp)
     config_gpio(54, GPIO_OUTPUT, 1);
a0001ea0:	24040036 	li	a0,54
a0001ea4:	24050001 	li	a1,1
a0001ea8:	8f990074 	lw	t9,116(gp)
a0001eac:	0320f809 	jalr	t9
a0001eb0:	24060001 	li	a2,1
a0001eb4:	8fbc0010 	lw	gp,16(sp)
     config_gpio(55, GPIO_OUTPUT, 1);
a0001eb8:	24040037 	li	a0,55
a0001ebc:	24050001 	li	a1,1
a0001ec0:	8f990074 	lw	t9,116(gp)
a0001ec4:	0320f809 	jalr	t9
a0001ec8:	24060001 	li	a2,1
a0001ecc:	8fbc0010 	lw	gp,16(sp)
     config_gpio(56, GPIO_OUTPUT, 1);
a0001ed0:	24040038 	li	a0,56
a0001ed4:	24050001 	li	a1,1
a0001ed8:	8f990074 	lw	t9,116(gp)
a0001edc:	0320f809 	jalr	t9
a0001ee0:	24060001 	li	a2,1
a0001ee4:	8fbc0010 	lw	gp,16(sp)
     config_gpio(57, GPIO_OUTPUT, 1);
a0001ee8:	24040039 	li	a0,57
a0001eec:	24050001 	li	a1,1
a0001ef0:	8f990074 	lw	t9,116(gp)
a0001ef4:	0320f809 	jalr	t9
a0001ef8:	24060001 	li	a2,1
a0001efc:	8fbc0010 	lw	gp,16(sp)
     config_gpio(59, GPIO_OUTPUT, 1);
a0001f00:	2404003b 	li	a0,59
a0001f04:	24050001 	li	a1,1
a0001f08:	8f990074 	lw	t9,116(gp)
a0001f0c:	0320f809 	jalr	t9
a0001f10:	24060001 	li	a2,1
a0001f14:	8fbc0010 	lw	gp,16(sp)
     config_gpio(60, GPIO_OUTPUT, 1);
a0001f18:	2404003c 	li	a0,60
a0001f1c:	24050001 	li	a1,1
a0001f20:	8f990074 	lw	t9,116(gp)
a0001f24:	0320f809 	jalr	t9
a0001f28:	24060001 	li	a2,1
a0001f2c:	8fbc0010 	lw	gp,16(sp)
     config_gpio(61, GPIO_OUTPUT, 1);
a0001f30:	2404003d 	li	a0,61
a0001f34:	24050001 	li	a1,1
a0001f38:	8f990074 	lw	t9,116(gp)
a0001f3c:	0320f809 	jalr	t9
a0001f40:	24060001 	li	a2,1

     REG32(EBU_ADDR_SEL_0) = 0x17400051;
a0001f44:	3c031740 	lui	v1,0x1740
a0001f48:	24630051 	addiu	v1,v1,81
a0001f4c:	3c02b6f0 	lui	v0,0xb6f0
a0001f50:	ac430020 	sw	v1,32(v0)

}
a0001f54:	8fbf001c 	lw	ra,28(sp)
a0001f58:	03e00008 	jr	ra
a0001f5c:	27bd0020 	addiu	sp,sp,32

a0001f60 <serial_setbrg>:
   *preload = reload - 1;
}


void serial_setbrg (void)
{
a0001f60:	3c1c0000 	lui	gp,0x0
a0001f64:	279c39e0 	addiu	gp,gp,14816
a0001f68:	0399e021 	addu	gp,gp,t9
a0001f6c:	27bdffe0 	addiu	sp,sp,-32
	u32 uiReloadValue=0;
    u32 fdv=0;
	
    serial_divs(CONFIG_BAUDRATE, get_fpi_clk(), &fdv, &uiReloadValue);
a0001f70:	8f990088 	lw	t9,136(gp)
   *preload = reload - 1;
}


void serial_setbrg (void)
{
a0001f74:	afbc0010 	sw	gp,16(sp)
a0001f78:	afbf001c 	sw	ra,28(sp)
	u32 uiReloadValue=0;
    u32 fdv=0;
	
    serial_divs(CONFIG_BAUDRATE, get_fpi_clk(), &fdv, &uiReloadValue);
a0001f7c:	0320f809 	jalr	t9
a0001f80:	00000000 	nop
 * ReloadValue = ( ----- * --------------- ) - 1
 *                  512     16 * BaudRate
 */
static void serial_divs(u32 baudrate, u32 fasc, u32 *pfdv, u32 *preload)
{
   u32 clock = fasc / 16;
a0001f84:	00024902 	srl	t1,v0,0x4
   u32 idiff; /* current diff */
   u32 ireload; /* current reload */
   u32 i; /* current fdv */
   u32 result; /* current resulting baudrate */

   if (clock > 0x7FFFFF)
a0001f88:	3c030080 	lui	v1,0x80
a0001f8c:	0123182b 	sltu	v1,t1,v1
a0001f90:	14600003 	bnez	v1,a0001fa0 <serial_setbrg+0x40>
a0001f94:	3c04004b 	lui	a0,0x4b
      clock /= 512;
a0001f98:	00024b42 	srl	t1,v0,0xd
a0001f9c:	24042580 	li	a0,9600
a0001fa0:	00092a40 	sll	a1,t1,0x9

   fdv = 512; /* start with 1:1 fraction */
   diff = baudrate; /* highest possible */

   /* i is the test fdv value -- start with the largest possible */
   for (i = 512; i > 0; i--)
a0001fa4:	00805821 	move	t3,a0
static void serial_divs(u32 baudrate, u32 fasc, u32 *pfdv, u32 *preload)
{
   u32 clock = fasc / 16;

   u32 fdv; /* best fdv */
   u32 reload = 0; /* best reload */
a0001fa8:	00005021 	move	t2,zero
   if (clock > 0x7FFFFF)
      clock /= 512;
   else
      baudrate *= 512;

   fdv = 512; /* start with 1:1 fraction */
a0001fac:	24030200 	li	v1,512
   diff = baudrate; /* highest possible */

   /* i is the test fdv value -- start with the largest possible */
   for (i = 512; i > 0; i--)
a0001fb0:	24060200 	li	a2,512
   {
      ireload = (clock * i) / baudrate;
a0001fb4:	00a4001b 	divu	zero,a1,a0
a0001fb8:	008001f4 	teq	a0,zero,0x7
a0001fbc:	00003812 	mflo	a3
      if (ireload < 1)
a0001fc0:	10e00014 	beqz	a3,a0002014 <serial_setbrg+0xb4>
a0001fc4:	00004012 	mflo	t0
         break; /* already invalid */
      result = (clock * i) / ireload;
a0001fc8:	00a7001b 	divu	zero,a1,a3
a0001fcc:	00e001f4 	teq	a3,zero,0x7
a0001fd0:	00006012 	mflo	t4

      idiff = (result > baudrate) ? (result - baudrate) : (baudrate - result);
a0001fd4:	008c682b 	sltu	t5,a0,t4
a0001fd8:	01841023 	subu	v0,t4,a0
a0001fdc:	008c6023 	subu	t4,a0,t4
a0001fe0:	018d100a 	movz	v0,t4,t5
      if (idiff == 0)
a0001fe4:	1040000d 	beqz	v0,a000201c <serial_setbrg+0xbc>
a0001fe8:	004b602b 	sltu	t4,v0,t3
      {
         fdv = i;
         reload = ireload;
         break; /* can't do better */
      }
      else if (idiff < diff)
a0001fec:	01404021 	move	t0,t2
a0001ff0:	00cc180b 	movn	v1,a2,t4

   fdv = 512; /* start with 1:1 fraction */
   diff = baudrate; /* highest possible */

   /* i is the test fdv value -- start with the largest possible */
   for (i = 512; i > 0; i--)
a0001ff4:	24c6ffff 	addiu	a2,a2,-1
      {
         fdv = i;
         reload = ireload;
         break; /* can't do better */
      }
      else if (idiff < diff)
a0001ff8:	016c100a 	movz	v0,t3,t4
a0001ffc:	00ec400b 	movn	t0,a3,t4

   fdv = 512; /* start with 1:1 fraction */
   diff = baudrate; /* highest possible */

   /* i is the test fdv value -- start with the largest possible */
   for (i = 512; i > 0; i--)
a0002000:	10c00007 	beqz	a2,a0002020 <serial_setbrg+0xc0>
a0002004:	00a92823 	subu	a1,a1,t1
a0002008:	01005021 	move	t2,t0
a000200c:	1000ffe9 	b	a0001fb4 <serial_setbrg+0x54>
a0002010:	00405821 	move	t3,v0
   {
      ireload = (clock * i) / baudrate;
      if (ireload < 1)
a0002014:	10000002 	b	a0002020 <serial_setbrg+0xc0>
a0002018:	01404021 	move	t0,t2
         break; /* already invalid */
      result = (clock * i) / ireload;

      idiff = (result > baudrate) ? (result - baudrate) : (baudrate - result);
      if (idiff == 0)
a000201c:	00c01821 	move	v1,a2
         reload = ireload;
         diff = idiff; /* update lowest diff*/
      }
   }

   *pfdv = (fdv == 512) ? 0 : fdv;
a0002020:	38620200 	xori	v0,v1,0x200
a0002024:	0002180a 	movz	v1,zero,v0
	u32 uiReloadValue=0;
    u32 fdv=0;
	
    serial_divs(CONFIG_BAUDRATE, get_fpi_clk(), &fdv, &uiReloadValue);
	/* Disable Baud Rate Generator; BG should only be written when R=0 */
	CLEAR_BIT(pAsc->asc_con, ASCCON_R);
a0002028:	3c02b660 	lui	v0,0xb660
a000202c:	3c04ffff 	lui	a0,0xffff
a0002030:	8c450010 	lw	a1,16(v0)
a0002034:	24847fff 	addiu	a0,a0,32767
a0002038:	00a42024 	and	a0,a1,a0
         diff = idiff; /* update lowest diff*/
      }
   }

   *pfdv = (fdv == 512) ? 0 : fdv;
   *preload = reload - 1;
a000203c:	2508ffff 	addiu	t0,t0,-1
	u32 uiReloadValue=0;
    u32 fdv=0;
	
    serial_divs(CONFIG_BAUDRATE, get_fpi_clk(), &fdv, &uiReloadValue);
	/* Disable Baud Rate Generator; BG should only be written when R=0 */
	CLEAR_BIT(pAsc->asc_con, ASCCON_R);
a0002040:	ac440010 	sw	a0,16(v0)

	/* Enable Fractional Divider */
	SET_BIT(pAsc->asc_con, ASCCON_FDE); /* FDE = 1 */
a0002044:	8c440010 	lw	a0,16(v0)
a0002048:	34840200 	ori	a0,a0,0x200
a000204c:	ac440010 	sw	a0,16(v0)

	/* Set fractional divider value */
	pAsc->asc_fdv = fdv & ASCFDV_VALUE_MASK;
a0002050:	ac430058 	sw	v1,88(v0)

	/* Set reload value in BG */
	pAsc->asc_bg = uiReloadValue;
a0002054:	ac480050 	sw	t0,80(v0)

	/* Enable Baud Rate Generator */
	SET_BIT(pAsc->asc_con, ASCCON_R);           /* R = 1 */
a0002058:	8c430010 	lw	v1,16(v0)
a000205c:	34638000 	ori	v1,v1,0x8000
a0002060:	ac430010 	sw	v1,16(v0)
}
a0002064:	8fbf001c 	lw	ra,28(sp)
a0002068:	03e00008 	jr	ra
a000206c:	27bd0020 	addiu	sp,sp,32

a0002070 <serial_init>:
*
* RETURNS: N/A
*/

int serial_init (void)
{
a0002070:	3c1c0000 	lui	gp,0x0
a0002074:	279c38d0 	addiu	gp,gp,14544
a0002078:	0399e021 	addu	gp,gp,t9
a000207c:	27bdffe0 	addiu	sp,sp,-32
a0002080:	afb00018 	sw	s0,24(sp)

	/* and we have to set CLC register*/
	CLEAR_BIT(pAsc->asc_clc, ASCCLC_DISS);
a0002084:	3c10b660 	lui	s0,0xb660
*
* RETURNS: N/A
*/

int serial_init (void)
{
a0002088:	afbf001c 	sw	ra,28(sp)
a000208c:	afbc0010 	sw	gp,16(sp)

	/* and we have to set CLC register*/
	CLEAR_BIT(pAsc->asc_clc, ASCCLC_DISS);
a0002090:	8e030000 	lw	v1,0(s0)
a0002094:	2402fffd 	li	v0,-3
a0002098:	00621024 	and	v0,v1,v0
			ASCRXFCON_RXFITLOFF, DANUBEASC_RXFIFO_FL);
	/* enable RXFIFO */
	SET_BIT(pAsc->asc_rxfcon, ASCRXFCON_RXFEN);

	/* set baud rate */
	serial_setbrg();
a000209c:	8f99008c 	lw	t9,140(gp)

int serial_init (void)
{

	/* and we have to set CLC register*/
	CLEAR_BIT(pAsc->asc_clc, ASCCLC_DISS);
a00020a0:	ae020000 	sw	v0,0(s0)
	SET_BITFIELD(pAsc->asc_clc, ASCCLC_RMCMASK, ASCCLC_RMCOFFSET, 0x0001);
a00020a4:	8e030000 	lw	v1,0(s0)
a00020a8:	3c02ffff 	lui	v0,0xffff
a00020ac:	244200ff 	addiu	v0,v0,255
a00020b0:	00621024 	and	v0,v1,v0
a00020b4:	ae020000 	sw	v0,0(s0)
a00020b8:	8e020000 	lw	v0,0(s0)
a00020bc:	34420100 	ori	v0,v0,0x100
a00020c0:	ae020000 	sw	v0,0(s0)


	/* initialy we are in async mode */
	pAsc->asc_con = ASCCON_M_8ASYNC;
a00020c4:	ae000010 	sw	zero,16(s0)

	/* select input port */
	pAsc->asc_pisel = (CONSOLE_TTY & 0x1);
a00020c8:	ae000004 	sw	zero,4(s0)

	/* TXFIFO's filling level */
	SET_BITFIELD(pAsc->asc_txfcon, ASCTXFCON_TXFITLMASK,
a00020cc:	8e030044 	lw	v1,68(s0)
a00020d0:	2402c0ff 	li	v0,-16129
a00020d4:	00621824 	and	v1,v1,v0
a00020d8:	ae030044 	sw	v1,68(s0)
a00020dc:	8e030044 	lw	v1,68(s0)
a00020e0:	34630100 	ori	v1,v1,0x100
a00020e4:	ae030044 	sw	v1,68(s0)
			ASCTXFCON_TXFITLOFF, DANUBEASC_TXFIFO_FL);
	/* enable TXFIFO */
	SET_BIT(pAsc->asc_txfcon, ASCTXFCON_TXFEN);
a00020e8:	8e030044 	lw	v1,68(s0)
a00020ec:	34630001 	ori	v1,v1,0x1
a00020f0:	ae030044 	sw	v1,68(s0)

	/* RXFIFO's filling level */
	SET_BITFIELD(pAsc->asc_txfcon, ASCRXFCON_RXFITLMASK,
a00020f4:	8e030044 	lw	v1,68(s0)
a00020f8:	00621024 	and	v0,v1,v0
a00020fc:	ae020044 	sw	v0,68(s0)
a0002100:	8e020044 	lw	v0,68(s0)
a0002104:	34420100 	ori	v0,v0,0x100
a0002108:	ae020044 	sw	v0,68(s0)
			ASCRXFCON_RXFITLOFF, DANUBEASC_RXFIFO_FL);
	/* enable RXFIFO */
	SET_BIT(pAsc->asc_rxfcon, ASCRXFCON_RXFEN);
a000210c:	8e020040 	lw	v0,64(s0)
a0002110:	34420001 	ori	v0,v0,0x1
a0002114:	ae020040 	sw	v0,64(s0)

	/* set baud rate */
	serial_setbrg();
a0002118:	0320f809 	jalr	t9
a000211c:	00000000 	nop

	/* enable error signals &  Receiver enable  */
	SET_BIT(pAsc->asc_whbstate, ASCWHBSTATE_SETREN|ASCCON_FEN|ASCCON_TOEN|ASCCON_ROEN);
a0002120:	8e030018 	lw	v1,24(s0)
a0002124:	3c02001a 	lui	v0,0x1a
a0002128:	24420002 	addiu	v0,v0,2
a000212c:	00621025 	or	v0,v1,v0
a0002130:	ae020018 	sw	v0,24(s0)

	return 0;
}
a0002134:	8fbf001c 	lw	ra,28(sp)
a0002138:	8fb00018 	lw	s0,24(sp)
a000213c:	00001021 	move	v0,zero
a0002140:	03e00008 	jr	ra
a0002144:	27bd0020 	addiu	sp,sp,32

a0002148 <serial_putc>:
	SET_BIT(pAsc->asc_con, ASCCON_R);           /* R = 1 */
}


void serial_putc (const char c)
{
a0002148:	3c1c0000 	lui	gp,0x0
a000214c:	279c37f8 	addiu	gp,gp,14328
a0002150:	0399e021 	addu	gp,gp,t9
a0002154:	27bdffe0 	addiu	sp,sp,-32
	u32 txFl = 0;
#ifdef DEBUG_ASC_RAW
	static u8 * debug = (u8 *) DEBUG_ASC_RAW_TX_BUF;
	*debug++=c;
#endif
	if (c == '\n')
a0002158:	2402000a 	li	v0,10
	SET_BIT(pAsc->asc_con, ASCCON_R);           /* R = 1 */
}


void serial_putc (const char c)
{
a000215c:	afb00018 	sw	s0,24(sp)
a0002160:	afbc0010 	sw	gp,16(sp)
a0002164:	7c048420 	seb	s0,a0
a0002168:	afbf001c 	sw	ra,28(sp)
	u32 txFl = 0;
#ifdef DEBUG_ASC_RAW
	static u8 * debug = (u8 *) DEBUG_ASC_RAW_TX_BUF;
	*debug++=c;
#endif
	if (c == '\n')
a000216c:	16020005 	bne	s0,v0,a0002184 <serial_putc+0x3c>
a0002170:	3c05b660 	lui	a1,0xb660
		serial_putc ('\r');
a0002174:	8f990090 	lw	t9,144(gp)
a0002178:	0320f809 	jalr	t9
a000217c:	2404000d 	li	a0,13
	/* check do we have a free space in the TX FIFO */
	/* get current filling level */
	do
	{
		txFl = ( pAsc->asc_fstat & ASCFSTAT_TXFFLMASK ) >> ASCFSTAT_TXFFLOFF;
a0002180:	3c05b660 	lui	a1,0xb660
	}
	while ( txFl == DANUBEASC_TXFIFO_FULL );
a0002184:	24030010 	li	v1,16
		serial_putc ('\r');
	/* check do we have a free space in the TX FIFO */
	/* get current filling level */
	do
	{
		txFl = ( pAsc->asc_fstat & ASCFSTAT_TXFFLMASK ) >> ASCFSTAT_TXFFLOFF;
a0002188:	8ca40048 	lw	a0,72(a1)
a000218c:	7c842a00 	ext	a0,a0,0x8,0x6
	}
	while ( txFl == DANUBEASC_TXFIFO_FULL );
a0002190:	1083fffd 	beq	a0,v1,a0002188 <serial_putc+0x40>
a0002194:	3c02b660 	lui	v0,0xb660

	pAsc->asc_tbuf = c; /* write char to Transmit Buffer Register */
a0002198:	ac500020 	sw	s0,32(v0)

	/* check for errors */
	if ( pAsc->asc_state & ASCSTATE_TOE )
a000219c:	8c430014 	lw	v1,20(v0)
a00021a0:	7c630500 	ext	v1,v1,0x14,0x1
a00021a4:	10600005 	beqz	v1,a00021bc <serial_putc+0x74>
a00021a8:	8fbf001c 	lw	ra,28(sp)
	{
		SET_BIT(pAsc->asc_whbstate, ASCWHBSTATE_CLRTOE);
a00021ac:	8c430018 	lw	v1,24(v0)
a00021b0:	34630040 	ori	v1,v1,0x40
a00021b4:	ac430018 	sw	v1,24(v0)
		return;
	}
}
a00021b8:	8fbf001c 	lw	ra,28(sp)
a00021bc:	8fb00018 	lw	s0,24(sp)
a00021c0:	03e00008 	jr	ra
a00021c4:	27bd0020 	addiu	sp,sp,32

a00021c8 <serial_puts>:

void serial_puts (const char *s)
{
a00021c8:	3c1c0000 	lui	gp,0x0
a00021cc:	279c3778 	addiu	gp,gp,14200
a00021d0:	0399e021 	addu	gp,gp,t9
a00021d4:	27bdffe0 	addiu	sp,sp,-32
a00021d8:	afb00018 	sw	s0,24(sp)
a00021dc:	afbc0010 	sw	gp,16(sp)
a00021e0:	afbf001c 	sw	ra,28(sp)
a00021e4:	00808021 	move	s0,a0
	while (*s)
a00021e8:	82040000 	lb	a0,0(s0)
a00021ec:	10800005 	beqz	a0,a0002204 <serial_puts+0x3c>
a00021f0:	8f990090 	lw	t9,144(gp)
	{
		serial_putc (*s++);
a00021f4:	0320f809 	jalr	t9
a00021f8:	26100001 	addiu	s0,s0,1
a00021fc:	1000fffa 	b	a00021e8 <serial_puts+0x20>
a0002200:	8fbc0010 	lw	gp,16(sp)
	}
}
a0002204:	8fbf001c 	lw	ra,28(sp)
a0002208:	8fb00018 	lw	s0,24(sp)
a000220c:	03e00008 	jr	ra
a0002210:	27bd0020 	addiu	sp,sp,32

a0002214 <asc_inb>:

int asc_inb(int timeout)
{
	u32 symbol_mask;
	char c;
	while ((pAsc->asc_fstat & ASCFSTAT_RXFFLMASK) == 0 ) {
a0002214:	3c03b660 	lui	v1,0xb660
a0002218:	8c620048 	lw	v0,72(v1)
a000221c:	3042003f 	andi	v0,v0,0x3f
a0002220:	1040fffd 	beqz	v0,a0002218 <asc_inb+0x4>
a0002224:	3c02b660 	lui	v0,0xb660
	}
	symbol_mask = ((ASC_OPTIONS & ASCOPT_CSIZE) == ASCOPT_CS7) ? (0x7f) : (0xff);
	c = (char)(pAsc->asc_rbuf & symbol_mask);
a0002228:	8c420024 	lw	v0,36(v0)
	return (c);
}
a000222c:	03e00008 	jr	ra
a0002230:	7c021420 	seb	v0,v0

a0002234 <serial_getc>:

int serial_getc (void)
{
	char c;
	while ((pAsc->asc_fstat & ASCFSTAT_RXFFLMASK) == 0 );
a0002234:	3c03b660 	lui	v1,0xb660
a0002238:	8c620048 	lw	v0,72(v1)
a000223c:	3042003f 	andi	v0,v0,0x3f
a0002240:	1040fffd 	beqz	v0,a0002238 <serial_getc+0x4>
a0002244:	3c02b660 	lui	v0,0xb660
	c = (char)(pAsc->asc_rbuf & 0xff);
a0002248:	8c420024 	lw	v0,36(v0)
#ifdef 	DEBUG_ASC_RAW
	static u8* debug=(u8*)(DEBUG_ASC_RAW_RX_BUF);
	*debug++=c;
#endif
	return c;
}
a000224c:	03e00008 	jr	ra
a0002250:	7c021420 	seb	v0,v0

a0002254 <serial_tstc>:
int serial_tstc (void)
{
         int res = 1;

#ifdef ASC_FIFO_PRESENT
    if ( (pAsc->asc_fstat & ASCFSTAT_RXFFLMASK) == 0 )
a0002254:	3c02b660 	lui	v0,0xb660
a0002258:	8c420048 	lw	v0,72(v0)
a000225c:	3042003f 	andi	v0,v0,0x3f
        SET_BIT(pAsc->asc_whbcon, ASCWHBCON_CLROE);
        res = 0;
    }
#endif
  return res;
}
a0002260:	03e00008 	jr	ra
a0002264:	0002102b 	sltu	v0,zero,v0

a0002268 <serial_start>:


int serial_start(void)
{
   return 1;
}
a0002268:	03e00008 	jr	ra
a000226c:	24020001 	li	v0,1

a0002270 <serial_stop>:

int serial_stop(void)
{
   return 1;
}
a0002270:	03e00008 	jr	ra
a0002274:	24020001 	li	v0,1
	...

a0002280 <get_sys_clk>:


uint get_sys_clk(void)
{
    return 0;
}
a0002280:	03e00008 	jr	ra
a0002284:	00001021 	move	v0,zero

a0002288 <get_cpu_clk>:
{
       unsigned long pllclk;
       u32 val;
       u32 clk4_div;

       val = REG32(CGU_PLL0A_CFG1);
a0002288:	3c02b620 	lui	v0,0xb620
a000228c:	8c430008 	lw	v1,8(v0)

        if (val & CPU_CLK_MST_SEL_2GHZ) {
a0002290:	7c630740 	ext	v1,v1,0x1d,0x1
a0002294:	10600006 	beqz	v1,a00022b0 <get_cpu_clk+0x28>
a0002298:	00000000 	nop
                pllclk = CLOCK_2000M;
                clk4_div = (REG32(CGU_PLL0B_CFG1) & PLL0B_CFG1_CLK4)>>12;
a000229c:	8c420038 	lw	v0,56(v0)
       u32 clk4_div;

       val = REG32(CGU_PLL0A_CFG1);

        if (val & CPU_CLK_MST_SEL_2GHZ) {
                pllclk = CLOCK_2000M;
a00022a0:	3c037735 	lui	v1,0x7735
                clk4_div = (REG32(CGU_PLL0B_CFG1) & PLL0B_CFG1_CLK4)>>12;
a00022a4:	7c421b00 	ext	v0,v0,0xc,0x4
a00022a8:	10000005 	b	a00022c0 <get_cpu_clk+0x38>
a00022ac:	34639400 	ori	v1,v1,0x9400
        } else {
                pllclk = CLOCK_2400M;
                clk4_div = (REG32(CGU_PLL0A_CFG1) & PLL0A_CFG1_CLK4)>>12;
a00022b0:	8c420008 	lw	v0,8(v0)

        if (val & CPU_CLK_MST_SEL_2GHZ) {
                pllclk = CLOCK_2000M;
                clk4_div = (REG32(CGU_PLL0B_CFG1) & PLL0B_CFG1_CLK4)>>12;
        } else {
                pllclk = CLOCK_2400M;
a00022b4:	3c038f0d 	lui	v1,0x8f0d
                clk4_div = (REG32(CGU_PLL0A_CFG1) & PLL0A_CFG1_CLK4)>>12;
a00022b8:	7c421b00 	ext	v0,v0,0xc,0x4

        if (val & CPU_CLK_MST_SEL_2GHZ) {
                pllclk = CLOCK_2000M;
                clk4_div = (REG32(CGU_PLL0B_CFG1) & PLL0B_CFG1_CLK4)>>12;
        } else {
                pllclk = CLOCK_2400M;
a00022bc:	24631800 	addiu	v1,v1,6144
                clk4_div = (REG32(CGU_PLL0A_CFG1) & PLL0A_CFG1_CLK4)>>12;
        }

        return (unsigned long)(pllclk / (clk4_div + 1));
a00022c0:	24420001 	addiu	v0,v0,1

}
a00022c4:	0062001b 	divu	zero,v1,v0
a00022c8:	004001f4 	teq	v0,zero,0x7
a00022cc:	03e00008 	jr	ra
a00022d0:	00001012 	mflo	v0

a00022d4 <get_ddr_clk>:


unsigned int get_ddr_clk(void)
{
a00022d4:	3c1c0000 	lui	gp,0x0
a00022d8:	279c366c 	addiu	gp,gp,13932
a00022dc:	0399e021 	addu	gp,gp,t9
       u32 val=400000000;
       u32 clk3_div;
        
#if 1       
       pllclk = CLOCK_2000M;
       clk3_div = (REG32(CGU_PLL0B_CFG1) & PLL0B_CFG1_CLK3)>>8;
a00022e0:	3c02b620 	lui	v0,0xb620
a00022e4:	8c420038 	lw	v0,56(v0)
a00022e8:	7c421a00 	ext	v0,v0,0x8,0x4
a00022ec:	2442fffe 	addiu	v0,v0,-2
a00022f0:	2c430007 	sltiu	v1,v0,7
a00022f4:	10600006 	beqz	v1,a0002310 <get_ddr_clk+0x3c>
a00022f8:	8f830058 	lw	v1,88(gp)
a00022fc:	00021080 	sll	v0,v0,0x2
a0002300:	246353a0 	addiu	v1,v1,21408
a0002304:	00431021 	addu	v0,v0,v1
a0002308:	03e00008 	jr	ra
a000230c:	8c420000 	lw	v0,0(v0)
a0002310:	3c0217d7 	lui	v0,0x17d7
              break;

       }
#endif
       return val;
}
a0002314:	03e00008 	jr	ra
a0002318:	34428400 	ori	v0,v0,0x8400

a000231c <get_fpi_clk>:

unsigned int get_fpi_clk()
{
    //return 16000000/4;   // HAPS 800MHz CPU Actual Frequency is 16MHz;
    return   CLOCK_200M;
}
a000231c:	3c020beb 	lui	v0,0xbeb
a0002320:	03e00008 	jr	ra
a0002324:	3442c200 	ori	v0,v0,0xc200
	...

a0002330 <strcpy>:
 * strcpy - Copy a %NUL terminated string
 * @dest: Where to copy the string to
 * @src: Where to copy the string from
 */
char * strcpy(char * dest,const char *src)
{
a0002330:	00801021 	move	v0,a0
	char *tmp = dest;

	while ((*dest++ = *src++) != '\0')
a0002334:	00801821 	move	v1,a0
a0002338:	24a50001 	addiu	a1,a1,1
a000233c:	80a4ffff 	lb	a0,-1(a1)
a0002340:	24630001 	addiu	v1,v1,1
a0002344:	1480fffc 	bnez	a0,a0002338 <strcpy+0x8>
a0002348:	a064ffff 	sb	a0,-1(v1)
		/* nothing */;
	return tmp;
}
a000234c:	03e00008 	jr	ra
a0002350:	00000000 	nop

a0002354 <strncpy>:
 * Note that unlike userspace strncpy, this does not %NUL-pad the buffer.
 * However, the result is not %NUL-terminated if the source exceeds
 * @count bytes.
 */
char * strncpy(char * dest,const char *src,size_t count)
{
a0002354:	00801021 	move	v0,a0
	char *tmp = dest;

	while (count-- && (*dest++ = *src++) != '\0')
a0002358:	00001821 	move	v1,zero
a000235c:	10660006 	beq	v1,a2,a0002378 <strncpy+0x24>
a0002360:	00a32021 	addu	a0,a1,v1
a0002364:	00433821 	addu	a3,v0,v1
a0002368:	80840000 	lb	a0,0(a0)
a000236c:	24630001 	addiu	v1,v1,1
a0002370:	1480fffa 	bnez	a0,a000235c <strncpy+0x8>
a0002374:	a0e40000 	sb	a0,0(a3)
		/* nothing */;

	return tmp;
}
a0002378:	03e00008 	jr	ra
a000237c:	00000000 	nop

a0002380 <strcat>:
 * strcat - Append one %NUL-terminated string to another
 * @dest: The string to be appended to
 * @src: The string to append to it
 */
char * strcat(char * dest, const char * src)
{
a0002380:	00801021 	move	v0,a0
	char *tmp = dest;

	while (*dest)
a0002384:	00801821 	move	v1,a0
a0002388:	80640000 	lb	a0,0(v1)
a000238c:	50800004 	beqzl	a0,a00023a0 <strcat+0x20>
a0002390:	24a50001 	addiu	a1,a1,1
		dest++;
a0002394:	1000fffc 	b	a0002388 <strcat+0x8>
a0002398:	24630001 	addiu	v1,v1,1
	while ((*dest++ = *src++) != '\0')
a000239c:	24a50001 	addiu	a1,a1,1
a00023a0:	80a4ffff 	lb	a0,-1(a1)
a00023a4:	24630001 	addiu	v1,v1,1
a00023a8:	1480fffc 	bnez	a0,a000239c <strcat+0x1c>
a00023ac:	a064ffff 	sb	a0,-1(v1)
		;

	return tmp;
}
a00023b0:	03e00008 	jr	ra
a00023b4:	00000000 	nop

a00023b8 <strncat>:
 *
 * Note that in contrast to strncpy, strncat ensures the result is
 * terminated.
 */
char * strncat(char *dest, const char *src, size_t count)
{
a00023b8:	00801021 	move	v0,a0
	char *tmp = dest;

	if (count) {
a00023bc:	10c0000f 	beqz	a2,a00023fc <strncat+0x44>
a00023c0:	00801821 	move	v1,a0
		while (*dest)
a00023c4:	80640000 	lb	a0,0(v1)
a00023c8:	50800003 	beqzl	a0,a00023d8 <strncat+0x20>
a00023cc:	00663021 	addu	a2,v1,a2
			dest++;
a00023d0:	1000fffc 	b	a00023c4 <strncat+0xc>
a00023d4:	24630001 	addiu	v1,v1,1
		while ((*dest++ = *src++)) {
a00023d8:	24a50001 	addiu	a1,a1,1
a00023dc:	80a4ffff 	lb	a0,-1(a1)
a00023e0:	24670001 	addiu	a3,v1,1
a00023e4:	10800005 	beqz	a0,a00023fc <strncat+0x44>
a00023e8:	a0e4ffff 	sb	a0,-1(a3)
			if (--count == 0) {
a00023ec:	50e60003 	beql	a3,a2,a00023fc <strncat+0x44>
a00023f0:	a0600001 	sb	zero,1(v1)
	char *tmp = dest;

	if (count) {
		while (*dest)
			dest++;
		while ((*dest++ = *src++)) {
a00023f4:	1000fff8 	b	a00023d8 <strncat+0x20>
a00023f8:	00e01821 	move	v1,a3
			}
		}
	}

	return tmp;
}
a00023fc:	03e00008 	jr	ra
a0002400:	00000000 	nop

a0002404 <strcmp>:
int strcmp(const char * cs,const char * ct)
{
	register signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
a0002404:	24a50001 	addiu	a1,a1,1
a0002408:	80830000 	lb	v1,0(a0)
a000240c:	90a2ffff 	lbu	v0,-1(a1)
a0002410:	00621023 	subu	v0,v1,v0
a0002414:	7c021420 	seb	v0,v0
a0002418:	14400003 	bnez	v0,a0002428 <strcmp+0x24>
a000241c:	00000000 	nop
a0002420:	1460fff8 	bnez	v1,a0002404 <strcmp>
a0002424:	24840001 	addiu	a0,a0,1
			break;
	}

	return __res;
}
a0002428:	03e00008 	jr	ra
a000242c:	00000000 	nop

a0002430 <strncmp>:
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
	register signed char __res = 0;

	while (count) {
a0002430:	00001821 	move	v1,zero
a0002434:	1066000b 	beq	v1,a2,a0002464 <strncmp+0x34>
a0002438:	00001021 	move	v0,zero
a000243c:	00831021 	addu	v0,a0,v1
		if ((__res = *cs - *ct++) != 0 || !*cs++)
a0002440:	80470000 	lb	a3,0(v0)
a0002444:	00a31021 	addu	v0,a1,v1
a0002448:	90420000 	lbu	v0,0(v0)
a000244c:	00e21023 	subu	v0,a3,v0
a0002450:	7c021420 	seb	v0,v0
a0002454:	14400003 	bnez	v0,a0002464 <strncmp+0x34>
a0002458:	00000000 	nop
a000245c:	14e0fff5 	bnez	a3,a0002434 <strncmp+0x4>
a0002460:	24630001 	addiu	v1,v1,1
			break;
		count--;
	}

	return __res;
}
a0002464:	03e00008 	jr	ra
a0002468:	00000000 	nop

a000246c <strchr>:
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
a000246c:	7c052c20 	seb	a1,a1
a0002470:	80820000 	lb	v0,0(a0)
a0002474:	10450005 	beq	v0,a1,a000248c <strchr+0x20>
a0002478:	00000000 	nop
		if (*s == '\0')
a000247c:	10400005 	beqz	v0,a0002494 <strchr+0x28>
a0002480:	24840001 	addiu	a0,a0,1
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
a0002484:	1000fffb 	b	a0002474 <strchr+0x8>
a0002488:	80820000 	lb	v0,0(a0)
a000248c:	03e00008 	jr	ra
a0002490:	00801021 	move	v0,a0
		if (*s == '\0')
			return NULL;
	return (char *) s;
}
a0002494:	03e00008 	jr	ra
a0002498:	00001021 	move	v0,zero

a000249c <skip_spaces>:
 * @str: The string to be stripped.
 *
 * Returns a pointer to the first non-whitespace character in @str.
 */
char *skip_spaces(const char *str)
{
a000249c:	3c1c0000 	lui	gp,0x0
a00024a0:	279c34a4 	addiu	gp,gp,13476
a00024a4:	0399e021 	addu	gp,gp,t9
a00024a8:	00801021 	move	v0,a0
        
        while (isspace(*str))
a00024ac:	8f840094 	lw	a0,148(gp)
a00024b0:	90430000 	lbu	v1,0(v0)
a00024b4:	00831821 	addu	v1,a0,v1
a00024b8:	90630000 	lbu	v1,0(v1)
a00024bc:	30630020 	andi	v1,v1,0x20
a00024c0:	10600003 	beqz	v1,a00024d0 <skip_spaces+0x34>
a00024c4:	00000000 	nop
                ++str;
a00024c8:	1000fff9 	b	a00024b0 <skip_spaces+0x14>
a00024cc:	24420001 	addiu	v0,v0,1
        
        return (char *)str;
}
a00024d0:	03e00008 	jr	ra
a00024d4:	00000000 	nop

a00024d8 <strlen>:
 */
size_t strlen(const char * s)
{
	const char *sc;

	for (sc = s; *sc != '\0'; ++sc)
a00024d8:	00801021 	move	v0,a0
a00024dc:	80430000 	lb	v1,0(v0)
a00024e0:	10600003 	beqz	v1,a00024f0 <strlen+0x18>
a00024e4:	00000000 	nop
a00024e8:	1000fffc 	b	a00024dc <strlen+0x4>
a00024ec:	24420001 	addiu	v0,v0,1
		/* nothing */;
	return sc - s;
}
a00024f0:	03e00008 	jr	ra
a00024f4:	00441023 	subu	v0,v0,a0

a00024f8 <strrchr>:
 * strrchr - Find the last occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
a00024f8:	3c1c0000 	lui	gp,0x0
a00024fc:	279c3448 	addiu	gp,gp,13384
a0002500:	0399e021 	addu	gp,gp,t9
a0002504:	27bdffd8 	addiu	sp,sp,-40
       const char *p = s + strlen(s);
a0002508:	8f990098 	lw	t9,152(gp)
 * strrchr - Find the last occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
a000250c:	afb10020 	sw	s1,32(sp)
a0002510:	afb0001c 	sw	s0,28(sp)
a0002514:	afbc0010 	sw	gp,16(sp)
a0002518:	afbf0024 	sw	ra,36(sp)
a000251c:	00808021 	move	s0,a0
       const char *p = s + strlen(s);
a0002520:	0320f809 	jalr	t9
a0002524:	00a08821 	move	s1,a1
a0002528:	02021021 	addu	v0,s0,v0
       do {
	   if (*p == (char)c)
a000252c:	7c118c20 	seb	s1,s1
a0002530:	80430000 	lb	v1,0(v0)
a0002534:	10710007 	beq	v1,s1,a0002554 <strrchr+0x5c>
a0002538:	8fbf0024 	lw	ra,36(sp)
	       return (char *)p;
       } while (--p >= s);
a000253c:	2442ffff 	addiu	v0,v0,-1
a0002540:	0050182b 	sltu	v1,v0,s0
a0002544:	5060fffb 	beqzl	v1,a0002534 <strrchr+0x3c>
a0002548:	80430000 	lb	v1,0(v0)
       return NULL;
a000254c:	00001021 	move	v0,zero
}
a0002550:	8fbf0024 	lw	ra,36(sp)
a0002554:	8fb10020 	lw	s1,32(sp)
a0002558:	8fb0001c 	lw	s0,28(sp)
a000255c:	03e00008 	jr	ra
a0002560:	27bd0028 	addiu	sp,sp,40

a0002564 <strim>:
 * Note that the first trailing whitespace is replaced with a %NUL-terminator
 * in the given string @s. Returns a pointer to the first non-whitespace
 * character in @s.
 */
char *strim(char *s)
{
a0002564:	3c1c0000 	lui	gp,0x0
a0002568:	279c33dc 	addiu	gp,gp,13276
a000256c:	0399e021 	addu	gp,gp,t9
a0002570:	27bdffe0 	addiu	sp,sp,-32
        size_t size;
        char *end;

        s = skip_spaces(s);
a0002574:	8f99009c 	lw	t9,156(gp)
 * Note that the first trailing whitespace is replaced with a %NUL-terminator
 * in the given string @s. Returns a pointer to the first non-whitespace
 * character in @s.
 */
char *strim(char *s)
{
a0002578:	afbc0010 	sw	gp,16(sp)
a000257c:	afbf001c 	sw	ra,28(sp)
a0002580:	afb00018 	sw	s0,24(sp)
        size_t size;
        char *end;

        s = skip_spaces(s);
a0002584:	0320f809 	jalr	t9
a0002588:	00000000 	nop
a000258c:	8fbc0010 	lw	gp,16(sp)
        size = strlen(s);
a0002590:	00402021 	move	a0,v0
a0002594:	8f990098 	lw	t9,152(gp)
a0002598:	0320f809 	jalr	t9
a000259c:	00408021 	move	s0,v0
        if (!size)
a00025a0:	10400010 	beqz	v0,a00025e4 <strim+0x80>
a00025a4:	8fbc0010 	lw	gp,16(sp)
                return s;

        end = s + size - 1;
a00025a8:	2443ffff 	addiu	v1,v0,-1
        while (end >= s && isspace(*end))
a00025ac:	8f840094 	lw	a0,148(gp)
        s = skip_spaces(s);
        size = strlen(s);
        if (!size)
                return s;

        end = s + size - 1;
a00025b0:	02031821 	addu	v1,s0,v1
        while (end >= s && isspace(*end))
a00025b4:	0070102b 	sltu	v0,v1,s0
a00025b8:	50400003 	beqzl	v0,a00025c8 <strim+0x64>
a00025bc:	90620000 	lbu	v0,0(v1)
                end--;
        *(end + 1) = '\0';

        return s;
a00025c0:	10000008 	b	a00025e4 <strim+0x80>
a00025c4:	a0600001 	sb	zero,1(v1)
        size = strlen(s);
        if (!size)
                return s;

        end = s + size - 1;
        while (end >= s && isspace(*end))
a00025c8:	00821021 	addu	v0,a0,v0
a00025cc:	90420000 	lbu	v0,0(v0)
a00025d0:	30420020 	andi	v0,v0,0x20
a00025d4:	50400003 	beqzl	v0,a00025e4 <strim+0x80>
a00025d8:	a0600001 	sb	zero,1(v1)
                end--;
a00025dc:	1000fff5 	b	a00025b4 <strim+0x50>
a00025e0:	2463ffff 	addiu	v1,v1,-1
        *(end + 1) = '\0';

        return s;
}
a00025e4:	8fbf001c 	lw	ra,28(sp)
a00025e8:	02001021 	move	v0,s0
a00025ec:	8fb00018 	lw	s0,24(sp)
a00025f0:	03e00008 	jr	ra
a00025f4:	27bd0020 	addiu	sp,sp,32

a00025f8 <strnlen>:
 * strnlen - Find the length of a length-limited string
 * @s: The string to be sized
 * @count: The maximum number of bytes to search
 */
size_t strnlen(const char * s, size_t count)
{
a00025f8:	00852821 	addu	a1,a0,a1
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
a00025fc:	00801021 	move	v0,a0
a0002600:	54450003 	bnel	v0,a1,a0002610 <strnlen+0x18>
a0002604:	80430000 	lb	v1,0(v0)
		/* nothing */;
	return sc - s;
a0002608:	03e00008 	jr	ra
a000260c:	00441023 	subu	v0,v0,a0
 */
size_t strnlen(const char * s, size_t count)
{
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
a0002610:	1060fffd 	beqz	v1,a0002608 <strnlen+0x10>
a0002614:	00000000 	nop
a0002618:	1000fff9 	b	a0002600 <strnlen+0x8>
a000261c:	24420001 	addiu	v0,v0,1

a0002620 <strdup>:
}
#endif

#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
a0002620:	3c1c0000 	lui	gp,0x0
a0002624:	279c3320 	addiu	gp,gp,13088
a0002628:	0399e021 	addu	gp,gp,t9
a000262c:	27bdffd8 	addiu	sp,sp,-40
a0002630:	afbc0010 	sw	gp,16(sp)
a0002634:	afb10020 	sw	s1,32(sp)
a0002638:	afbf0024 	sw	ra,36(sp)
a000263c:	afb0001c 	sw	s0,28(sp)
	char *new;

	if ((s == NULL)	||
a0002640:	10800011 	beqz	a0,a0002688 <strdup+0x68>
a0002644:	00808821 	move	s1,a0
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
a0002648:	8f990098 	lw	t9,152(gp)
a000264c:	0320f809 	jalr	t9
a0002650:	00000000 	nop
a0002654:	8fbc0010 	lw	gp,16(sp)
#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
	char *new;

	if ((s == NULL)	||
a0002658:	8f9900a0 	lw	t9,160(gp)
a000265c:	0320f809 	jalr	t9
a0002660:	24440001 	addiu	a0,v0,1
a0002664:	00408021 	move	s0,v0
a0002668:	10400007 	beqz	v0,a0002688 <strdup+0x68>
a000266c:	8fbc0010 	lw	gp,16(sp)
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
	}

	strcpy (new, s);
a0002670:	8f9900a4 	lw	t9,164(gp)
a0002674:	00402021 	move	a0,v0
a0002678:	0320f809 	jalr	t9
a000267c:	02202821 	move	a1,s1
	return new;
a0002680:	10000002 	b	a000268c <strdup+0x6c>
a0002684:	02001021 	move	v0,s0
a0002688:	00001021 	move	v0,zero
}
a000268c:	8fbf0024 	lw	ra,36(sp)
a0002690:	8fb10020 	lw	s1,32(sp)
a0002694:	8fb0001c 	lw	s0,28(sp)
a0002698:	03e00008 	jr	ra
a000269c:	27bd0028 	addiu	sp,sp,40

a00026a0 <strspn>:
{
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
a00026a0:	00801821 	move	v1,a0
a00026a4:	80670000 	lb	a3,0(v1)
a00026a8:	10e00009 	beqz	a3,a00026d0 <strspn+0x30>
a00026ac:	00641023 	subu	v0,v1,a0
a00026b0:	00a03021 	move	a2,a1
		for (a = accept; *a != '\0'; ++a) {
a00026b4:	80c80000 	lb	t0,0(a2)
a00026b8:	11000005 	beqz	t0,a00026d0 <strspn+0x30>
a00026bc:	00000000 	nop
			if (*p == *a)
a00026c0:	14e8fffc 	bne	a3,t0,a00026b4 <strspn+0x14>
a00026c4:	24c60001 	addiu	a2,a2,1
{
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
a00026c8:	1000fff6 	b	a00026a4 <strspn+0x4>
a00026cc:	24630001 	addiu	v1,v1,1
			return count;
		++count;
	}

	return count;
}
a00026d0:	03e00008 	jr	ra
a00026d4:	00000000 	nop

a00026d8 <strpbrk>:
 */
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
a00026d8:	80830000 	lb	v1,0(a0)
a00026dc:	1060000b 	beqz	v1,a000270c <strpbrk+0x34>
a00026e0:	00000000 	nop
a00026e4:	00a01021 	move	v0,a1
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
a00026e8:	80460000 	lb	a2,0(v0)
a00026ec:	50c0fffa 	beqzl	a2,a00026d8 <strpbrk>
a00026f0:	24840001 	addiu	a0,a0,1
			if (*sc1 == *sc2)
a00026f4:	10660003 	beq	v1,a2,a0002704 <strpbrk+0x2c>
a00026f8:	00000000 	nop
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
a00026fc:	1000fffa 	b	a00026e8 <strpbrk+0x10>
a0002700:	24420001 	addiu	v0,v0,1
a0002704:	03e00008 	jr	ra
a0002708:	00801021 	move	v0,a0
			if (*sc1 == *sc2)
				return (char *) sc1;
		}
	}
	return NULL;
}
a000270c:	03e00008 	jr	ra
a0002710:	00001021 	move	v0,zero

a0002714 <strtok>:
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
a0002714:	3c1c0000 	lui	gp,0x0
a0002718:	279c322c 	addiu	gp,gp,12844
a000271c:	0399e021 	addu	gp,gp,t9
a0002720:	27bdffd8 	addiu	sp,sp,-40
a0002724:	afbc0010 	sw	gp,16(sp)
a0002728:	afb20020 	sw	s2,32(sp)
a000272c:	afb1001c 	sw	s1,28(sp)
a0002730:	afb00018 	sw	s0,24(sp)
a0002734:	afbf0024 	sw	ra,36(sp)
a0002738:	00808021 	move	s0,a0
a000273c:	00a09021 	move	s2,a1
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
a0002740:	14800004 	bnez	a0,a0002754 <strtok+0x40>
a0002744:	8f9100a8 	lw	s1,168(gp)
a0002748:	8e300000 	lw	s0,0(s1)
	if (!sbegin) {
a000274c:	12000018 	beqz	s0,a00027b0 <strtok+0x9c>
a0002750:	00001021 	move	v0,zero
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
a0002754:	8f9900ac 	lw	t9,172(gp)
a0002758:	02002021 	move	a0,s0
a000275c:	0320f809 	jalr	t9
a0002760:	02402821 	move	a1,s2
a0002764:	02028021 	addu	s0,s0,v0
	if (*sbegin == '\0') {
a0002768:	82020000 	lb	v0,0(s0)
a000276c:	14400003 	bnez	v0,a000277c <strtok+0x68>
a0002770:	8fbc0010 	lw	gp,16(sp)
		___strtok = NULL;
		return( NULL );
a0002774:	1000000e 	b	a00027b0 <strtok+0x9c>
a0002778:	ae200000 	sw	zero,0(s1)
	}
	send = strpbrk( sbegin, ct);
a000277c:	8f9900b0 	lw	t9,176(gp)
a0002780:	02002021 	move	a0,s0
a0002784:	0320f809 	jalr	t9
a0002788:	02402821 	move	a1,s2
	if (send && *send != '\0')
a000278c:	50400007 	beqzl	v0,a00027ac <strtok+0x98>
a0002790:	ae220000 	sw	v0,0(s1)
a0002794:	80430000 	lb	v1,0(v0)
a0002798:	50600004 	beqzl	v1,a00027ac <strtok+0x98>
a000279c:	ae220000 	sw	v0,0(s1)
		*send++ = '\0';
a00027a0:	a0400000 	sb	zero,0(v0)
a00027a4:	24420001 	addiu	v0,v0,1
	___strtok = send;
a00027a8:	ae220000 	sw	v0,0(s1)
a00027ac:	02001021 	move	v0,s0
	return (sbegin);
}
a00027b0:	8fbf0024 	lw	ra,36(sp)
a00027b4:	8fb20020 	lw	s2,32(sp)
a00027b8:	8fb1001c 	lw	s1,28(sp)
a00027bc:	8fb00018 	lw	s0,24(sp)
a00027c0:	03e00008 	jr	ra
a00027c4:	27bd0028 	addiu	sp,sp,40

a00027c8 <strsep>:
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
a00027c8:	3c1c0000 	lui	gp,0x0
a00027cc:	279c3178 	addiu	gp,gp,12664
a00027d0:	0399e021 	addu	gp,gp,t9
a00027d4:	27bdffd8 	addiu	sp,sp,-40
a00027d8:	afb10020 	sw	s1,32(sp)
a00027dc:	afbc0010 	sw	gp,16(sp)
a00027e0:	afbf0024 	sw	ra,36(sp)
a00027e4:	afb0001c 	sw	s0,28(sp)
	char *sbegin = *s, *end;
a00027e8:	8c900000 	lw	s0,0(a0)

	if (sbegin == NULL)
a00027ec:	1200000b 	beqz	s0,a000281c <strsep+0x54>
a00027f0:	00808821 	move	s1,a0
		return NULL;

	end = strpbrk(sbegin, ct);
a00027f4:	8f9900b0 	lw	t9,176(gp)
a00027f8:	0320f809 	jalr	t9
a00027fc:	02002021 	move	a0,s0
	if (end)
a0002800:	50400004 	beqzl	v0,a0002814 <strsep+0x4c>
a0002804:	ae220000 	sw	v0,0(s1)
		*end++ = '\0';
a0002808:	a0400000 	sb	zero,0(v0)
a000280c:	24420001 	addiu	v0,v0,1
	*s = end;
a0002810:	ae220000 	sw	v0,0(s1)

	return sbegin;
a0002814:	10000002 	b	a0002820 <strsep+0x58>
a0002818:	02001021 	move	v0,s0
char * strsep(char **s, const char *ct)
{
	char *sbegin = *s, *end;

	if (sbegin == NULL)
		return NULL;
a000281c:	00001021 	move	v0,zero
	if (end)
		*end++ = '\0';
	*s = end;

	return sbegin;
}
a0002820:	8fbf0024 	lw	ra,36(sp)
a0002824:	8fb10020 	lw	s1,32(sp)
a0002828:	8fb0001c 	lw	s0,28(sp)
a000282c:	03e00008 	jr	ra
a0002830:	27bd0028 	addiu	sp,sp,40

a0002834 <strswab>:
 */
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
a0002834:	1080000e 	beqz	a0,a0002870 <strswab+0x3c>
a0002838:	00000000 	nop
a000283c:	80820000 	lb	v0,0(a0)
a0002840:	1040000b 	beqz	v0,a0002870 <strswab+0x3c>
a0002844:	00801821 	move	v1,a0
		return (NULL);
	}

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
a0002848:	80650000 	lb	a1,0(v1)
a000284c:	10a0000a 	beqz	a1,a0002878 <strswab+0x44>
a0002850:	00000000 	nop
a0002854:	80620001 	lb	v0,1(v1)
a0002858:	10400007 	beqz	v0,a0002878 <strswab+0x44>
a000285c:	00000000 	nop
		char  tmp;

		tmp = *p;
		*p  = *q;
a0002860:	a0620000 	sb	v0,0(v1)
		*q  = tmp;
a0002864:	a0650001 	sb	a1,1(v1)

	if ((NULL == s) || ('\0' == *s)) {
		return (NULL);
	}

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
a0002868:	1000fff7 	b	a0002848 <strswab+0x14>
a000286c:	24630002 	addiu	v1,v1,2
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
		return (NULL);
a0002870:	03e00008 	jr	ra
a0002874:	00001021 	move	v0,zero
		*p  = *q;
		*q  = tmp;
	}

	return (char *) s;
}
a0002878:	03e00008 	jr	ra
a000287c:	00801021 	move	v0,a0

a0002880 <memset>:
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
{
a0002880:	00801021 	move	v0,a0
	unsigned long cl = 0;
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
a0002884:	30840003 	andi	a0,a0,0x3
a0002888:	14800014 	bnez	a0,a00028dc <memset+0x5c>
a000288c:	00401821 	move	v1,v0
a0002890:	24030005 	li	v1,5
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
a0002894:	30a700ff 	andi	a3,a1,0xff
a0002898:	2463ffff 	addiu	v1,v1,-1
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
a000289c:	50600004 	beqzl	v1,a00028b0 <memset+0x30>
a00028a0:	00401821 	move	v1,v0
			cl <<= 8;
a00028a4:	00042200 	sll	a0,a0,0x8
			cl |= c & 0xff;
a00028a8:	1000fffb 	b	a0002898 <memset+0x18>
a00028ac:	00872025 	or	a0,a0,a3
a00028b0:	00464021 	addu	t0,v0,a2
a00028b4:	01033823 	subu	a3,t0,v1
		}
		while (count >= sizeof(*sl)) {
a00028b8:	2ce70004 	sltiu	a3,a3,4
a00028bc:	14e00003 	bnez	a3,a00028cc <memset+0x4c>
a00028c0:	24630004 	addiu	v1,v1,4
			*sl++ = cl;
a00028c4:	1000fffb 	b	a00028b4 <memset+0x34>
a00028c8:	ac64fffc 	sw	a0,-4(v1)
a00028cc:	00061882 	srl	v1,a2,0x2
a00028d0:	00031880 	sll	v1,v1,0x2
a00028d4:	00431821 	addu	v1,v0,v1
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
a00028d8:	30c60003 	andi	a2,a2,0x3
a00028dc:	00663021 	addu	a2,v1,a2
			count -= sizeof(*sl);
		}
	}
	/* fill 8 bits at a time */
	s8 = (char *)sl;
	while (count--)
a00028e0:	10660003 	beq	v1,a2,a00028f0 <memset+0x70>
a00028e4:	24630001 	addiu	v1,v1,1
		*s8++ = c;
a00028e8:	1000fffd 	b	a00028e0 <memset+0x60>
a00028ec:	a065ffff 	sb	a1,-1(v1)

	return s;
}
a00028f0:	03e00008 	jr	ra
a00028f4:	00000000 	nop

a00028f8 <bcopy>:
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
char * bcopy(const char * src, char * dest, int count)
{
a00028f8:	00a01021 	move	v0,a1
	char *tmp = dest;

	while (count--)
a00028fc:	00001821 	move	v1,zero
a0002900:	10660006 	beq	v1,a2,a000291c <bcopy+0x24>
a0002904:	00832821 	addu	a1,a0,v1
		*tmp++ = *src++;
a0002908:	80a70000 	lb	a3,0(a1)
a000290c:	00432821 	addu	a1,v0,v1
a0002910:	24630001 	addiu	v1,v1,1
a0002914:	1000fffa 	b	a0002900 <bcopy+0x8>
a0002918:	a0a70000 	sb	a3,0(a1)

	return dest;
}
a000291c:	03e00008 	jr	ra
a0002920:	00000000 	nop

a0002924 <memcpy>:
{
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
	char *d8, *s8;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
a0002924:	00851825 	or	v1,a0,a1
a0002928:	30630003 	andi	v1,v1,0x3
a000292c:	1460000f 	bnez	v1,a000296c <memcpy+0x48>
a0002930:	00801021 	move	v0,a0
a0002934:	00c32023 	subu	a0,a2,v1
		while (count >= sizeof(*dl)) {
a0002938:	2c840004 	sltiu	a0,a0,4
a000293c:	14800006 	bnez	a0,a0002958 <memcpy+0x34>
a0002940:	00a32021 	addu	a0,a1,v1
			*dl++ = *sl++;
a0002944:	8c870000 	lw	a3,0(a0)
a0002948:	00432021 	addu	a0,v0,v1
a000294c:	24630004 	addiu	v1,v1,4
a0002950:	1000fff8 	b	a0002934 <memcpy+0x10>
a0002954:	ac870000 	sw	a3,0(a0)
a0002958:	00061882 	srl	v1,a2,0x2
a000295c:	00031880 	sll	v1,v1,0x2
a0002960:	00432021 	addu	a0,v0,v1
a0002964:	00a32821 	addu	a1,a1,v1
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
	char *d8, *s8;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
		while (count >= sizeof(*dl)) {
a0002968:	30c60003 	andi	a2,a2,0x3
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
{
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
a000296c:	00001821 	move	v1,zero
		}
	}
	/* copy the reset one byte at a time */
	d8 = (char *)dl;
	s8 = (char *)sl;
	while (count--)
a0002970:	10660006 	beq	v1,a2,a000298c <memcpy+0x68>
a0002974:	00a33821 	addu	a3,a1,v1
		*d8++ = *s8++;
a0002978:	80e80000 	lb	t0,0(a3)
a000297c:	00833821 	addu	a3,a0,v1
a0002980:	24630001 	addiu	v1,v1,1
a0002984:	1000fffa 	b	a0002970 <memcpy+0x4c>
a0002988:	a0e80000 	sb	t0,0(a3)

	return dest;
}
a000298c:	03e00008 	jr	ra
a0002990:	00000000 	nop

a0002994 <memmove>:
 */
void * memmove(void * dest,const void *src,size_t count)
{
	char *tmp, *s;

	if (dest <= src) {
a0002994:	00a4182b 	sltu	v1,a1,a0
a0002998:	14600009 	bnez	v1,a00029c0 <memmove+0x2c>
a000299c:	00801021 	move	v0,a0
a00029a0:	00001821 	move	v1,zero
		tmp = (char *) dest;
		s = (char *) src;
		while (count--)
a00029a4:	10660013 	beq	v1,a2,a00029f4 <memmove+0x60>
a00029a8:	00a32021 	addu	a0,a1,v1
			*tmp++ = *s++;
a00029ac:	80870000 	lb	a3,0(a0)
a00029b0:	00432021 	addu	a0,v0,v1
a00029b4:	24630001 	addiu	v1,v1,1
a00029b8:	1000fffa 	b	a00029a4 <memmove+0x10>
a00029bc:	a0870000 	sb	a3,0(a0)
		}
	else {
		tmp = (char *) dest + count;
a00029c0:	00863821 	addu	a3,a0,a2
a00029c4:	00061823 	negu	v1,a2
		s = (char *) src + count;
a00029c8:	00a62821 	addu	a1,a1,a2
a00029cc:	00a32821 	addu	a1,a1,v1
		while (count--)
a00029d0:	2404ffff 	li	a0,-1
a00029d4:	00e31821 	addu	v1,a3,v1
a00029d8:	24c6ffff 	addiu	a2,a2,-1
a00029dc:	10c40005 	beq	a2,a0,a00029f4 <memmove+0x60>
a00029e0:	00a63821 	addu	a3,a1,a2
			*--tmp = *--s;
a00029e4:	80e80000 	lb	t0,0(a3)
a00029e8:	00663821 	addu	a3,v1,a2
a00029ec:	1000fffa 	b	a00029d8 <memmove+0x44>
a00029f0:	a0e80000 	sb	t0,0(a3)
		}

	return dest;
}
a00029f4:	03e00008 	jr	ra
a00029f8:	00000000 	nop

a00029fc <memcmp>:
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
a00029fc:	00001821 	move	v1,zero
a0002a00:	10660008 	beq	v1,a2,a0002a24 <memcmp+0x28>
a0002a04:	00001021 	move	v0,zero
a0002a08:	00831021 	addu	v0,a0,v1
		if ((res = *su1 - *su2) != 0)
a0002a0c:	90470000 	lbu	a3,0(v0)
a0002a10:	00a31021 	addu	v0,a1,v1
a0002a14:	90420000 	lbu	v0,0(v0)
a0002a18:	00e21023 	subu	v0,a3,v0
a0002a1c:	1040fff8 	beqz	v0,a0002a00 <memcmp+0x4>
a0002a20:	24630001 	addiu	v1,v1,1
			break;
	return res;
}
a0002a24:	03e00008 	jr	ra
a0002a28:	00000000 	nop

a0002a2c <memscan>:
 *
 * returns the address of the first occurrence of @c, or 1 byte past
 * the area if @c is not found
 */
void * memscan(void * addr, int c, size_t size)
{
a0002a2c:	00801021 	move	v0,a0
a0002a30:	00863021 	addu	a2,a0,a2
	unsigned char * p = (unsigned char *) addr;

	while (size) {
a0002a34:	10460006 	beq	v0,a2,a0002a50 <memscan+0x24>
a0002a38:	00000000 	nop
		if (*p == c)
a0002a3c:	90430000 	lbu	v1,0(v0)
a0002a40:	10650003 	beq	v1,a1,a0002a50 <memscan+0x24>
a0002a44:	00000000 	nop
			return (void *) p;
		p++;
a0002a48:	1000fffa 	b	a0002a34 <memscan+0x8>
a0002a4c:	24420001 	addiu	v0,v0,1
		size--;
	}
	return (void *) p;
}
a0002a50:	03e00008 	jr	ra
a0002a54:	00000000 	nop

a0002a58 <strstr>:
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
a0002a58:	3c1c0000 	lui	gp,0x0
a0002a5c:	279c2ee8 	addiu	gp,gp,12008
a0002a60:	0399e021 	addu	gp,gp,t9
a0002a64:	27bdffd0 	addiu	sp,sp,-48
	int l1, l2;

	l2 = strlen(s2);
a0002a68:	8f990098 	lw	t9,152(gp)
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
a0002a6c:	afbc0010 	sw	gp,16(sp)
a0002a70:	afb30024 	sw	s3,36(sp)
a0002a74:	afb20020 	sw	s2,32(sp)
a0002a78:	afb1001c 	sw	s1,28(sp)
a0002a7c:	00809021 	move	s2,a0
a0002a80:	afbf002c 	sw	ra,44(sp)
a0002a84:	afb40028 	sw	s4,40(sp)
a0002a88:	afb00018 	sw	s0,24(sp)
	int l1, l2;

	l2 = strlen(s2);
a0002a8c:	00a02021 	move	a0,a1
a0002a90:	0320f809 	jalr	t9
a0002a94:	00a09821 	move	s3,a1
a0002a98:	00408821 	move	s1,v0
a0002a9c:	8fbc0010 	lw	gp,16(sp)
	if (!l2)
a0002aa0:	12200015 	beqz	s1,a0002af8 <strstr+0xa0>
a0002aa4:	02401021 	move	v0,s2
		return (char *) s1;
	l1 = strlen(s1);
a0002aa8:	8f990098 	lw	t9,152(gp)
a0002aac:	0320f809 	jalr	t9
a0002ab0:	02402021 	move	a0,s2
a0002ab4:	8fbc0010 	lw	gp,16(sp)
a0002ab8:	00408021 	move	s0,v0
a0002abc:	02429021 	addu	s2,s2,v0
	while (l1 >= l2) {
a0002ac0:	0211102a 	slt	v0,s0,s1
a0002ac4:	1440000b 	bnez	v0,a0002af4 <strstr+0x9c>
a0002ac8:	0250a023 	subu	s4,s2,s0
		l1--;
		if (!memcmp(s1,s2,l2))
a0002acc:	8f9900b4 	lw	t9,180(gp)
a0002ad0:	02802021 	move	a0,s4
a0002ad4:	02602821 	move	a1,s3
a0002ad8:	0320f809 	jalr	t9
a0002adc:	02203021 	move	a2,s1
	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
		l1--;
a0002ae0:	2610ffff 	addiu	s0,s0,-1
		if (!memcmp(s1,s2,l2))
a0002ae4:	1440fff6 	bnez	v0,a0002ac0 <strstr+0x68>
a0002ae8:	8fbc0010 	lw	gp,16(sp)
a0002aec:	10000002 	b	a0002af8 <strstr+0xa0>
a0002af0:	02801021 	move	v0,s4
			return (char *) s1;
		s1++;
	}
	return NULL;
a0002af4:	00001021 	move	v0,zero
}
a0002af8:	8fbf002c 	lw	ra,44(sp)
a0002afc:	8fb40028 	lw	s4,40(sp)
a0002b00:	8fb30024 	lw	s3,36(sp)
a0002b04:	8fb20020 	lw	s2,32(sp)
a0002b08:	8fb1001c 	lw	s1,28(sp)
a0002b0c:	8fb00018 	lw	s0,24(sp)
a0002b10:	03e00008 	jr	ra
a0002b14:	27bd0030 	addiu	sp,sp,48

a0002b18 <memchr>:
 *
 * returns the address of the first occurrence of @c, or %NULL
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
a0002b18:	00863021 	addu	a2,a0,a2
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
a0002b1c:	30a500ff 	andi	a1,a1,0xff
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
a0002b20:	10860006 	beq	a0,a2,a0002b3c <memchr+0x24>
a0002b24:	00000000 	nop
		if ((unsigned char)c == *p++) {
a0002b28:	90830000 	lbu	v1,0(a0)
a0002b2c:	10650005 	beq	v1,a1,a0002b44 <memchr+0x2c>
a0002b30:	24820001 	addiu	v0,a0,1
a0002b34:	1000fffa 	b	a0002b20 <memchr+0x8>
a0002b38:	00402021 	move	a0,v0
a0002b3c:	03e00008 	jr	ra
a0002b40:	00001021 	move	v0,zero
			return (void *)(p-1);
		}
	}
	return NULL;
}
a0002b44:	03e00008 	jr	ra
a0002b48:	00801021 	move	v0,a0
a0002b4c:	00000000 	nop

a0002b50 <timer_init>:
/*
 * timer without interrupts
 */

int timer_init(void)
{
a0002b50:	3c1c0000 	lui	gp,0x0
a0002b54:	279c2df0 	addiu	gp,gp,11760
a0002b58:	0399e021 	addu	gp,gp,t9
	/* Set up the timer for the first expiration. */
	timestamp = 0;
a0002b5c:	8f820058 	lw	v0,88(gp)
a0002b60:	ac405a70 	sw	zero,23152(v0)
	write_c0_compare(read_c0_count() + CYCLES_PER_JIFFY);
a0002b64:	40024800 	mfc0	v0,c0_count
a0002b68:	3c030006 	lui	v1,0x6
a0002b6c:	24631a80 	addiu	v1,v1,6784
a0002b70:	00431021 	addu	v0,v0,v1

	return 0;
}
a0002b74:	40825800 	mtc0	v0,c0_compare
a0002b78:	03e00008 	jr	ra
a0002b7c:	00001021 	move	v0,zero

a0002b80 <reset_timer>:

void reset_timer(void)
{
a0002b80:	3c1c0000 	lui	gp,0x0
a0002b84:	279c2dc0 	addiu	gp,gp,11712
a0002b88:	0399e021 	addu	gp,gp,t9
	timestamp = 0;
a0002b8c:	8f820058 	lw	v0,88(gp)
a0002b90:	ac405a70 	sw	zero,23152(v0)
	write_c0_compare(read_c0_count() + CYCLES_PER_JIFFY);
a0002b94:	40024800 	mfc0	v0,c0_count
a0002b98:	3c030006 	lui	v1,0x6
a0002b9c:	24631a80 	addiu	v1,v1,6784
a0002ba0:	00431021 	addu	v0,v0,v1
a0002ba4:	03e00008 	jr	ra
a0002ba8:	40825800 	mtc0	v0,c0_compare

a0002bac <get_timer>:
}

ulong get_timer(ulong base)
{
a0002bac:	3c1c0000 	lui	gp,0x0
a0002bb0:	279c2d94 	addiu	gp,gp,11668
a0002bb4:	0399e021 	addu	gp,gp,t9
	unsigned int count;
	unsigned int expirelo = read_c0_compare();
a0002bb8:	40035800 	mfc0	v1,c0_compare

	/* Check to see if we have missed any timestamps. */
	count = read_c0_count();
a0002bbc:	40084800 	mfc0	t0,c0_count
    asm("sync");
a0002bc0:	0000000f 	sync
a0002bc4:	8f850058 	lw	a1,88(gp)
    while ((count - expirelo) < 0x7fffffff) {
a0002bc8:	3c077fff 	lui	a3,0x7fff
        asm("sync");
        expirelo += CYCLES_PER_JIFFY;
a0002bcc:	3c0a0006 	lui	t2,0x6
	unsigned int expirelo = read_c0_compare();

	/* Check to see if we have missed any timestamps. */
	count = read_c0_count();
    asm("sync");
    while ((count - expirelo) < 0x7fffffff) {
a0002bd0:	8ca25a70 	lw	v0,23152(a1)
a0002bd4:	34e7ffff 	ori	a3,a3,0xffff
        asm("sync");
        expirelo += CYCLES_PER_JIFFY;
a0002bd8:	254a1a80 	addiu	t2,t2,6784
a0002bdc:	01033023 	subu	a2,t0,v1
	unsigned int expirelo = read_c0_compare();

	/* Check to see if we have missed any timestamps. */
	count = read_c0_count();
    asm("sync");
    while ((count - expirelo) < 0x7fffffff) {
a0002be0:	00c7302b 	sltu	a2,a2,a3
a0002be4:	10c00006 	beqz	a2,a0002c00 <get_timer+0x54>
a0002be8:	24490001 	addiu	t1,v0,1
        asm("sync");
a0002bec:	0000000f 	sync
        expirelo += CYCLES_PER_JIFFY;
a0002bf0:	006a1821 	addu	v1,v1,t2
	    asm("sync");
a0002bf4:	0000000f 	sync
a0002bf8:	1000fff8 	b	a0002bdc <get_timer+0x30>
a0002bfc:	01201021 	move	v0,t1
a0002c00:	aca25a70 	sw	v0,23152(a1)
	    timestamp++;
	}
	asm("sync");
a0002c04:	0000000f 	sync
	write_c0_compare(expirelo);
a0002c08:	40835800 	mtc0	v1,c0_compare
    
	return (timestamp - base);
}
a0002c0c:	03e00008 	jr	ra
a0002c10:	00441023 	subu	v0,v0,a0

a0002c14 <set_timer>:

void set_timer(ulong t)
{
a0002c14:	3c1c0000 	lui	gp,0x0
a0002c18:	279c2d2c 	addiu	gp,gp,11564
a0002c1c:	0399e021 	addu	gp,gp,t9
	timestamp = t;
a0002c20:	8f820058 	lw	v0,88(gp)
a0002c24:	ac445a70 	sw	a0,23152(v0)
	write_c0_compare(read_c0_count() + CYCLES_PER_JIFFY);
a0002c28:	40024800 	mfc0	v0,c0_count
a0002c2c:	3c030006 	lui	v1,0x6
a0002c30:	24631a80 	addiu	v1,v1,6784
a0002c34:	00431021 	addu	v0,v0,v1
a0002c38:	03e00008 	jr	ra
a0002c3c:	40825800 	mtc0	v0,c0_compare

a0002c40 <__udelay>:

void __udelay(unsigned long usec)
{
	unsigned int tmo;

	tmo = read_c0_count() + (usec * (CONFIG_SYS_MIPS_TIMER_FREQ / 1000000));
a0002c40:	40024800 	mfc0	v0,c0_count
a0002c44:	24030190 	li	v1,400
a0002c48:	70832802 	mul	a1,a0,v1
	while ((tmo - read_c0_count()) < 0x7fffffff)
a0002c4c:	3c037fff 	lui	v1,0x7fff
a0002c50:	3463ffff 	ori	v1,v1,0xffff

void __udelay(unsigned long usec)
{
	unsigned int tmo;

	tmo = read_c0_count() + (usec * (CONFIG_SYS_MIPS_TIMER_FREQ / 1000000));
a0002c54:	00a22021 	addu	a0,a1,v0
	while ((tmo - read_c0_count()) < 0x7fffffff)
a0002c58:	40024800 	mfc0	v0,c0_count
a0002c5c:	00821023 	subu	v0,a0,v0
a0002c60:	0043102b 	sltu	v0,v0,v1
a0002c64:	1440fffc 	bnez	v0,a0002c58 <__udelay+0x18>
a0002c68:	00000000 	nop
		/*NOP*/;
}
a0002c6c:	03e00008 	jr	ra
a0002c70:	00000000 	nop

a0002c74 <mdelay>:


void mdelay (unsigned long msec)
{
a0002c74:	3c1c0000 	lui	gp,0x0
a0002c78:	279c2ccc 	addiu	gp,gp,11468
a0002c7c:	0399e021 	addu	gp,gp,t9
a0002c80:	27bdffd8 	addiu	sp,sp,-40
a0002c84:	afb10020 	sw	s1,32(sp)
a0002c88:	afb0001c 	sw	s0,28(sp)
a0002c8c:	afbc0010 	sw	gp,16(sp)
a0002c90:	afbf0024 	sw	ra,36(sp)
a0002c94:	00808821 	move	s1,a0
       int i,j;
	   for(i=0;i<msec;i++)
a0002c98:	00008021 	move	s0,zero
a0002c9c:	12110006 	beq	s0,s1,a0002cb8 <mdelay+0x44>
a0002ca0:	8f9900b8 	lw	t9,184(gp)
	   {
	      __udelay(1000);
a0002ca4:	0320f809 	jalr	t9
a0002ca8:	240403e8 	li	a0,1000


void mdelay (unsigned long msec)
{
       int i,j;
	   for(i=0;i<msec;i++)
a0002cac:	26100001 	addiu	s0,s0,1
	   {
	      __udelay(1000);
a0002cb0:	1000fffa 	b	a0002c9c <mdelay+0x28>
a0002cb4:	8fbc0010 	lw	gp,16(sp)
	   }

}
a0002cb8:	8fbf0024 	lw	ra,36(sp)
a0002cbc:	8fb10020 	lw	s1,32(sp)
a0002cc0:	8fb0001c 	lw	s0,28(sp)
a0002cc4:	03e00008 	jr	ra
a0002cc8:	27bd0028 	addiu	sp,sp,40

a0002ccc <get_ticks>:
/*
 * This function is derived from PowerPC code (read timebase as long long).
 * On MIPS it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
a0002ccc:	3c1c0000 	lui	gp,0x0
a0002cd0:	279c2c74 	addiu	gp,gp,11380
a0002cd4:	0399e021 	addu	gp,gp,t9
a0002cd8:	27bdffe0 	addiu	sp,sp,-32
	return get_timer(0);
a0002cdc:	8f9900bc 	lw	t9,188(gp)
/*
 * This function is derived from PowerPC code (read timebase as long long).
 * On MIPS it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
a0002ce0:	afbf001c 	sw	ra,28(sp)
a0002ce4:	afbc0010 	sw	gp,16(sp)
	return get_timer(0);
a0002ce8:	0320f809 	jalr	t9
a0002cec:	00002021 	move	a0,zero
}
a0002cf0:	8fbf001c 	lw	ra,28(sp)
 * This function is derived from PowerPC code (read timebase as long long).
 * On MIPS it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
	return get_timer(0);
a0002cf4:	00401821 	move	v1,v0
}
a0002cf8:	00001021 	move	v0,zero
a0002cfc:	03e00008 	jr	ra
a0002d00:	27bd0020 	addiu	sp,sp,32

a0002d04 <get_tbclk>:
 * On MIPS it returns the number of timer ticks per second.
 */
ulong get_tbclk(void)
{
	return CONFIG_SYS_HZ;
}
a0002d04:	03e00008 	jr	ra
a0002d08:	240203e8 	li	v0,1000
a0002d0c:	00000000 	nop

a0002d10 <crc32_no_comp>:

/* No ones complement version. JFFS2 (and other things ?)
 * don't use ones compliment in their CRC calculations.
 */
uint32_t ZEXPORT crc32_no_comp(uint32_t crc, const Bytef *buf, uInt len)
{
a0002d10:	3c1c0000 	lui	gp,0x0
a0002d14:	279c2c30 	addiu	gp,gp,11312
a0002d18:	0399e021 	addu	gp,gp,t9
a0002d1c:	7c0410a0 	wsbh	v0,a0
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
a0002d20:	30a30003 	andi	v1,a1,0x3
a0002d24:	10600013 	beqz	v1,a0002d74 <crc32_no_comp+0x64>
a0002d28:	00221402 	ror	v0,v0,0x10
a0002d2c:	10c00012 	beqz	a2,a0002d78 <crc32_no_comp+0x68>
a0002d30:	8f830058 	lw	v1,88(gp)
	 uint8_t *p = (uint8_t *)b;
	 do {
	      DO_CRC(*p++);
a0002d34:	8f840058 	lw	a0,88(gp)
a0002d38:	248453c0 	addiu	a0,a0,21440
a0002d3c:	24a50001 	addiu	a1,a1,1
a0002d40:	90a3ffff 	lbu	v1,-1(a1)
a0002d44:	00023e02 	srl	a3,v0,0x18
a0002d48:	00e31826 	xor	v1,a3,v1
a0002d4c:	00031880 	sll	v1,v1,0x2
a0002d50:	00831821 	addu	v1,a0,v1
a0002d54:	00021200 	sll	v0,v0,0x8
a0002d58:	8c630000 	lw	v1,0(v1)
	 } while ((--len) && ((long)p)&3);
a0002d5c:	24c6ffff 	addiu	a2,a2,-1
a0002d60:	10c00004 	beqz	a2,a0002d74 <crc32_no_comp+0x64>
a0002d64:	00621026 	xor	v0,v1,v0
a0002d68:	30a30003 	andi	v1,a1,0x3
a0002d6c:	5460fff4 	bnezl	v1,a0002d40 <crc32_no_comp+0x30>
a0002d70:	24a50001 	addiu	a1,a1,1
    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
	 DO_CRC(0);
a0002d74:	8f830058 	lw	v1,88(gp)
	      DO_CRC(*p++);
	 } while ((--len) && ((long)p)&3);
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
a0002d78:	30c80003 	andi	t0,a2,0x3
    len = len >> 2;
    for (--b; len; --len) {
a0002d7c:	24a5fffc 	addiu	a1,a1,-4
	 } while ((--len) && ((long)p)&3);
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
a0002d80:	00063082 	srl	a2,a2,0x2
    for (--b; len; --len) {
a0002d84:	00a03821 	move	a3,a1
	 } while ((--len) && ((long)p)&3);
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
a0002d88:	00c02021 	move	a0,a2
    for (--b; len; --len) {
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
	 DO_CRC(0);
a0002d8c:	246353c0 	addiu	v1,v1,21440
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
a0002d90:	1080001d 	beqz	a0,a0002e08 <crc32_no_comp+0xf8>
a0002d94:	24e70004 	addiu	a3,a3,4
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
a0002d98:	8ce90000 	lw	t1,0(a3)
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
a0002d9c:	2484ffff 	addiu	a0,a0,-1
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
a0002da0:	00491026 	xor	v0,v0,t1
	 DO_CRC(0);
a0002da4:	00024e02 	srl	t1,v0,0x18
a0002da8:	00094880 	sll	t1,t1,0x2
a0002dac:	00694821 	addu	t1,v1,t1
a0002db0:	00021200 	sll	v0,v0,0x8
a0002db4:	8d2a0000 	lw	t2,0(t1)
a0002db8:	01421026 	xor	v0,t2,v0
	 DO_CRC(0);
a0002dbc:	00024e02 	srl	t1,v0,0x18
a0002dc0:	00094880 	sll	t1,t1,0x2
a0002dc4:	00694821 	addu	t1,v1,t1
a0002dc8:	00021200 	sll	v0,v0,0x8
a0002dcc:	8d2a0000 	lw	t2,0(t1)
a0002dd0:	01425026 	xor	t2,t2,v0
	 DO_CRC(0);
a0002dd4:	000a1602 	srl	v0,t2,0x18
a0002dd8:	00021080 	sll	v0,v0,0x2
a0002ddc:	00621021 	addu	v0,v1,v0
a0002de0:	000a5200 	sll	t2,t2,0x8
a0002de4:	8c490000 	lw	t1,0(v0)
a0002de8:	012a4826 	xor	t1,t1,t2
	 DO_CRC(0);
a0002dec:	00091602 	srl	v0,t1,0x18
a0002df0:	00021080 	sll	v0,v0,0x2
a0002df4:	00621021 	addu	v0,v1,v0
a0002df8:	00094a00 	sll	t1,t1,0x8
a0002dfc:	8c420000 	lw	v0,0(v0)
a0002e00:	1000ffe3 	b	a0002d90 <crc32_no_comp+0x80>
a0002e04:	00491026 	xor	v0,v0,t1
a0002e08:	00063080 	sll	a2,a2,0x2
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
a0002e0c:	1100000e 	beqz	t0,a0002e48 <crc32_no_comp+0x138>
a0002e10:	00a62821 	addu	a1,a1,a2
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
a0002e14:	8f840058 	lw	a0,88(gp)
a0002e18:	00a84021 	addu	t0,a1,t0
a0002e1c:	248453c0 	addiu	a0,a0,21440
a0002e20:	90a60004 	lbu	a2,4(a1)
a0002e24:	00021e02 	srl	v1,v0,0x18
a0002e28:	00c31826 	xor	v1,a2,v1
a0002e2c:	00031880 	sll	v1,v1,0x2
a0002e30:	00831821 	addu	v1,a0,v1
a0002e34:	00021200 	sll	v0,v0,0x8
a0002e38:	8c630000 	lw	v1,0(v1)
a0002e3c:	24a50001 	addiu	a1,a1,1
	 } while (--len);
a0002e40:	14a8fff7 	bne	a1,t0,a0002e20 <crc32_no_comp+0x110>
a0002e44:	00621026 	xor	v0,v1,v0
    }

    return le32_to_cpu(crc);
}
a0002e48:	7c0210a0 	wsbh	v0,v0
a0002e4c:	03e00008 	jr	ra
a0002e50:	00221402 	ror	v0,v0,0x10

a0002e54 <crc32>:
#undef DO_CRC

uint32_t ZEXPORT crc32 (uint32_t crc, const Bytef *p, uInt len)
{
a0002e54:	3c1c0000 	lui	gp,0x0
a0002e58:	279c2aec 	addiu	gp,gp,10988
a0002e5c:	0399e021 	addu	gp,gp,t9
a0002e60:	27bdffe0 	addiu	sp,sp,-32
     return crc32_no_comp(crc ^ 0xffffffffL, p, len) ^ 0xffffffffL;
a0002e64:	8f9900c0 	lw	t9,192(gp)
    return le32_to_cpu(crc);
}
#undef DO_CRC

uint32_t ZEXPORT crc32 (uint32_t crc, const Bytef *p, uInt len)
{
a0002e68:	afbf001c 	sw	ra,28(sp)
a0002e6c:	afbc0010 	sw	gp,16(sp)
     return crc32_no_comp(crc ^ 0xffffffffL, p, len) ^ 0xffffffffL;
a0002e70:	0320f809 	jalr	t9
a0002e74:	00042027 	nor	a0,zero,a0
}
a0002e78:	8fbf001c 	lw	ra,28(sp)
a0002e7c:	00021027 	nor	v0,zero,v0
a0002e80:	03e00008 	jr	ra
a0002e84:	27bd0020 	addiu	sp,sp,32

a0002e88 <crc32_wd>:
 * of input.
 */
uint32_t ZEXPORT crc32_wd (uint32_t crc,
			   const unsigned char *buf,
			   uInt len, uInt chunk_sz)
{
a0002e88:	3c1c0000 	lui	gp,0x0
a0002e8c:	279c2ab8 	addiu	gp,gp,10936
a0002e90:	0399e021 	addu	gp,gp,t9
		crc = crc32 (crc, curr, chunk);
		curr += chunk;
		WATCHDOG_RESET ();
	}
#else
	crc = crc32 (crc, buf, len);
a0002e94:	8f990060 	lw	t9,96(gp)
a0002e98:	03200008 	jr	t9
a0002e9c:	00000000 	nop

a0002ea0 <nand_calculate_ecc>:
 * @dat:	raw data
 * @ecc_code:	buffer for ECC
 */
int nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
		       u_char *ecc_code)
{
a0002ea0:	3c1c0000 	lui	gp,0x0
a0002ea4:	279c2aa0 	addiu	gp,gp,10912
a0002ea8:	0399e021 	addu	gp,gp,t9
	reg1 = reg2 = reg3 = 0;

	/* Build up column parity */
	for(i = 0; i < 256; i++) {
		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[*dat++];
a0002eac:	8f8a0058 	lw	t2,88(gp)

	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;

	/* Build up column parity */
	for(i = 0; i < 256; i++) {
a0002eb0:	00002021 	move	a0,zero
{
	uint8_t idx, reg1, reg2, reg3, tmp1, tmp2;
	int i;

	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;
a0002eb4:	00001021 	move	v0,zero
a0002eb8:	00001821 	move	v1,zero
a0002ebc:	00003821 	move	a3,zero

	/* Build up column parity */
	for(i = 0; i < 256; i++) {
		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[*dat++];
a0002ec0:	254a57c0 	addiu	t2,t2,22464

	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;

	/* Build up column parity */
	for(i = 0; i < 256; i++) {
a0002ec4:	24090100 	li	t1,256
a0002ec8:	00a44021 	addu	t0,a1,a0
		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[*dat++];
a0002ecc:	91080000 	lbu	t0,0(t0)
a0002ed0:	010a4021 	addu	t0,t0,t2
a0002ed4:	91080000 	lbu	t0,0(t0)
		reg1 ^= (idx & 0x3f);
a0002ed8:	310b003f 	andi	t3,t0,0x3f

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
a0002edc:	31080040 	andi	t0,t0,0x40
a0002ee0:	11000006 	beqz	t0,a0002efc <nand_calculate_ecc+0x5c>
a0002ee4:	01673826 	xor	a3,t3,a3
a0002ee8:	00044027 	nor	t0,zero,a0
			reg3 ^= (uint8_t) i;
a0002eec:	00441026 	xor	v0,v0,a0
			reg2 ^= ~((uint8_t) i);
a0002ef0:	01031826 	xor	v1,t0,v1
		idx = nand_ecc_precalc_table[*dat++];
		reg1 ^= (idx & 0x3f);

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
			reg3 ^= (uint8_t) i;
a0002ef4:	304200ff 	andi	v0,v0,0xff
			reg2 ^= ~((uint8_t) i);
a0002ef8:	306300ff 	andi	v1,v1,0xff

	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;

	/* Build up column parity */
	for(i = 0; i < 256; i++) {
a0002efc:	24840001 	addiu	a0,a0,1
a0002f00:	1489fff2 	bne	a0,t1,a0002ecc <nand_calculate_ecc+0x2c>
a0002f04:	00a44021 	addu	t0,a1,a0
		}
	}

	/* Create non-inverted ECC code from line parity */
	tmp1  = (reg3 & 0x80) >> 0; /* B7 -> B7 */
	tmp1 |= (reg2 & 0x80) >> 1; /* B7 -> B6 */
a0002f08:	2404ff80 	li	a0,-128
a0002f0c:	00644024 	and	t0,v1,a0
	tmp1 |= (reg3 & 0x40) >> 1; /* B6 -> B5 */
a0002f10:	30450040 	andi	a1,v0,0x40
		}
	}

	/* Create non-inverted ECC code from line parity */
	tmp1  = (reg3 & 0x80) >> 0; /* B7 -> B7 */
	tmp1 |= (reg2 & 0x80) >> 1; /* B7 -> B6 */
a0002f14:	00084043 	sra	t0,t0,0x1
	tmp1 |= (reg3 & 0x40) >> 1; /* B6 -> B5 */
a0002f18:	00052842 	srl	a1,a1,0x1
		}
	}

	/* Create non-inverted ECC code from line parity */
	tmp1  = (reg3 & 0x80) >> 0; /* B7 -> B7 */
	tmp1 |= (reg2 & 0x80) >> 1; /* B7 -> B6 */
a0002f1c:	01052825 	or	a1,t0,a1
			reg2 ^= ~((uint8_t) i);
		}
	}

	/* Create non-inverted ECC code from line parity */
	tmp1  = (reg3 & 0x80) >> 0; /* B7 -> B7 */
a0002f20:	00442024 	and	a0,v0,a0
	tmp1 |= (reg2 & 0x80) >> 1; /* B7 -> B6 */
	tmp1 |= (reg3 & 0x40) >> 1; /* B6 -> B5 */
a0002f24:	00a42025 	or	a0,a1,a0
	tmp1 |= (reg2 & 0x40) >> 2; /* B6 -> B4 */
a0002f28:	30650040 	andi	a1,v1,0x40
a0002f2c:	00052882 	srl	a1,a1,0x2
a0002f30:	00852025 	or	a0,a0,a1
	tmp1 |= (reg3 & 0x20) >> 2; /* B5 -> B3 */
a0002f34:	30450020 	andi	a1,v0,0x20
a0002f38:	00052882 	srl	a1,a1,0x2
a0002f3c:	00852025 	or	a0,a0,a1
	tmp1 |= (reg2 & 0x20) >> 3; /* B5 -> B2 */
a0002f40:	30650020 	andi	a1,v1,0x20
a0002f44:	000528c2 	srl	a1,a1,0x3
a0002f48:	00852025 	or	a0,a0,a1
	tmp1 |= (reg3 & 0x10) >> 3; /* B4 -> B1 */
a0002f4c:	30450010 	andi	a1,v0,0x10
a0002f50:	000528c2 	srl	a1,a1,0x3
a0002f54:	00852025 	or	a0,a0,a1
	tmp1 |= (reg2 & 0x10) >> 4; /* B4 -> B0 */
a0002f58:	7c650100 	ext	a1,v1,0x4,0x1
a0002f5c:	00852025 	or	a0,a0,a1

	tmp2  = (reg3 & 0x08) << 4; /* B3 -> B7 */
a0002f60:	30450008 	andi	a1,v0,0x8
	tmp2 |= (reg3 & 0x04) << 3; /* B2 -> B5 */
	tmp2 |= (reg2 & 0x04) << 2; /* B2 -> B4 */
	tmp2 |= (reg3 & 0x02) << 2; /* B1 -> B3 */
	tmp2 |= (reg2 & 0x02) << 1; /* B1 -> B2 */
	tmp2 |= (reg3 & 0x01) << 1; /* B0 -> B1 */
	tmp2 |= (reg2 & 0x01) << 0; /* B7 -> B0 */
a0002f64:	30680001 	andi	t0,v1,0x1
	tmp1 |= (reg3 & 0x20) >> 2; /* B5 -> B3 */
	tmp1 |= (reg2 & 0x20) >> 3; /* B5 -> B2 */
	tmp1 |= (reg3 & 0x10) >> 3; /* B4 -> B1 */
	tmp1 |= (reg2 & 0x10) >> 4; /* B4 -> B0 */

	tmp2  = (reg3 & 0x08) << 4; /* B3 -> B7 */
a0002f68:	00052900 	sll	a1,a1,0x4
	tmp2 |= (reg2 & 0x08) << 3; /* B3 -> B6 */
a0002f6c:	00a82825 	or	a1,a1,t0
a0002f70:	30680008 	andi	t0,v1,0x8
a0002f74:	000840c0 	sll	t0,t0,0x3
	tmp2 |= (reg3 & 0x04) << 3; /* B2 -> B5 */
a0002f78:	00a82825 	or	a1,a1,t0
a0002f7c:	30480004 	andi	t0,v0,0x4
a0002f80:	000840c0 	sll	t0,t0,0x3
	tmp2 |= (reg2 & 0x04) << 2; /* B2 -> B4 */
a0002f84:	00a82825 	or	a1,a1,t0
a0002f88:	30680004 	andi	t0,v1,0x4
a0002f8c:	00084080 	sll	t0,t0,0x2
	tmp2 |= (reg3 & 0x02) << 2; /* B1 -> B3 */
a0002f90:	00a82825 	or	a1,a1,t0
a0002f94:	30480002 	andi	t0,v0,0x2
a0002f98:	00084080 	sll	t0,t0,0x2
	tmp2 |= (reg2 & 0x02) << 1; /* B1 -> B2 */
a0002f9c:	30630002 	andi	v1,v1,0x2
a0002fa0:	00a82825 	or	a1,a1,t0
a0002fa4:	00031840 	sll	v1,v1,0x1
	tmp2 |= (reg3 & 0x01) << 1; /* B0 -> B1 */
a0002fa8:	30420001 	andi	v0,v0,0x1
a0002fac:	00a31825 	or	v1,a1,v1
a0002fb0:	00021040 	sll	v0,v0,0x1
	ecc_code[1] = ~tmp1;
#else
	ecc_code[0] = ~tmp1;
	ecc_code[1] = ~tmp2;
#endif
	ecc_code[2] = ((~reg1) << 2) | 0x03;
a0002fb4:	00073827 	nor	a3,zero,a3
	tmp2 |= (reg3 & 0x04) << 3; /* B2 -> B5 */
	tmp2 |= (reg2 & 0x04) << 2; /* B2 -> B4 */
	tmp2 |= (reg3 & 0x02) << 2; /* B1 -> B3 */
	tmp2 |= (reg2 & 0x02) << 1; /* B1 -> B2 */
	tmp2 |= (reg3 & 0x01) << 1; /* B0 -> B1 */
	tmp2 |= (reg2 & 0x01) << 0; /* B7 -> B0 */
a0002fb8:	00621025 	or	v0,v1,v0
	ecc_code[1] = ~tmp1;
#else
	ecc_code[0] = ~tmp1;
	ecc_code[1] = ~tmp2;
#endif
	ecc_code[2] = ((~reg1) << 2) | 0x03;
a0002fbc:	00073880 	sll	a3,a3,0x2
	/* Calculate final ECC code */
#ifdef CONFIG_MTD_NAND_ECC_SMC
	ecc_code[0] = ~tmp2;
	ecc_code[1] = ~tmp1;
#else
	ecc_code[0] = ~tmp1;
a0002fc0:	00041827 	nor	v1,zero,a0
	ecc_code[1] = ~tmp2;
a0002fc4:	00021027 	nor	v0,zero,v0
#endif
	ecc_code[2] = ((~reg1) << 2) | 0x03;
a0002fc8:	34e70003 	ori	a3,a3,0x3
#ifdef CONFIG_MTD_NAND_ECC_SMC
	ecc_code[0] = ~tmp2;
	ecc_code[1] = ~tmp1;
#else
	ecc_code[0] = ~tmp1;
	ecc_code[1] = ~tmp2;
a0002fcc:	a0c20001 	sb	v0,1(a2)
	/* Calculate final ECC code */
#ifdef CONFIG_MTD_NAND_ECC_SMC
	ecc_code[0] = ~tmp2;
	ecc_code[1] = ~tmp1;
#else
	ecc_code[0] = ~tmp1;
a0002fd0:	a0c30000 	sb	v1,0(a2)
	ecc_code[1] = ~tmp2;
#endif
	ecc_code[2] = ((~reg1) << 2) | 0x03;
a0002fd4:	a0c70002 	sb	a3,2(a2)

	return 0;
}
a0002fd8:	03e00008 	jr	ra
a0002fdc:	00001021 	move	v0,zero

a0002fe0 <nand_correct_data>:
#ifdef CONFIG_MTD_NAND_ECC_SMC
	s0 = calc_ecc[0] ^ read_ecc[0];
	s1 = calc_ecc[1] ^ read_ecc[1];
	s2 = calc_ecc[2] ^ read_ecc[2];
#else
	s1 = calc_ecc[0] ^ read_ecc[0];
a0002fe0:	90c20000 	lbu	v0,0(a2)
a0002fe4:	90e30000 	lbu	v1,0(a3)
	s0 = calc_ecc[1] ^ read_ecc[1];
a0002fe8:	90e40001 	lbu	a0,1(a3)
#ifdef CONFIG_MTD_NAND_ECC_SMC
	s0 = calc_ecc[0] ^ read_ecc[0];
	s1 = calc_ecc[1] ^ read_ecc[1];
	s2 = calc_ecc[2] ^ read_ecc[2];
#else
	s1 = calc_ecc[0] ^ read_ecc[0];
a0002fec:	00621826 	xor	v1,v1,v0
	s0 = calc_ecc[1] ^ read_ecc[1];
a0002ff0:	90c20001 	lbu	v0,1(a2)
	s2 = calc_ecc[2] ^ read_ecc[2];
a0002ff4:	90e70002 	lbu	a3,2(a3)
	s0 = calc_ecc[0] ^ read_ecc[0];
	s1 = calc_ecc[1] ^ read_ecc[1];
	s2 = calc_ecc[2] ^ read_ecc[2];
#else
	s1 = calc_ecc[0] ^ read_ecc[0];
	s0 = calc_ecc[1] ^ read_ecc[1];
a0002ff8:	00822026 	xor	a0,a0,v0
	s2 = calc_ecc[2] ^ read_ecc[2];
a0002ffc:	90c20002 	lbu	v0,2(a2)
#ifdef CONFIG_MTD_NAND_ECC_SMC
	s0 = calc_ecc[0] ^ read_ecc[0];
	s1 = calc_ecc[1] ^ read_ecc[1];
	s2 = calc_ecc[2] ^ read_ecc[2];
#else
	s1 = calc_ecc[0] ^ read_ecc[0];
a0003000:	306300ff 	andi	v1,v1,0xff
	s0 = calc_ecc[1] ^ read_ecc[1];
	s2 = calc_ecc[2] ^ read_ecc[2];
a0003004:	00e23026 	xor	a2,a3,v0
	s0 = calc_ecc[0] ^ read_ecc[0];
	s1 = calc_ecc[1] ^ read_ecc[1];
	s2 = calc_ecc[2] ^ read_ecc[2];
#else
	s1 = calc_ecc[0] ^ read_ecc[0];
	s0 = calc_ecc[1] ^ read_ecc[1];
a0003008:	308400ff 	andi	a0,a0,0xff
	s2 = calc_ecc[2] ^ read_ecc[2];
a000300c:	30c600ff 	andi	a2,a2,0xff
#endif
	if ((s0 | s1 | s2) == 0)
a0003010:	00833825 	or	a3,a0,v1
a0003014:	00c73825 	or	a3,a2,a3
a0003018:	10e00043 	beqz	a3,a0003128 <nand_correct_data+0x148>
a000301c:	00001021 	move	v0,zero
		return 0;

	/* Check for a single bit error */
	if( ((s0 ^ (s0 >> 1)) & 0x55) == 0x55 &&
a0003020:	00041042 	srl	v0,a0,0x1
a0003024:	00443826 	xor	a3,v0,a0
a0003028:	30e70055 	andi	a3,a3,0x55
a000302c:	24080055 	li	t0,85
a0003030:	54e80030 	bnel	a3,t0,a00030f4 <nand_correct_data+0x114>
a0003034:	00031a00 	sll	v1,v1,0x8
	    ((s1 ^ (s1 >> 1)) & 0x55) == 0x55 &&
a0003038:	00034042 	srl	t0,v1,0x1
a000303c:	00684026 	xor	t0,v1,t0
#endif
	if ((s0 | s1 | s2) == 0)
		return 0;

	/* Check for a single bit error */
	if( ((s0 ^ (s0 >> 1)) & 0x55) == 0x55 &&
a0003040:	31080055 	andi	t0,t0,0x55
a0003044:	5507002b 	bnel	t0,a3,a00030f4 <nand_correct_data+0x114>
a0003048:	00031a00 	sll	v1,v1,0x8
	    ((s1 ^ (s1 >> 1)) & 0x55) == 0x55 &&
	    ((s2 ^ (s2 >> 1)) & 0x54) == 0x54) {
a000304c:	00064042 	srl	t0,a2,0x1
a0003050:	00c84026 	xor	t0,a2,t0
	if ((s0 | s1 | s2) == 0)
		return 0;

	/* Check for a single bit error */
	if( ((s0 ^ (s0 >> 1)) & 0x55) == 0x55 &&
	    ((s1 ^ (s1 >> 1)) & 0x55) == 0x55 &&
a0003054:	31080054 	andi	t0,t0,0x54
a0003058:	24070054 	li	a3,84
a000305c:	55070025 	bnel	t0,a3,a00030f4 <nand_correct_data+0x114>
a0003060:	00031a00 	sll	v1,v1,0x8
		byteoffs |= (s1 << 2) & 0x20;
		byteoffs |= (s1 << 3) & 0x10;

		byteoffs |= (s0 >> 4) & 0x08;
		byteoffs |= (s0 >> 3) & 0x04;
		byteoffs |= (s0 >> 2) & 0x02;
a0003064:	00044082 	srl	t0,a0,0x2
		byteoffs |= (s1 << 1) & 0x40;
		byteoffs |= (s1 << 2) & 0x20;
		byteoffs |= (s1 << 3) & 0x10;

		byteoffs |= (s0 >> 4) & 0x08;
		byteoffs |= (s0 >> 3) & 0x04;
a0003068:	000438c2 	srl	a3,a0,0x3
		byteoffs |= (s0 >> 2) & 0x02;
a000306c:	31080002 	andi	t0,t0,0x2
		byteoffs |= (s1 << 1) & 0x40;
		byteoffs |= (s1 << 2) & 0x20;
		byteoffs |= (s1 << 3) & 0x10;

		byteoffs |= (s0 >> 4) & 0x08;
		byteoffs |= (s0 >> 3) & 0x04;
a0003070:	30e70004 	andi	a3,a3,0x4
	    ((s2 ^ (s2 >> 1)) & 0x54) == 0x54) {

		uint32_t byteoffs, bitnum;

		byteoffs = (s1 << 0) & 0x80;
		byteoffs |= (s1 << 1) & 0x40;
a0003074:	01073825 	or	a3,t0,a3
		byteoffs |= (s1 << 2) & 0x20;
		byteoffs |= (s1 << 3) & 0x10;

		byteoffs |= (s0 >> 4) & 0x08;
a0003078:	00042102 	srl	a0,a0,0x4
	    ((s1 ^ (s1 >> 1)) & 0x55) == 0x55 &&
	    ((s2 ^ (s2 >> 1)) & 0x54) == 0x54) {

		uint32_t byteoffs, bitnum;

		byteoffs = (s1 << 0) & 0x80;
a000307c:	30680080 	andi	t0,v1,0x80
		byteoffs |= (s1 << 1) & 0x40;
		byteoffs |= (s1 << 2) & 0x20;
a0003080:	00e83825 	or	a3,a3,t0
		byteoffs |= (s1 << 3) & 0x10;

		byteoffs |= (s0 >> 4) & 0x08;
a0003084:	30840008 	andi	a0,a0,0x8
		uint32_t byteoffs, bitnum;

		byteoffs = (s1 << 0) & 0x80;
		byteoffs |= (s1 << 1) & 0x40;
		byteoffs |= (s1 << 2) & 0x20;
		byteoffs |= (s1 << 3) & 0x10;
a0003088:	00e42025 	or	a0,a3,a0

		byteoffs |= (s0 >> 4) & 0x08;
		byteoffs |= (s0 >> 3) & 0x04;
		byteoffs |= (s0 >> 2) & 0x02;
		byteoffs |= (s0 >> 1) & 0x01;
a000308c:	30420001 	andi	v0,v0,0x1
		byteoffs = (s1 << 0) & 0x80;
		byteoffs |= (s1 << 1) & 0x40;
		byteoffs |= (s1 << 2) & 0x20;
		byteoffs |= (s1 << 3) & 0x10;

		byteoffs |= (s0 >> 4) & 0x08;
a0003090:	00822025 	or	a0,a0,v0

		uint32_t byteoffs, bitnum;

		byteoffs = (s1 << 0) & 0x80;
		byteoffs |= (s1 << 1) & 0x40;
		byteoffs |= (s1 << 2) & 0x20;
a0003094:	00033880 	sll	a3,v1,0x2
	    ((s2 ^ (s2 >> 1)) & 0x54) == 0x54) {

		uint32_t byteoffs, bitnum;

		byteoffs = (s1 << 0) & 0x80;
		byteoffs |= (s1 << 1) & 0x40;
a0003098:	00031040 	sll	v0,v1,0x1
		byteoffs |= (s1 << 2) & 0x20;
a000309c:	30e70020 	andi	a3,a3,0x20
	    ((s2 ^ (s2 >> 1)) & 0x54) == 0x54) {

		uint32_t byteoffs, bitnum;

		byteoffs = (s1 << 0) & 0x80;
		byteoffs |= (s1 << 1) & 0x40;
a00030a0:	30420040 	andi	v0,v0,0x40
		byteoffs |= (s1 << 2) & 0x20;
		byteoffs |= (s1 << 3) & 0x10;
a00030a4:	000318c0 	sll	v1,v1,0x3

		byteoffs |= (s0 >> 4) & 0x08;
		byteoffs |= (s0 >> 3) & 0x04;
a00030a8:	00e21025 	or	v0,a3,v0
		uint32_t byteoffs, bitnum;

		byteoffs = (s1 << 0) & 0x80;
		byteoffs |= (s1 << 1) & 0x40;
		byteoffs |= (s1 << 2) & 0x20;
		byteoffs |= (s1 << 3) & 0x10;
a00030ac:	30630010 	andi	v1,v1,0x10

		byteoffs |= (s0 >> 4) & 0x08;
		byteoffs |= (s0 >> 3) & 0x04;
		byteoffs |= (s0 >> 2) & 0x02;
a00030b0:	00431025 	or	v0,v0,v1
		byteoffs |= (s0 >> 1) & 0x01;
a00030b4:	00441025 	or	v0,v0,a0

		bitnum = (s2 >> 5) & 0x04;
		bitnum |= (s2 >> 4) & 0x02;
		bitnum |= (s2 >> 3) & 0x01;

		dat[byteoffs] ^= (1 << bitnum);
a00030b8:	00a22821 	addu	a1,a1,v0
		byteoffs |= (s0 >> 3) & 0x04;
		byteoffs |= (s0 >> 2) & 0x02;
		byteoffs |= (s0 >> 1) & 0x01;

		bitnum = (s2 >> 5) & 0x04;
		bitnum |= (s2 >> 4) & 0x02;
a00030bc:	00061902 	srl	v1,a2,0x4
		byteoffs |= (s0 >> 4) & 0x08;
		byteoffs |= (s0 >> 3) & 0x04;
		byteoffs |= (s0 >> 2) & 0x02;
		byteoffs |= (s0 >> 1) & 0x01;

		bitnum = (s2 >> 5) & 0x04;
a00030c0:	00061142 	srl	v0,a2,0x5
		bitnum |= (s2 >> 4) & 0x02;
a00030c4:	30630002 	andi	v1,v1,0x2
		byteoffs |= (s0 >> 4) & 0x08;
		byteoffs |= (s0 >> 3) & 0x04;
		byteoffs |= (s0 >> 2) & 0x02;
		byteoffs |= (s0 >> 1) & 0x01;

		bitnum = (s2 >> 5) & 0x04;
a00030c8:	30420004 	andi	v0,v0,0x4
		bitnum |= (s2 >> 4) & 0x02;
a00030cc:	00621025 	or	v0,v1,v0
		bitnum |= (s2 >> 3) & 0x01;
a00030d0:	7cc600c0 	ext	a2,a2,0x3,0x1

		dat[byteoffs] ^= (1 << bitnum);
a00030d4:	00463025 	or	a2,v0,a2
a00030d8:	24020001 	li	v0,1
a00030dc:	00c23004 	sllv	a2,v0,a2
a00030e0:	90a20000 	lbu	v0,0(a1)
a00030e4:	00c23026 	xor	a2,a2,v0

		return 1;
a00030e8:	24020001 	li	v0,1
a00030ec:	03e00008 	jr	ra
a00030f0:	a0a60000 	sb	a2,0(a1)
	}

	if(countbits(s0 | ((uint32_t)s1 << 8) | ((uint32_t)s2 <<16)) == 1)
a00030f4:	00063400 	sll	a2,a2,0x10
a00030f8:	00661825 	or	v1,v1,a2
a00030fc:	00642025 	or	a0,v1,a0
#endif
//#endif /* CONFIG_NAND_SPL */

static inline int countbits(uint32_t byte)
{
	int res = 0;
a0003100:	00001821 	move	v1,zero

	for (;byte; byte >>= 1)
a0003104:	10800005 	beqz	a0,a000311c <nand_correct_data+0x13c>
a0003108:	24020001 	li	v0,1
		res += byte & 0x01;
a000310c:	30820001 	andi	v0,a0,0x1
a0003110:	00431821 	addu	v1,v0,v1

static inline int countbits(uint32_t byte)
{
	int res = 0;

	for (;byte; byte >>= 1)
a0003114:	1000fffb 	b	a0003104 <nand_correct_data+0x124>
a0003118:	00042042 	srl	a0,a0,0x1

		return 1;
	}

	if(countbits(s0 | ((uint32_t)s1 << 8) | ((uint32_t)s2 <<16)) == 1)
		return 1;
a000311c:	38630001 	xori	v1,v1,0x1
a0003120:	2404ffb3 	li	a0,-77
a0003124:	0083100b 	movn	v0,a0,v1

	return -EBADMSG;
}
a0003128:	03e00008 	jr	ra
a000312c:	00000000 	nop

a0003130 <init_cp0>:
/**************************************************************************************
**************************************************************************************/
LEAF(init_cp0)

        // Initialize Status
	li	v1, 0x00400404		// (M_StatusBEV=1 | M_StatusIM | M_StatusERL) - Compatibility Int Mode
a0003130:	3c030040 	lui	v1,0x40
a0003134:	34630404 	ori	v1,v1,0x404
	mtc0	v1, CP0_STATUS		// write C0_Status $12
a0003138:	40836000 	mtc0	v1,c0_status

	// Initialize Watch registers if implemented.
	mfc0	v0, CP0_CONFIG,1		// read C0_Config1
a000313c:	40028001 	mfc0	v0,c0_config1
	ext     v1, v0, 3, 1		// extract bit 3 WR (Watch registers implemented)
a0003140:	7c4300c0 	ext	v1,v0,0x3,0x1
	beq 	v1, zero, done_wr
a0003144:	1060001f 	beqz	v1,a00031c4 <done_wr>
	li    	v1, 0x7				// (M_WatchHiI | M_WatchHiR | M_WatchHiW)
a0003148:	24030007 	li	v1,7

	// Clear Watch Status bits and disable watch exceptions
	mtc0	v1, CP0_WATCHHI		// write C0_WatchHi0
a000314c:	40839800 	mtc0	v1,c0_watchhi
	mfc0	v0, CP0_WATCHHI		// read C0_WatchHi0
a0003150:	40029800 	mfc0	v0,c0_watchhi
	beq 	v0, zero, done_wr
a0003154:	1040001b 	beqz	v0,a00031c4 <done_wr>
	mtc0	zero, CP0_WATCHLO	// write C0_WatchLo0
a0003158:	40809000 	mtc0	zero,c0_watchlo

	mtc0	v1, CP0_WATCHHI, 1	// write C0_WatchHi1
a000315c:	40839801 	mtc0	v1,c0_watchhi,1
	mfc0	v0, CP0_WATCHHI, 1	// read C0_WatchHi1
a0003160:	40029801 	mfc0	v0,c0_watchhi,1
	beq 	v0, zero, done_wr
a0003164:	10400017 	beqz	v0,a00031c4 <done_wr>
	mtc0	zero, CP0_WATCHLO, 1	// write C0_WatchLo1
a0003168:	40809001 	mtc0	zero,c0_watchlo,1

	mtc0	v1, CP0_WATCHHI, 2	// write C0_WatchHi2
a000316c:	40839802 	mtc0	v1,c0_watchhi,2
	mfc0	v0, CP0_WATCHHI, 2	// read C0_WatchHi2
a0003170:	40029802 	mfc0	v0,c0_watchhi,2
	beq 	v0, zero, done_wr
a0003174:	10400013 	beqz	v0,a00031c4 <done_wr>
	mtc0	zero, CP0_WATCHLO, 2	// write C0_WatchLo2
a0003178:	40809002 	mtc0	zero,c0_watchlo,2

	mtc0	v1, CP0_WATCHHI, 3	// write C0_WatchHi3
a000317c:	40839803 	mtc0	v1,c0_watchhi,3
	mfc0	v0, CP0_WATCHHI, 3	// read C0_WatchHi3
a0003180:	40029803 	mfc0	v0,c0_watchhi,3
	beq 	v0, zero, done_wr
a0003184:	1040000f 	beqz	v0,a00031c4 <done_wr>
	mtc0	zero, CP0_WATCHLO, 3	// write C0_WatchLo3
a0003188:	40809003 	mtc0	zero,c0_watchlo,3

	mtc0	v1, CP0_WATCHHI, 4	// write C0_WatchHi4
a000318c:	40839804 	mtc0	v1,c0_watchhi,4
	mfc0	v0, CP0_WATCHHI, 4	// read C0_WatchHi4
a0003190:	40029804 	mfc0	v0,c0_watchhi,4
	beq 	v0, zero, done_wr
a0003194:	1040000b 	beqz	v0,a00031c4 <done_wr>
	mtc0	zero, CP0_WATCHLO, 4	// write C0_WatchLo4
a0003198:	40809004 	mtc0	zero,c0_watchlo,4

	mtc0	v1, CP0_WATCHHI, 5	// write C0_WatchHi5
a000319c:	40839805 	mtc0	v1,c0_watchhi,5
	mfc0	v0, CP0_WATCHHI, 5	// read C0_WatchHi5
a00031a0:	40029805 	mfc0	v0,c0_watchhi,5
	beq 	v0, zero, done_wr
a00031a4:	10400007 	beqz	v0,a00031c4 <done_wr>
	mtc0	zero, CP0_WATCHLO, 5	// write C0_WatchLo5
a00031a8:	40809005 	mtc0	zero,c0_watchlo,5

	mtc0	v1, CP0_WATCHHI, 6	// write C0_WatchHi6
a00031ac:	40839806 	mtc0	v1,c0_watchhi,6
	mfc0	v0, CP0_WATCHHI, 6	// read C0_WatchHi6
a00031b0:	40029806 	mfc0	v0,c0_watchhi,6
	beq 	v0, zero, done_wr
a00031b4:	10400003 	beqz	v0,a00031c4 <done_wr>
	mtc0	zero, CP0_WATCHLO, 6	// write C0_WatchLo6
a00031b8:	40809006 	mtc0	zero,c0_watchlo,6

	mtc0	v1, CP0_WATCHHI, 7	// write C0_WatchHi7
a00031bc:	40839807 	mtc0	v1,c0_watchhi,7
	mtc0	zero, CP0_WATCHLO, 7	// write C0_WatchLo7
a00031c0:	40809007 	mtc0	zero,c0_watchlo,7

a00031c4 <done_wr>:

done_wr:

	// Clear WP bit to avoid watch exception upon user code entry, IV, and software interrupts.
	mtc0	zero, CP0_CAUSE		// write C0_Cause: Init AFTER init of CP0 WatchHi/Lo registers.
a00031c4:	40806800 	mtc0	zero,c0_cause

	// Clear timer interrupt. (Count was cleared at the reset vector to allow timing boot.)
	mtc0	zero, CP0_COMPARE	// write C0_Compare
a00031c8:	40805800 	mtc0	zero,c0_compare

    jr      ra
a00031cc:	03e00008 	jr	ra
	nop
a00031d0:	00000000 	nop

a00031d4 <init_gic>:
END(init_cp0)

LEAF(init_gic)

    beqz    r11_is_cps, done_gic				// Skip if non-CPS.
a00031d4:	1160001a 	beqz	t3,a0003240 <done_gic>
    nop
a00031d8:	00000000 	nop

    bnez    r23_cpu_num, done_gic				// Only core0 vpe0 inits shared portion.
a00031dc:	16e00018 	bnez	s7,a0003240 <done_gic>
    nop
a00031e0:	00000000 	nop

//Only cpu0 = core0+vpe0 to reach here
/*set GIC base address and enable it*/

    li      a1, GCR_CONFIG_ADDR + GCR_GIC_BASE  	// Locate and enable GIC
a00031e4:	3c05b230 	lui	a1,0xb230
a00031e8:	34a50080 	ori	a1,a1,0x80
    li      a0, GIC_P_BASE_ADDR | 1 			// Physical address + enable bit
a00031ec:	3c041232 	lui	a0,0x1232
a00031f0:	34840001 	ori	a0,a0,0x1
    sw      a0, 0(a1)				        // a0 = 0x12320001
a00031f4:	aca40000 	sw	a0,0(a1)


/*initialize IPI for VPE1/core0, VPE0/core1, VPE1/core1*/
    li      a1, GIC_BASE_ADDR		// GIC_BASE_ADDR = 0xb2320000
a00031f8:	3c05b232 	lui	a1,0xb232
    // IPI interrupts 20, 21 85  
    li      a0, 0x00300000
a00031fc:	3c040030 	lui	a0,0x30
    sw      a0, GIC_SH_RMASK31_0(a1)	// (disable     56..59)
a0003200:	aca40300 	sw	a0,768(a1)
    sw      a0, GIC_SH_POL31_0(a1)		// (high/rise   56..59)
a0003204:	aca40100 	sw	a0,256(a1)
    sw      a0, GIC_SH_TRIG31_0(a1)	// (edge        56..59)
a0003208:	aca40180 	sw	a0,384(a1)
    sw      a0, GIC_SH_SMASK31_00(a1)	// (enable      56..59)
a000320c:	aca40380 	sw	a0,896(a1)

    li      a0, 0x00200000
a0003210:	3c040020 	lui	a0,0x20
    sw      a0, GIC_SH_RMASK95_64(a1)	// (disable     56..59)
a0003214:	aca40308 	sw	a0,776(a1)
    sw      a0, GIC_SH_POL95_64(a1)		// (high/rise   56..59)
a0003218:	aca40108 	sw	a0,264(a1)
    sw      a0, GIC_SH_TRIG95_64(a1)	// (edge        56..59)
a000321c:	aca40188 	sw	a0,392(a1)
    sw      a0, GIC_SH_SMASK95_64(a1)	// (enable      56..59)
a0003220:	aca40388 	sw	a0,904(a1)
     
 
    li      a0, 1              // set bit 0 for CORE0 or for MT vpe0
a0003224:	24040001 	li	a0,1
    sll     a0, a0, 1          // set bit 1 for CORE1 or for MT vpe1
a0003228:	00042040 	sll	a0,a0,0x1
    sw      a0, GIC_SH_MAP0_VPE31_0 + (GIC_SH_MAP_SPACER * 20) (a1)
a000322c:	aca42280 	sw	a0,8832(a1)
    sll     a0, a0, 1          // set bit 2 for CORE2 or for MT vpe2
a0003230:	00042040 	sll	a0,a0,0x1
    sw      a0, GIC_SH_MAP0_VPE31_0 + (GIC_SH_MAP_SPACER * 21) (a1)
a0003234:	aca422a0 	sw	a0,8864(a1)
    sll     a0, a0, 1          // set bit 3 for CORE3 or for MT vpe3
a0003238:	00042040 	sll	a0,a0,0x1
    sw      a0, GIC_SH_MAP0_VPE31_0 + (GIC_SH_MAP_SPACER * 85) (a1)
a000323c:	aca42aa0 	sw	a0,10912(a1)

a0003240 <done_gic>:

done_gic:
    jr      ra
a0003240:	03e00008 	jr	ra
    nop
a0003244:	00000000 	nop

a0003248 <ipi_reconfig>:

END(init_gic)

/* Reconfigure IPI interrupts when VPE re-enters IBL after FW exits */
LEAF(ipi_reconfig)
    beqz    r11_is_cps, ipi_done		/* Skip if non-CPS */
a0003248:	1160002e 	beqz	t3,a0003304 <ipi_done>
    nop
a000324c:	00000000 	nop

    beqz    r9_vpe_num, ipi_done		/* If VPE0, return */
a0003250:	1120002c 	beqz	t1,a0003304 <ipi_done>
    nop
a0003254:	00000000 	nop

	li		a0,	GCR_CONFIG_ADDR + GCR_GIC_BASE
a0003258:	3c04b230 	lui	a0,0xb230
a000325c:	34840080 	ori	a0,a0,0x80
    li      a1, GIC_P_BASE_ADDR | 1 	/* Physical address + enable bit */
a0003260:	3c051232 	lui	a1,0x1232
a0003264:	34a50001 	ori	a1,a1,0x1
    sw      a1, 0(a0)
a0003268:	ac850000 	sw	a1,0(a0)

    li      a0, GIC_BASE_ADDR
a000326c:	3c04b232 	lui	a0,0xb232

	li		t0, 1
a0003270:	24080001 	li	t0,1
	bne		r23_cpu_num, t0, vpe2			/* Check if VPE1 */
a0003274:	16e8000c 	bne	s7,t0,a00032a8 <vpe2>
	nop
a0003278:	00000000 	nop

	li		a1,	0x00100000				/* IPI 20 */
a000327c:	3c050010 	lui	a1,0x10
	lw		a2,	(GIC_SH_MASK31_00)(a0)	/* Load MASK reg val */
a0003280:	8c860400 	lw	a2,1024(a0)
	and		a3, a2, a1 					/* Check bit enabled */ 
a0003284:	00c53824 	and	a3,a2,a1
	bnez	a3, ipi_done				/* If enabled, we are done */
a0003288:	14e0001e 	bnez	a3,a0003304 <ipi_done>
	nop		
a000328c:	00000000 	nop
	
    sw      a1, GIC_SH_RMASK31_0(a0)	/* disable */
a0003290:	ac850300 	sw	a1,768(a0)
    sw      a1, GIC_SH_SMASK31_00(a0)	/* enable */
a0003294:	ac850380 	sw	a1,896(a0)
	
    li      a1, 2              /* set bit 1 for CORE1 or for MT vpe1 */
a0003298:	24050002 	li	a1,2
    sw      a1, GIC_SH_MAP0_VPE31_0 + (GIC_SH_MAP_SPACER * 20) (a0)
a000329c:	ac852280 	sw	a1,8832(a0)
	b		ipi_done
a00032a0:	10000018 	b	a0003304 <ipi_done>
	nop
a00032a4:	00000000 	nop

a00032a8 <vpe2>:

vpe2:
	li		t0, 2
a00032a8:	24080002 	li	t0,2
	bne		r23_cpu_num, t0, vpe3			/* check if VPE2 */
a00032ac:	16e8000c 	bne	s7,t0,a00032e0 <vpe3>
	nop
a00032b0:	00000000 	nop

	li		a1, 0x00200000				/* IPI 21 */
a00032b4:	3c050020 	lui	a1,0x20
	lw		a2,	(GIC_SH_MASK31_00)(a0)	/* Load MASK reg */
a00032b8:	8c860400 	lw	a2,1024(a0)
	and     a3, a2, a1					/* Check bit enabled */
a00032bc:	00c53824 	and	a3,a2,a1
	bnez	a3, ipi_done				/* If enabled, we are done */
a00032c0:	14e00010 	bnez	a3,a0003304 <ipi_done>
	nop
a00032c4:	00000000 	nop
	
	sw      a1, GIC_SH_RMASK31_0(a0)	/* disable */
a00032c8:	ac850300 	sw	a1,768(a0)
    sw      a1, GIC_SH_SMASK31_00(a0)	/* enable */
a00032cc:	ac850380 	sw	a1,896(a0)
	
    li      a1, 4              			/* set bit 2 for CORE2 or for MT vpe2 */
a00032d0:	24050004 	li	a1,4
    sw      a1, GIC_SH_MAP0_VPE31_0 + (GIC_SH_MAP_SPACER * 21) (a0)
a00032d4:	ac8522a0 	sw	a1,8864(a0)
	b		ipi_done
a00032d8:	1000000a 	b	a0003304 <ipi_done>
	nop
a00032dc:	00000000 	nop

a00032e0 <vpe3>:

vpe3:
    li      a1, 0x00200000				/* IPI 85 */
a00032e0:	3c050020 	lui	a1,0x20
	lw		a2, (GIC_SH_MASK95_64)(a0)	/* Load MASK reg */
a00032e4:	8c860408 	lw	a2,1032(a0)
	and		a3, a2, a1					/* Check bit enabled */
a00032e8:	00c53824 	and	a3,a2,a1
	bnez	a3, ipi_done				/* If enabled, we are done */
a00032ec:	14e00005 	bnez	a3,a0003304 <ipi_done>
	nop
a00032f0:	00000000 	nop
		
    sw      a1, GIC_SH_RMASK95_64(a0)	/* disable */
a00032f4:	ac850308 	sw	a1,776(a0)
    sw      a1, GIC_SH_SMASK95_64(a0)	/* enable */
a00032f8:	ac850388 	sw	a1,904(a0)
    
	li      a1, 8              			/* set bit 3 for CORE3 or for MT vpe0 */
a00032fc:	24050008 	li	a1,8
    sw      a1, GIC_SH_MAP0_VPE31_0 + (GIC_SH_MAP_SPACER * 85)(a0)
a0003300:	ac852aa0 	sw	a1,10912(a0)

a0003304 <ipi_done>:

ipi_done:
	jr	ra
a0003304:	03e00008 	jr	ra
	nop	
a0003308:	00000000 	nop

a000330c <init_cm>:
**************************************************************************************/
LEAF(init_cm)


	// Allow each core access to the CM registers (they should only access their local registers.)
	li	    a0, 2							// Start building mask for cores in this cps.
a000330c:	24040002 	li	a0,2
    sll     a0, a0, r19_more_cores
a0003310:	02642004 	sllv	a0,a0,s3
    addiu   a0, -1							// Complete mask.
a0003314:	2484ffff 	addiu	a0,a0,-1
	sw	    a0, GCR_ACCESS(r22_gcr_addr)	// GCR_ACCESS
a0003318:	aec40020 	sw	a0,32(s6)

    // Check to see if this CPS implements an IOCU.
    lw      a0, GCR_CONFIG(r22_gcr_addr)	// Load GCR_CONFIG
a000331c:	8ec40000 	lw	a0,0(s6)
    ext	    a0, a0, NUMIOCU, NUMIOCU_S		// Extract NUMIOCU.
a0003320:	7c841a00 	ext	a0,a0,0x8,0x4
    beqz    a0, done_cm_init
a0003324:	10800012 	beqz	a0,a0003370 <done_cm_init>
    lui	    a0, 0xffff
a0003328:	3c04ffff 	lui	a0,0xffff

	// Disable the CM regions if there is an IOCU.
	sw	    a0, GCR_REG0_BASE(r22_gcr_addr)	// GCR_REG0_BASE
a000332c:	aec40090 	sw	a0,144(s6)
	sw	    a0, GCR_REG0_MASK(r22_gcr_addr)	// GCR_REG0_MASK
a0003330:	aec40098 	sw	a0,152(s6)
	sw	    a0, GCR_REG1_BASE(r22_gcr_addr)	// GCR_REG1_BASE
a0003334:	aec400a0 	sw	a0,160(s6)
	sw	    a0, GCR_REG1_MASK(r22_gcr_addr)	// GCR_REG1_MASK
a0003338:	aec400a8 	sw	a0,168(s6)
	sw	    a0, GCR_REG2_BASE(r22_gcr_addr)	// GCR_REG2_BASE
a000333c:	aec400b0 	sw	a0,176(s6)
	sw	    a0, GCR_REG2_MASK(r22_gcr_addr)	// GCR_REG2_MASK
a0003340:	aec400b8 	sw	a0,184(s6)
	sw	    a0, GCR_REG3_BASE(r22_gcr_addr)	// GCR_REG3_BASE
a0003344:	aec400c0 	sw	a0,192(s6)
	sw	    a0, GCR_REG3_MASK(r22_gcr_addr)	// GCR_REG3_MASK
a0003348:	aec400c8 	sw	a0,200(s6)
	sw	    a0, GCR_REG4_BASE(r22_gcr_addr)	// GCR_REG4_BASE
a000334c:	aec40190 	sw	a0,400(s6)
	sw	    a0, GCR_REG4_MASK(r22_gcr_addr)	// GCR_REG4_MASK
a0003350:	aec40198 	sw	a0,408(s6)
	sw	    a0, GCR_REG5_BASE(r22_gcr_addr)	// GCR_REG5_BASE
a0003354:	aec401a0 	sw	a0,416(s6)
	sw	    a0, GCR_REG5_MASK(r22_gcr_addr)	// GCR_REG5_MASK
a0003358:	aec401a8 	sw	a0,424(s6)

	// program CM CUSTOM
	li       a0, CUS_P_BASE_ADDR | 1
a000335c:	3c04123f 	lui	a0,0x123f
a0003360:	34840001 	ori	a0,a0,0x1
	sw       a0, 0x60(r22_gcr_addr)			// GCR Custom Base Register
a0003364:	aec40060 	sw	a0,96(s6)

    li       a0, 3
a0003368:	24040003 	li	a0,3
    sw       a0, 0x10(r22_gcr_addr)			// GCR Custom Base Register for UMT access to DMA3
a000336c:	aec40010 	sw	a0,16(s6)

a0003370 <done_cm_init>:

done_cm_init:
	jr      ra
a0003370:	03e00008 	jr	ra
	nop
a0003374:	00000000 	nop

a0003378 <init_cpc>:
END(init_cm)

/**************************************************************************************
**************************************************************************************/
LEAF(init_cpc)
    li      a0, CPC_P_BASE_ADDR				
a0003378:	3c041231 	lui	a0,0x1231
a000337c:	34840001 	ori	a0,a0,0x1
    sw      a0, GCR_CPC_BASE(r22_gcr_addr)		
a0003380:	aec40088 	sw	a0,136(s6)
    li      r30_cpc_addr, CPC_BASE_ADDR		
a0003384:	3c1eb231 	lui	s8,0xb231
    jr      ra
a0003388:	03e00008 	jr	ra
    nop
a000338c:	00000000 	nop

a0003390 <release_mp>:
    // CPS_CORE_OTHER_CONTROL_BLOCK = 0x4000
    // CPC_CMDO_REG = 0x000

powerup_next_core:
    // Send PwrUp command to next core causing execution at their reset exception vector.
    li      a0, 1
a0003390:	24040001 	li	a0,1
    sll     a0, 16
a0003394:	00042400 	sll	a0,a0,0x10
    sw      a0, (CPS_CORE_LOCAL_CONTROL_BLOCK | CPC_OTHERL_REG)(r30_cpc_addr)
a0003398:	afc42010 	sw	a0,8208(s8)
    li      a0, PWR_UP							// "PwrUp" power domain command.
a000339c:	24040003 	li	a0,3
    sw      a0, (CPS_CORE_OTHER_CONTROL_BLOCK | CPC_CMDO_REG)(r30_cpc_addr)
a00033a0:	afc44000 	sw	a0,16384(s8)
1:
    jr      ra
a00033a4:	03e00008 	jr	ra
    nop
a00033a8:	00000000 	nop

a00033ac <join_domain>:
	// GCR_CL_OTHER = 0x018

	// Next command, 0x0f for 1004K, 0x03 for GRX500(2 cores) and 0x33 for GRX500(2x cores + 2x iocu)


	li	    a0, 0x33					   // Set Coherent domain enable for all cores
a00033ac:	24040033 	li	a0,51
	sw	    a0, (CORE_LOCAL_CONTROL_BLOCK | GCR_CL_COHERENCE)(r22_gcr_addr)	// GCR_CL_COHERENCE
a00033b0:	aec42008 	sw	a0,8200(s6)
	ehb
a00033b4:	000000c0 	ehb

	// Cores other than core 0 can relinquish write access to CM regs here.

    move    a3, zero
a00033b8:	00003821 	move	a3,zero
	li	 	t0, CORE_ON
a00033bc:	24080002 	li	t0,2

a00033c0 <next_coherent_core>:

next_coherent_core:
    sll     a0, a3, 16
a00033c0:	00072400 	sll	a0,a3,0x10
    sw      a0, (CORE_LOCAL_CONTROL_BLOCK | GCR_CL_OTHER)(r22_gcr_addr) 	// GCR_CL_OTHER[CoreNum]
a00033c4:	aec42018 	sw	a0,8216(s6)

a00033c8 <busy_wait_coherent_core>:

busy_wait_coherent_core:
    lw      a0, (CORE_OTHER_CONTROL_BLOCK | GCR_CO_COHERENCE)(r22_gcr_addr) // GCR_CO_COHERENCE
a00033c8:	8ec44008 	lw	a0,16392(s6)
    beqz    a0, busy_wait_coherent_core   									// Busy wait on cores joining.
a00033cc:	1080fffe 	beqz	a0,a00033c8 <busy_wait_coherent_core>
    nop
a00033d0:	00000000 	nop

//  bne     a3, r19_more_cores, next_coherent_core
    addiu   a3, 1
a00033d4:	24e70001 	addiu	a3,a3,1

    bne     a3, t0, next_coherent_core
a00033d8:	14e8fff9 	bne	a3,t0,a00033c0 <next_coherent_core>
	nop
a00033dc:	00000000 	nop

a00033e0 <done_join_domain>:

done_join_domain:
	jr      ra
a00033e0:	03e00008 	jr	ra
	nop
a00033e4:	00000000 	nop

a00033e8 <set_gpr_boot_values>:
#define C0_TCHALT $2, 4
#define C0_TCBIND $2, 2

LEAF(set_gpr_boot_values)

    li      r1_all_ones, 0xffffffff             // Simplify code and improve clarity
a00033e8:	2401ffff 	li	at,-1
    
    mfc0    k1, CP0_PRID             
a00033ec:	401b7800 	mfc0	k1,c0_prid
    ext     k1, k1, 8, 16						// Company ID & Processor ID
a00033f0:	7f7b7a00 	ext	k1,k1,0x8,0x10
    li	    k0, 0x0190							// 4KEc
a00033f4:	241a0190 	li	k0,400
    beq     k0, k1, is_not_interAptiv
a00033f8:	135b0011 	beq	k0,k1,a0003440 <is_not_interAptiv>
    li 	    r23_cpu_num, 8						// Assign 8=CPUNum for 4KEc
a00033fc:	24170008 	li	s7,8
    
    mfc0    a0, CP0_EBASE                		// Read CP0 EBase
a0003400:	40047801 	mfc0	a0,c0_ebase
    li      r11_is_cps, 1
a0003404:	240b0001 	li	t3,1
    ext	    r23_cpu_num, a0, 0, 4     			// Extract CPUNum
a0003408:	7c971800 	ext	s7,a0,0x0,0x4
    li      r10_has_mt_ase, 1
a000340c:	240a0001 	li	t2,1

    // Every vpe will set up the following to simplify resource initialization.
    mfc0    a0, C0_TCBIND						// Read CP0 TCBind
a0003410:	40041002 	mfc0	a0,c0_tcbind
    ext	    r9_vpe_num, a0,  0, 4				// Extract CurVPE
a0003414:	7c891800 	ext	t1,a0,0x0,0x4
    ext	    r18_tc_num, a0, 21, 8				// Extract CurTC
a0003418:	7c923d40 	ext	s2,a0,0x15,0x8
    mfc0    a0, C0_MVPCONF0						// C0_MVPConf0
a000341c:	40040002 	mfc0	a0,c0_mvpconf0
    ext	    r21_more_tcs, a0, 0, 8   			// Extract PTC
a0003420:	7c953800 	ext	s5,a0,0x0,0x8
    ext	    r20_more_vpes, a0, 10, 4			// Extract VPE
a0003424:	7c941a80 	ext	s4,a0,0xa,0x4

    li      r22_gcr_addr, GCR_CONFIG_ADDR
a0003428:	3c16b230 	lui	s6,0xb230
    lw      r8_core_num, (CORE_LOCAL_CONTROL_BLOCK + GCR_CL_ID) (r22_gcr_addr) // Load GCR_CL_ID
a000342c:	8ec82028 	lw	t0,8232(s6)
    lw      a0, GCR_CONFIG(r22_gcr_addr)                // Load GCR_CONFIG
a0003430:	8ec40000 	lw	a0,0(s6)
    ext     r19_more_cores, a0, PCORES, PCORES_S        // Extract PCORES (r19_more_cores=1 from core 0)
a0003434:	7c933800 	ext	s3,a0,0x0,0x8
    
    b       done_init_gpr
a0003438:	10000008 	b	a000345c <done_init_gpr>
    nop
a000343c:	00000000 	nop

a0003440 <is_not_interAptiv>:

is_not_interAptiv: 	// This processor is not a InterAptiv Core. Set up defaults for 4Kc.
    li      r11_is_cps, 0
a0003440:	240b0000 	li	t3,0
    li      r8_core_num, 0
a0003444:	24080000 	li	t0,0
    li      r9_vpe_num, 0
a0003448:	24090000 	li	t1,0
    li      r18_tc_num, 0
a000344c:	24120000 	li	s2,0
    li      r20_more_vpes, 0
a0003450:	24140000 	li	s4,0
    li      r21_more_tcs, 0
a0003454:	24150000 	li	s5,0
    li      r19_more_cores, 0
a0003458:	24130000 	li	s3,0

a000345c <done_init_gpr>:
        
	
done_init_gpr:
    jr     ra
a000345c:	03e00008 	jr	ra
    nop
a0003460:	00000000 	nop

a0003464 <init_legacy>:
END(set_gpr_boot_values)

LEAF(init_legacy)
	mfc0	v0, CP0_CONFIG5
a0003464:	40028005 	mfc0	v0,$16,5
	li		v1, 0x2fffffff
a0003468:	3c032fff 	lui	v1,0x2fff
a000346c:	3463ffff 	ori	v1,v1,0xffff
	and		v0, v0, v1
a0003470:	00431024 	and	v0,v0,v1
	mtc0	v0, CP0_CONFIG5
a0003474:	40828005 	mtc0	v0,$16,5
	jr		ra
a0003478:	03e00008 	jr	ra
	nop
a000347c:	00000000 	nop

a0003480 <sys_init_icache>:
LEAF(sys_init_icache)

	// Can be skipped if using magic simulation cache flush

	// Determine how big the I$ is
	mfc0	v0, CP0_CONFIG, 1				
a0003480:	40028001 	mfc0	v0,c0_config1

	// I$ Line Size
	ext	    v1, v0, MIPS_CONF1_IL_SHIFT, 3		// extract IL (16B/4KEc, 32B/InterAptiv)
a0003484:	7c4314c0 	ext	v1,v0,0x13,0x3

	// Skip ahead if No I$
	beq	    v1, zero, done_icache
a0003488:	10600011 	beqz	v1,a00034d0 <done_icache>
	nop
a000348c:	00000000 	nop

	li	    a2, 2
a0003490:	24060002 	li	a2,2
	sllv    v1, a2, v1					// Now have true I$ line size in bytes (v1=32B/set) 
a0003494:	00661804 	sllv	v1,a2,v1

	ext	    a0, v0,  MIPS_CONF1_IS_SHIFT , 3		// extract IS
a0003498:	7c441580 	ext	a0,v0,0x16,0x3
	li	    a2, 64
a000349c:	24060040 	li	a2,64
	sllv    a0, a2, a0					// I$ Sets per way (512sets/way/4KEc, 256sets/way/InterAptiv)
a00034a0:	00862004 	sllv	a0,a2,a0

	// Config1IA == I$ Assoc - 1
	ext	    a1, v0, MIPS_CONF1_IA_SHIFT, 3		// extract IA
a00034a4:	7c451400 	ext	a1,v0,0x10,0x3
	add	    a1, 1					// a1 = 4 ways	
a00034a8:	20a50001 	addi	a1,a1,1

	mul	    a0, a0, a1					// Total number of sets (2048sets/4KEc, 1024sets/InterAptiv)
a00034ac:	70852002 	mul	a0,a0,a1
	lui	    a2, 0x8000					// 0x9fc0 Get a KSeg0 address for cacheops
a00034b0:	3c068000 	lui	a2,0x8000

	// Clear TagLo/TagHi registers
	mtc0    zero, CP0_TAGLO				// write C0_ITagLo $28,0
a00034b4:	4080e000 	mtc0	zero,c0_taglo

	// For 4Kec
	mtc0    zero, CP0_TAGHI
a00034b8:	4080e800 	mtc0	zero,c0_taghi

	move    a3, a0						
a00034bc:	00803821 	move	a3,a0

a00034c0 <next_icache_tag>:

next_icache_tag:
	cache   0x8, 0(a2)					// ICIndexStTag
a00034c0:	bcc80000 	cache	0x8,0(a2)
	add	    a3, -1						// Decrement set counter
a00034c4:	20e7ffff 	addi	a3,a3,-1
	bne     a3, zero, next_icache_tag
a00034c8:	14e0fffd 	bnez	a3,a00034c0 <next_icache_tag>
	add     a2, v1						// Get next line address
a00034cc:	00c33020 	add	a2,a2,v1

a00034d0 <done_icache>:

done_icache:

    jr      ra
a00034d0:	03e00008 	jr	ra
    nop
a00034d4:	00000000 	nop

a00034d8 <sys_init_dcache>:
/**************************************************************************************
* init_icache invalidates all Instruction cache entries
**************************************************************************************/
LEAF(sys_init_dcache)

	mfc0	v0, CP0_CONFIG, 1				// read C0_Config1
a00034d8:	40028001 	mfc0	v0,c0_config1

	// Isolate D$ Line Size
	ext	    v1, v0,  MIPS_CONF1_DL_SHIFT, 3		// extract DL
a00034dc:	7c431280 	ext	v1,v0,0xa,0x3

	// Skip ahead if No D$
	beq	    v1, zero, done_dcache
a00034e0:	10600013 	beqz	v1,a0003530 <done_dcache>
	nop
a00034e4:	00000000 	nop

	li	    a2, 2
a00034e8:	24060002 	li	a2,2
	sllv	v1, a2, v1					// Now have true D$ line size in bytes (16B/set/4KEc, 32B/set/InterAptiv)
a00034ec:	00661804 	sllv	v1,a2,v1

	ext	    a0, v0, MIPS_CONF1_DS_SHIFT, 3		// extract DS
a00034f0:	7c441340 	ext	a0,v0,0xd,0x3
	li	    a2, 64
a00034f4:	24060040 	li	a2,64
	sllv	a0, a2, a0					// D$ Sets per way (512sets/way/4KEc, 256sets/way/InterAptiv)
a00034f8:	00862004 	sllv	a0,a2,a0

	ext	    a1, v0,  MIPS_CONF1_DA_SHIFT, 3		// extract DA
a00034fc:	7c4511c0 	ext	a1,v0,0x7,0x3
	add	    a1, 1						// a1 = 4 ways
a0003500:	20a50001 	addi	a1,a1,1

	mul	    a0, a0, a1					// Get total number of sets (2048sets/4KEc, 1024sets/InterAptiv)
a0003504:	70852002 	mul	a0,a0,a1

	// Clear TagLo/TagHi registers
	// Clear TagLo/TagHi registers
	mtc0	zero, CP0_TAGLO				// write C0_TagLo 
a0003508:	4080e000 	mtc0	zero,c0_taglo

	// For 4Kec
	mtc0    zero, CP0_TAGHI
a000350c:	4080e800 	mtc0	zero,c0_taghi
	
	mtc0	zero, CP0_TAGLO, 2			// write C0_DTagLo
a0003510:	4080e002 	mtc0	zero,c0_taglo1
	mtc0	zero, CP0_TAGHI, 2			// write C0_DTagHi
a0003514:	4080e802 	mtc0	zero,c0_taghi1
	
//DCIndexStTag	
	lui     a2, 0x8000		    		// 9fc0 Get a KSeg0 address for cacheops
a0003518:	3c068000 	lui	a2,0x8000
	move	a3, a0						
a000351c:	00803821 	move	a3,a0
1:
	// Index Store Tag Cache Op
	// Will invalidate the tag entry, clear the lock bit, and clear the LRF bit

        cache	    0x9, 0(a2)					// DCIndexStTag=0x9
a0003520:	bcc90000 	cache	0x9,0(a2)
	add	    a3, -1			    		// Decrement set counter
a0003524:	20e7ffff 	addi	a3,a3,-1

	bne	    a3, zero, 1b
a0003528:	14e0fffd 	bnez	a3,a0003520 <sys_init_dcache+0x48>
	add	    a2, v1		    			// Get next line address
a000352c:	00c33020 	add	a2,a2,v1

a0003530 <done_dcache>:
	
done_dcache:
    jr      ra
a0003530:	03e00008 	jr	ra
    nop
a0003534:	00000000 	nop

a0003538 <init_dcache_lock>:
/**************************************************************************************
* fetch and lock 16KB dcache lines 
**************************************************************************************/
LEAF(init_dcache_lock)

	mfc0	v0, CP0_CONFIG, 1				// read C0_Config1
a0003538:	40028001 	mfc0	v0,c0_config1

	// Isolate D$ Line Size
	ext	    v1, v0,  MIPS_CONF1_DL_SHIFT, 3		// extract DL
a000353c:	7c431280 	ext	v1,v0,0xa,0x3

	// Skip ahead if No D$
	beq	    v1, zero, done_dcache
a0003540:	1060fffb 	beqz	v1,a0003530 <done_dcache>
	nop
a0003544:	00000000 	nop

	li	    a2, 2
a0003548:	24060002 	li	a2,2
	sllv	v1, a2, v1					// Now have true D$ line size in bytes (16B/4KEc, 32B/InterAptiv)
a000354c:	00661804 	sllv	v1,a2,v1

	ext	    a0, v0, MIPS_CONF1_DS_SHIFT, 3		// extract DS
a0003550:	7c441340 	ext	a0,v0,0xd,0x3
	li	    a2, 64
a0003554:	24060040 	li	a2,64
	sllv	a0, a2, a0					// D$ Sets per way (512sets/way/4KEc, 256sets/way/InterAptiv)
a0003558:	00862004 	sllv	a0,a2,a0

	ext	    a1, v0, MIPS_CONF1_DA_SHIFT, 3		// extract DA
a000355c:	7c4511c0 	ext	a1,v0,0x7,0x3
	add	    a1, 1						// (4ways/4KEc, 8ways/InterAptiv
a0003560:	20a50001 	addi	a1,a1,1

	mul	    a0, a0, a1					// Get total number of sets (2048sets/4KEc, 1024sets/InterAptiv)
a0003564:	70852002 	mul	a0,a0,a1

	
//DCAddrFetchLock for first 8KBytes	
	lui	    a2, 0x9fc0		    		// 9fc0 Get a KSeg0 address for cacheops
a0003568:	3c069fc0 	lui	a2,0x9fc0
	move	a3, a0						
a000356c:	00803821 	move	a3,a0
	
	li		a0, 2
a0003570:	24040002 	li	a0,2
	srlv	a3, a3, a0					// a3/=4, 8KByte 
a0003574:	00873806 	srlv	a3,a3,a0
	
1:
	// Index Store Tag Cache Op
	// Will invalidate the tag entry, clear the lock bit, and clear the LRF bit

        cache	0x1d, 0(a2)					// DCAddrFetchLock=0x1d
a0003578:	bcdd0000 	cache	0x1d,0(a2)
	add	    a3, -1			    		// Decrement set counter
a000357c:	20e7ffff 	addi	a3,a3,-1

	bne	    a3, zero, 1b
a0003580:	14e0fffd 	bnez	a3,a0003578 <init_dcache_lock+0x40>
	add	    a2, v1		    			// Get next line address
a0003584:	00c33020 	add	a2,a2,v1

a0003588 <done_dcache_lock>:

done_dcache_lock:
    jr      ra
a0003588:	03e00008 	jr	ra
    nop
a000358c:	00000000 	nop

a0003590 <disable_L23>:
END(init_dcache_lock)

/**************************************************************************************
**************************************************************************************/
LEAF(disable_L23)
    beqz    r11_is_cps, done_disable_L23	# no cps skips
a0003590:	11600006 	beqz	t3,a00035ac <done_disable_L23>
    nop
a0003594:	00000000 	nop

	bnez    r8_core_num, done_disable_L23	# Only done from core 0.
a0003598:	15000004 	bnez	t0,a00035ac <done_disable_L23>
    // to disable it or initialize it if it can't be disabled.
    // Disable the L2 cache using CCA override by writing a 0x50 to
    // the GCR Base register. 0x50 enables the CCA override bit and sets
    // the CCA to uncached.

	lw	    a0, 0x0008(r22_gcr_addr)  	// Read GCR_BASE
a000359c:	8ec40008 	lw	a0,8(s6)
    li      a3, 0x50                  	// Enable CCA and set to uncached
a00035a0:	24070050 	li	a3,80
    ins     a0, a3, 0, 8    			// Insert bits
a00035a4:	7ce43804 	ins	a0,a3,0x0,0x8
    sw      a0, 0x0008(r22_gcr_addr)  	// Write GCR_BASE
a00035a8:	aec40008 	sw	a0,8(s6)

a00035ac <done_disable_L23>:

done_disable_L23:
    jr      ra
a00035ac:	03e00008 	jr	ra
    nop
a00035b0:	00000000 	nop

a00035b4 <init_L23>:

/**************************************************************************************
* Initialize the L2 and L3 caches
**************************************************************************************/
LEAF(init_L23)
    beqz    r11_is_cps, done_cach_init	// no cps skips
a00035b4:	11600015 	beqz	t3,a000360c <done_cach_init>
    nop
a00035b8:	00000000 	nop

	bnez    r8_core_num, done_cach_init	// Only done from core 0.
a00035bc:	15000013 	bnez	t0,a000360c <done_cach_init>

	// L2 Cache initialization routine
	// Check L2 cache size
	mfc0	v0, CP0_CONFIG, 2				// Read C0_Config2
a00035c0:	40028002 	mfc0	v0,c0_config2
	// Isolate L2$ Line Size
	ext	    v1, v0, 4, 4				// extract L2 line size
a00035c4:	7c431900 	ext	v1,v0,0x4,0x4
	li	    a2, 2
a00035c8:	24060002 	li	a2,2
	sllv	v1, a2, v1					// Now have true L2$ line size in bytes (32B/InterAptiv)
a00035cc:	00661804 	sllv	v1,a2,v1

	// Isolate L2 Sets per Way (cache lines per way)
	ext	    a3, v0, 8, 4				// extrace sets per way encoding
a00035d0:	7c471a00 	ext	a3,v0,0x8,0x4
	li	    a2, 64
a00035d4:	24060040 	li	a2,64
	sllv	a3, a2, a3					// L2$ Sets per way (1024 sets/way)
a00035d8:	00e63804 	sllv	a3,a2,a3

	// Isolate L2 Associativity (number of ways)
	// L2$ Assoc (-1)
	ext	    a1, v0, 0, 4				// extract ways encoding
a00035dc:	7c451800 	ext	a1,v0,0x0,0x4
	add	    a1, 1						// Decode L2 number of ways (8 ways)
a00035e0:	20a50001 	addi	a1,a1,1

	mul	    a3, a3, a1					// Get total number of sets (8196 sets)
a00035e4:	70e53802 	mul	a3,a3,a1
	lui	    a2, 0x8000					// Get a KSeg0 address for cacheops
a00035e8:	3c068000 	lui	a2,0x8000

	// Clear L23TagLo/L23TagHi registers these are used to set the cache tag
	mtc0	zero, CP0_TAGLO, 4
a00035ec:	4080e004 	mtc0	zero,c0_taglo2

a00035f0 <next_L2cache_tag>:
	
	// L2$ Index Store Tag Cache Op
	// Will invalidate the tag entry, clear the lock bit, and clear the LRF bit
next_L2cache_tag:
	cache	0xb, 0(a2)					// Write Tag using index store tag
a00035f0:	bccb0000 	cache	0xb,0(a2)
	add	    a3, -1						// Decrement set counter
a00035f4:	20e7ffff 	addi	a3,a3,-1

	bne	    a3, zero, next_L2cache_tag 	// Done yet?
a00035f8:	14e0fffd 	bnez	a3,a00035f0 <next_L2cache_tag>
	add	    a2, v1						// Get next line address (each tag covers one line)
a00035fc:	00c33020 	add	a2,a2,v1

a0003600 <done_l2cache>:

done_l2cache:
    // disable CCA Override to enable L2 cache
	lw	    a0, 0x0008(r22_gcr_addr)  	// GCR_BASE
a0003600:	8ec40008 	lw	a0,8(s6)
    ins     a0, zero, 0, 8            	// CCA Override disabled
a0003604:	7c043804 	ins	a0,zero,0x0,0x8
    sw      a0, 0x0008(r22_gcr_addr)  	// GCR_BASE
a0003608:	aec40008 	sw	a0,8(s6)

a000360c <done_cach_init>:

done_cach_init:
    jr      ra
a000360c:	03e00008 	jr	ra
    nop
a0003610:	00000000 	nop

a0003614 <change_k0_cca>:
END(init_L23)

LEAF(change_k0_cca)
	// NOTE! This code must be executed in KSEG1 (not KSGE0 uncached)
    // Set CCA for kseg0 to cacheable
	mfc0	v0, CP0_CONFIG				// read C0_Config
a0003614:	40028000 	mfc0	v0,c0_config
	beqz    r11_is_cps, set_kseg0_cca
a0003618:	11600002 	beqz	t3,a0003624 <set_kseg0_cca>
	li	    v1, 3						// CCA for non coherent core
a000361c:	24030003 	li	v1,3
	li	    v1, 5						// CCA for coherent cores
a0003620:	24030005 	li	v1,5

a0003624 <set_kseg0_cca>:

set_kseg0_cca:

    ins	    v0, v1, 0, 3				// insert K0
a0003624:	7c621004 	ins	v0,v1,0x0,0x3
    mtc0	v0, CP0_CONFIG				// write C0_Config
a0003628:	40828000 	mtc0	v0,c0_config
    jr.hb      ra
a000362c:	03e00408 	jr.hb	ra
    nop
a0003630:	00000000 	nop
	...

a0003640 <init_vpe1>:

   // Each vpe will need to set up additional TC bound to it. (No rebinding.)

	// This is executing on TC0 bound to VPE0.  Therefore VPEConf0.MVP is set.
	// Enter config mode
	mfc0	v0, C0_MVPCTL	// read C0_MVPCtl
a0003640:	40020001 	mfc0	v0,c0_mvpcontrol
	or		v0, (1 << 1)		// set VPC
a0003644:	34420002 	ori	v0,v0,0x2
	mtc0	v0, C0_MVPCTL	// write C0_MVPCtl
a0003648:	40820001 	mtc0	v0,c0_mvpcontrol
	ehb
a000364c:	000000c0 	ehb
#define a0_NTCS	a0
#define a2_NVPES	a2
#define a3_TC	a3

	// Get number of a3_TC's and VPE's
	mfc0	v0, C0_MVPCONF0	// read C0_MVPCONF0
a0003650:	40020002 	mfc0	v0,c0_mvpconf0
	ext		a0_NTCS, v0, 0, 8	// extract PTC
a0003654:	7c443800 	ext	a0,v0,0x0,0x8
	ext		a2_NVPES, v0, 10, 4	// extract PVPE
a0003658:	7c461a80 	ext	a2,v0,0xa,0x4

	// Initialise a3_TC's/VPE's
	move	a3_TC, zero
a000365c:	00003821 	move	a3,zero

a0003660 <nexttc>:
nexttc:
	// Select TCn
	mfc0	v0, C0_VPECTL	// read C0_VPECTL
a0003660:	40020801 	mfc0	v0,c0_vpecontrol
	ins		v0, a3_TC, 0, 8		// insert TargTC
a0003664:	7ce23804 	ins	v0,a3,0x0,0x8
	mtc0	v0, C0_VPECTL	// write C0_VPECTL
a0003668:	40820801 	mtc0	v0,c0_vpecontrol
	ehb
a000366c:	000000c0 	ehb

	// Bind a3_TC to next VPE
	beqz	a3_TC, nextvpe	// Don't rebind TC0
a0003670:	10e00035 	beqz	a3,a0003748 <nextvpe>
	nop
a0003674:	00000000 	nop

	// Halt a3_TC being configured
	li		v0, 1			    // set Halt bit
a0003678:	24020001 	li	v0,1
	mttc0	v0, C0_TCHALT	// write C0_TCHALT
a000367c:	41821004 	mttc0	v0,c0_tchalt
	ehb
a0003680:	000000c0 	ehb

	move    v1, a3_TC
a0003684:	00e01821 	move	v1,a3
	# Bind TC to a VPE
	mftc0   v0, C0_TCBIND	// Read C0_TCBind
a0003688:	41021002 	mftc0	v0,c0_tcbind
	ins     v0, v1, 0, 4	// change S_TCBindCurVPE
a000368c:	7c621804 	ins	v0,v1,0x0,0x4
	mttc0   v0, C0_TCBIND	// write C0_TCBind
a0003690:	41821002 	mttc0	v0,c0_tcbind
	// This code checks to see if the a3_TC mumber is
	// less than the VPE number. This ensures
	// in a system with more than 1 VPE and TCs each
	// VPE will have at least one a3_TC bound to it
	// and any TCs left over will be bound to the last a3_TC
	slt		v1, a2_NVPES, a3_TC
a0003694:	00c7182a 	slt	v1,a2,a3
	bnez	v1, 2f			// Bind spare a3_TC's to VPElast
a0003698:	14600005 	bnez	v1,a00036b0 <nexttc+0x50>
	move	v1, a2_NVPES
a000369c:	00c01821 	move	v1,a2

	// Set XTC for active a3_TC's
	mftc0	v0, C0_VPECONF0	// read C0_VPECONF0
a00036a0:	41011002 	mftc0	v0,c0_vpeconf0
	ins		v0, a3_TC, 21, 8 // insert XTC
a00036a4:	7ce2e544 	ins	v0,a3,0x15,0x8
	mttc0	v0, C0_VPECONF0	// write C0_VPECONF0
a00036a8:	41820802 	mttc0	v0,c0_vpeconf0

	move	v1, a3_TC
a00036ac:	00e01821 	move	v1,a3
2:
	// Bind a3_TC to a VPE
	mftc0	v0, C0_TCBIND	// read C0_TCBIND
a00036b0:	41021002 	mftc0	v0,c0_tcbind
	ins		v0, v1, 0, 4	// insert VPE
a00036b4:	7c621804 	ins	v0,v1,0x0,0x4
	mttc0	v0, C0_TCBIND	// write C0_TCBIND
a00036b8:	41821002 	mttc0	v0,c0_tcbind
	// not dynamically allocatable
	// not allocated
	// Kernel mode
	// interrupt exempt
	// ASID 0
	li		v0, (1 << 10)	// set IXMT
a00036bc:	24020400 	li	v0,1024
	mttc0	v0, C0_TCSTATUS	// write C0_TCSTATUS
a00036c0:	41821001 	mttc0	v0,c0_tcstatus

	// Initialize the a3_TC's register file
	li v0, 0xdeadbeef
a00036c4:	3c02dead 	lui	v0,0xdead
a00036c8:	3442beef 	ori	v0,v0,0xbeef
	mttgpr	v0, $1
a00036cc:	41820820 	mttgpr	v0,at
	mttgpr	v0, $2
a00036d0:	41821020 	mttgpr	v0,v0
	mttgpr	v0, $3
a00036d4:	41821820 	mttgpr	v0,v1
	mttgpr	v0, $4
a00036d8:	41822020 	mttgpr	v0,a0
	mttgpr	v0, $5
a00036dc:	41822820 	mttgpr	v0,a1
	mttgpr	v0, $6
a00036e0:	41823020 	mttgpr	v0,a2
	mttgpr	v0, $7
a00036e4:	41823820 	mttgpr	v0,a3
	mttgpr	v0, $8
a00036e8:	41824020 	mttgpr	v0,t0
	mttgpr	v0, $9
a00036ec:	41824820 	mttgpr	v0,t1
	mttgpr	v0, $10
a00036f0:	41825020 	mttgpr	v0,t2
	mttgpr	v0, $11
a00036f4:	41825820 	mttgpr	v0,t3
	mttgpr	v0, $12
a00036f8:	41826020 	mttgpr	v0,t4
	mttgpr	v0, $13
a00036fc:	41826820 	mttgpr	v0,t5
	mttgpr	v0, $14
a0003700:	41827020 	mttgpr	v0,t6
	mttgpr	v0, $15
a0003704:	41827820 	mttgpr	v0,t7
	mttgpr	v0, $16
a0003708:	41828020 	mttgpr	v0,s0
	mttgpr	v0, $17
a000370c:	41828820 	mttgpr	v0,s1
	mttgpr	v0, $18
a0003710:	41829020 	mttgpr	v0,s2
	mttgpr	v0, $19
a0003714:	41829820 	mttgpr	v0,s3
	mttgpr	v0, $20
a0003718:	4182a020 	mttgpr	v0,s4
	mttgpr	v0, $21
a000371c:	4182a820 	mttgpr	v0,s5
	mttgpr	v0, $22
a0003720:	4182b020 	mttgpr	v0,s6
	mttgpr	v0, $23
a0003724:	4182b820 	mttgpr	v0,s7
	mttgpr	v0, $24
a0003728:	4182c020 	mttgpr	v0,t8
	mttgpr	v0, $25
a000372c:	4182c820 	mttgpr	v0,t9
	mttgpr	v0, $26
a0003730:	4182d020 	mttgpr	v0,k0
	mttgpr	v0, $27
a0003734:	4182d820 	mttgpr	v0,k1
	mttgpr	v0, $28
a0003738:	4182e020 	mttgpr	v0,gp
	mttgpr	v0, $29
a000373c:	4182e820 	mttgpr	v0,sp
	mttgpr	v0, $30
a0003740:	4182f020 	mttgpr	v0,s8
	mttgpr	v0, $31
a0003744:	4182f820 	mttgpr	v0,ra

a0003748 <nextvpe>:

nextvpe:
	slt		v1, a2_NVPES, a3_TC
a0003748:	00c7182a 	slt	v1,a2,a3
	bnez	v1, donevpe		// No more VPE's
a000374c:	1460001f 	bnez	v1,a00037cc <donevpe>
	nop
a0003750:	00000000 	nop

	// Disable multi-threading with a3_TC's
	mftc0	v0, C0_VPECTL	// read C0_VPECTL
a0003754:	41011001 	mftc0	v0,c0_vpecontrol
	ins		v0, zero, 15, 1	// clear TE
a0003758:	7c027bc4 	ins	v0,zero,0xf,0x1
	mttc0	v0, C0_VPECTL	// write C0_VPECTL
a000375c:	41820801 	mttc0	v0,c0_vpecontrol

	beqz	a3_TC, 1f
a0003760:	10e0001a 	beqz	a3,a00037cc <donevpe>
	nop
a0003764:	00000000 	nop

	// For VPE1..n
	// Clear VPA and set master VPE
	mftc0	v0, C0_VPECONF0	// read C0_VPECONF0
a0003768:	41011002 	mftc0	v0,c0_vpeconf0
	ins		v0, zero, 0, 1	// insert VPA
a000376c:	7c020004 	ins	v0,zero,0x0,0x1
	or		v0, (1 << 1)	// set MVP
a0003770:	34420002 	ori	v0,v0,0x2
	mttc0	v0, C0_VPECONF0	// write C0_VPECONF0
a0003774:	41820802 	mttc0	v0,c0_vpeconf0

	mfc0	v0, CP0_STATUS	// read CP0_STATUS
a0003778:	40026000 	mfc0	v0,c0_status
	mttc0	v0, CP0_STATUS	// write CP0_Status
a000377c:	41826000 	mttc0	v0,c0_status

	li		v0, 0x12345678
a0003780:	3c021234 	lui	v0,0x1234
a0003784:	34425678 	ori	v0,v0,0x5678
	mttc0	v0, CP0_EPC		// write C0_EPC
a0003788:	41827000 	mttc0	v0,c0_epc

	mttc0	zero, CP0_CAUSE	// write C0_CAUSE
a000378c:	41806800 	mttc0	zero,c0_cause

	mfc0	v0, CP0_CONFIG	// read C0_CONFIG
a0003790:	40028000 	mfc0	v0,c0_config
	mttc0	v0, CP0_CONFIG	// write C0_CONFIG
a0003794:	41828000 	mttc0	v0,c0_config

	mftc0	v0, CP0_EBASE	// read C0_EBASE
a0003798:	410f1001 	mftc0	v0,c0_ebase
	ext		v0, v0, 0, 10	// extract CPUNum
a000379c:	7c424800 	ext	v0,v0,0x0,0xa
	mttgpr	v0, r23_cpu_num
a00037a0:	4182b820 	mttgpr	v0,s7

	// vpe1 of each core can execute cached as it's L1 I$ has already been initialized.
    // and the L2$ has been initialized or "disabled" via CCA override.
	la		a1, __reset_vector
a00037a4:	8f8500c4 	lw	a1,196(gp)
//TRI 1-1-2014
//Temporary comment out until cache issue is fixed	
//	ins     a1, zero, 29, 1 // Convert to cached kseg0 address in case we linked to kseg1.
	mttc0   a1, C0_TCRESTART // write C0_TCRESTART
a00037a8:	41851003 	mttc0	a1,c0_tcrestart

	// Yes.. this is undoing all of the work done above... :)
	mftc0	v0, C0_TCSTATUS	// read C0_TCSTATUS
a00037ac:	41021001 	mftc0	v0,c0_tcstatus
	ins	    v0, zero, 10, 1	// insert IXMT
a00037b0:	7c025284 	ins	v0,zero,0xa,0x1
	ori	    v0, (1 << 13)	// set A
a00037b4:	34422000 	ori	v0,v0,0x2000
	mttc0	v0, C0_TCSTATUS	// write C0_TCSTATUS
a00037b8:	41821001 	mttc0	v0,c0_tcstatus

	mttc0	zero, C0_TCHALT	// write C0_TCHALT
a00037bc:	41801004 	mttc0	zero,c0_tchalt

	mftc0	v0, C0_VPECONF0	// read C0_VPECONF0
a00037c0:	41011002 	mftc0	v0,c0_vpeconf0
	ori	    v0, 1		    // set VPA
a00037c4:	34420001 	ori	v0,v0,0x1
	mttc0	v0, C0_VPECONF0	// write C0_VPECONF0
a00037c8:	41820802 	mttc0	v0,c0_vpeconf0

a00037cc <donevpe>:
1:

donevpe:
	addu	a3_TC, 1
a00037cc:	24e70001 	addiu	a3,a3,1
	sltu	v1, a0_NTCS, a3_TC
a00037d0:	0087182b 	sltu	v1,a0,a3
	beqz	v1, nexttc
a00037d4:	1060ffa2 	beqz	v1,a0003660 <nexttc>
	nop
a00037d8:	00000000 	nop

	// Exit config mode
	mfc0	v0, C0_MVPCTL	// read C0_MVPCtl
a00037dc:	40020001 	mfc0	v0,c0_mvpcontrol
    ori     v0, 1           // set EVP will enable execution by vpe1
a00037e0:	34420001 	ori	v0,v0,0x1
	ins	    v0, zero, 1, 1	// insert VPC
a00037e4:	7c020844 	ins	v0,zero,0x1,0x1
	mtc0	v0, C0_MVPCTL	// write C0_MVPCtl
a00037e8:	40820001 	mtc0	v0,c0_mvpcontrol
	ehb
a00037ec:	000000c0 	ehb

a00037f0 <done_init_vpe1>:
#undef a2_NVPES
#undef a3_TC

done_init_vpe1:

    jr   ra
a00037f0:	03e00008 	jr	ra
    nop
a00037f4:	00000000 	nop
	...

a0003800 <init_exception>:
	.set	noreorder           // Don't allow the assembler to reorder instructions.
	.set	noat                // Don't allow the assembler to use r1(at) for synthetic instr.
/**********************************************************************************************/
LEAF(init_exception)
        /* CAUSE register */
        li      k0, C0_CAUSE_IV_BIT
a0003800:	3c1a0080 	lui	k0,0x80
        mtc0    k0, CP0_CAUSE
a0003804:	409a6800 	mtc0	k0,c0_cause

        li      v0, 0x0
a0003808:	24020000 	li	v0,0

        li      v1, 8
a000380c:	24030008 	li	v1,8
        beq     r23_cpu_num, v0, 1f
a0003810:	12e2000a 	beq	s7,v0,a000383c <init_exception+0x3c>
        nop       
a0003814:	00000000 	nop
 
        beqz    r23_cpu_num, 1f
a0003818:	12e00008 	beqz	s7,a000383c <init_exception+0x3c>
        nop         
a000381c:	00000000 	nop

#ifdef CONFIG_BOOT_FROM_NAND
        li      v0, CONFIG_NAND_SPL_TEXT_BASE
a0003820:	3c02a000 	lui	v0,0xa000
a0003824:	34421000 	ori	v0,v0,0x1000
#else
        li      v0, CONFIG_SFDDR_TEXT_BASE
#endif
        li      v1, (0x3ffff<<12)
a0003828:	3c033fff 	lui	v1,0x3fff
a000382c:	3463f000 	ori	v1,v1,0xf000
        and     v0, v1
a0003830:	00431024 	and	v0,v0,v1
        mtc0    v0, CP0_EBASE
a0003834:	40827801 	mtc0	v0,c0_ebase

        li      v0, 0x00000401     
a0003838:	24020401 	li	v0,1025
1:
        mtc0    v0, CP0_STATUS
a000383c:	40826000 	mtc0	v0,c0_status
        jr     ra
a0003840:	03e00008 	jr	ra
        nop
a0003844:	00000000 	nop
	...

a0003850 <get_cpu_id>:
	:								\
	: "i" (op), "R" (*(unsigned char *)(addr)))

u32 get_cpu_id()
{  
   u32 config = read_c0_prid();
a0003850:	40027800 	mfc0	v0,c0_prid
   return ((config>>8) & 0xff);

}
a0003854:	03e00008 	jr	ra
a0003858:	7c423a00 	ext	v0,v0,0x8,0x8

a000385c <icache_lines>:
   /* I-cache lines
    * Calculated as associativity * sets per way
	*/

   u32 config,associativity,sets;
   config = read_c0_config1();
a000385c:	40038001 	mfc0	v1,c0_config1
   associativity = 1+ ((config & M_Config1IA) >> S_Config1IA);
   sets = (1<<((config & M_Config1IS) >> S_Config1IS)) * 64;
a0003860:	24040040 	li	a0,64
a0003864:	7c621580 	ext	v0,v1,0x16,0x3
    * Calculated as associativity * sets per way
	*/

   u32 config,associativity,sets;
   config = read_c0_config1();
   associativity = 1+ ((config & M_Config1IA) >> S_Config1IA);
a0003868:	7c631400 	ext	v1,v1,0x10,0x3
   sets = (1<<((config & M_Config1IS) >> S_Config1IS)) * 64;
a000386c:	00441004 	sllv	v0,a0,v0
    * Calculated as associativity * sets per way
	*/

   u32 config,associativity,sets;
   config = read_c0_config1();
   associativity = 1+ ((config & M_Config1IA) >> S_Config1IA);
a0003870:	24630001 	addiu	v1,v1,1
   sets = (1<<((config & M_Config1IS) >> S_Config1IS)) * 64;
   return (associativity * sets);
}
a0003874:	03e00008 	jr	ra
a0003878:	70431002 	mul	v0,v0,v1

a000387c <icache_line_size>:

u32 icache_line_size()
{
    u32 config, line_size;
    config=read_c0_config1();
a000387c:	40028001 	mfc0	v0,c0_config1
    line_size= 0x02 <<((config & M_Config1IL) >> (S_Config1IL));
    return line_size;
}
a0003880:	24030002 	li	v1,2

u32 icache_line_size()
{
    u32 config, line_size;
    config=read_c0_config1();
    line_size= 0x02 <<((config & M_Config1IL) >> (S_Config1IL));
a0003884:	7c4214c0 	ext	v0,v0,0x13,0x3
    return line_size;
}
a0003888:	03e00008 	jr	ra
a000388c:	00431004 	sllv	v0,v1,v0

a0003890 <dcache_lines>:
   /* I-cache lines
    * Calculated as associativity * sets per way
	*/

   u32 config,associativity,sets;
   config = read_c0_config1();
a0003890:	40038001 	mfc0	v1,c0_config1
   associativity = 1+ ((config & M_Config1DA) >> S_Config1DA);
   sets = (1<<((config & M_Config1DS) >> S_Config1DS)) * 64;
a0003894:	24040040 	li	a0,64
a0003898:	7c621340 	ext	v0,v1,0xd,0x3
    * Calculated as associativity * sets per way
	*/

   u32 config,associativity,sets;
   config = read_c0_config1();
   associativity = 1+ ((config & M_Config1DA) >> S_Config1DA);
a000389c:	7c6311c0 	ext	v1,v1,0x7,0x3
   sets = (1<<((config & M_Config1DS) >> S_Config1DS)) * 64;
a00038a0:	00441004 	sllv	v0,a0,v0
    * Calculated as associativity * sets per way
	*/

   u32 config,associativity,sets;
   config = read_c0_config1();
   associativity = 1+ ((config & M_Config1DA) >> S_Config1DA);
a00038a4:	24630001 	addiu	v1,v1,1
   sets = (1<<((config & M_Config1DS) >> S_Config1DS)) * 64;
   return (associativity * sets);
}
a00038a8:	03e00008 	jr	ra
a00038ac:	70431002 	mul	v0,v0,v1

a00038b0 <dcache_line_size>:

u32 dcache_line_size()
{
    u32 config, line_size;
    config=read_c0_config1();
a00038b0:	40028001 	mfc0	v0,c0_config1
    line_size= 0x02 <<((config & M_Config1DL) >> (S_Config1DL));
    return line_size;
}
a00038b4:	24030002 	li	v1,2

u32 dcache_line_size()
{
    u32 config, line_size;
    config=read_c0_config1();
    line_size= 0x02 <<((config & M_Config1DL) >> (S_Config1DL));
a00038b8:	7c421280 	ext	v0,v0,0xa,0x3
    return line_size;
}
a00038bc:	03e00008 	jr	ra
a00038c0:	00431004 	sllv	v0,v1,v0

a00038c4 <scache_lines>:
										  
u32 scache_lines() 
{
a00038c4:	3c1c0000 	lui	gp,0x0
a00038c8:	279c207c 	addiu	gp,gp,8316
a00038cc:	0399e021 	addu	gp,gp,t9
a00038d0:	27bdffe0 	addiu	sp,sp,-32
    u32 config, config2, associativity, sets, tmp;
	u32 cpu_id = get_cpu_id();
a00038d4:	8f990070 	lw	t9,112(gp)
    line_size= 0x02 <<((config & M_Config1DL) >> (S_Config1DL));
    return line_size;
}
										  
u32 scache_lines() 
{
a00038d8:	afbc0010 	sw	gp,16(sp)
a00038dc:	afbf001c 	sw	ra,28(sp)
    u32 config, config2, associativity, sets, tmp;
	u32 cpu_id = get_cpu_id();
a00038e0:	0320f809 	jalr	t9

    if (cpu_id == CPU_4KEC)
a00038e4:	00000000 	nop
a00038e8:	24030090 	li	v1,144
a00038ec:	10430012 	beq	v0,v1,a0003938 <scache_lines+0x74>
a00038f0:	00001021 	move	v0,zero
        return 0;
 
	/* check the existance of config2 */
    config = read_c0_config1();
a00038f4:	40038001 	mfc0	v1,c0_config1
    if (!(config & MIPS_CONF_M)) 
a00038f8:	0461000f 	bgez	v1,a0003938 <scache_lines+0x74>
a00038fc:	00001021 	move	v0,zero
        return 0;

    config2 = read_c0_config2();
a0003900:	40038002 	mfc0	v1,c0_config2
    /* check if L2 cache is activated */
    if (!(config2 & (1 << 12)))
a0003904:	30621000 	andi	v0,v1,0x1000
a0003908:	1040000b 	beqz	v0,a0003938 <scache_lines+0x74>
a000390c:	7c641a00 	ext	a0,v1,0x8,0x4
        return 0;

    tmp = (config2 >> 8) & 0x0f;
    if (0 <= tmp && tmp <= 9)
a0003910:	2c85000a 	sltiu	a1,a0,10
a0003914:	10a00008 	beqz	a1,a0003938 <scache_lines+0x74>
a0003918:	00001021 	move	v0,zero
        sets = 64 << tmp;
    else
        return 0;

    tmp = (config2 >> 0) & 0x0f;
a000391c:	3063000f 	andi	v1,v1,0xf
    if (0 <= tmp && tmp <= 7)
a0003920:	2c650008 	sltiu	a1,v1,8
a0003924:	10a00004 	beqz	a1,a0003938 <scache_lines+0x74>
a0003928:	24630001 	addiu	v1,v1,1
    if (!(config2 & (1 << 12)))
        return 0;

    tmp = (config2 >> 8) & 0x0f;
    if (0 <= tmp && tmp <= 9)
        sets = 64 << tmp;
a000392c:	24020040 	li	v0,64
a0003930:	00821004 	sllv	v0,v0,a0
a0003934:	70431002 	mul	v0,v0,v1
    else
        return 0;

     return associativity * sets;
    
}
a0003938:	8fbf001c 	lw	ra,28(sp)
a000393c:	03e00008 	jr	ra
a0003940:	27bd0020 	addiu	sp,sp,32

a0003944 <scache_linesize>:

u32 scache_linesize()
{
a0003944:	3c1c0000 	lui	gp,0x0
a0003948:	279c1ffc 	addiu	gp,gp,8188
a000394c:	0399e021 	addu	gp,gp,t9
a0003950:	27bdffe0 	addiu	sp,sp,-32
    u32 config, config2, linesize;
	u32 cpu_id = get_cpu_id();
a0003954:	8f990070 	lw	t9,112(gp)
     return associativity * sets;
    
}

u32 scache_linesize()
{
a0003958:	afbc0010 	sw	gp,16(sp)
a000395c:	afbf001c 	sw	ra,28(sp)
    u32 config, config2, linesize;
	u32 cpu_id = get_cpu_id();
a0003960:	0320f809 	jalr	t9
	u32 tmp;

    if (cpu_id == CPU_4KEC)
a0003964:	00000000 	nop
a0003968:	24030090 	li	v1,144
a000396c:	5043000d 	beql	v0,v1,a00039a4 <scache_linesize+0x60>
a0003970:	00001021 	move	v0,zero
        return 0;

	/* check the existance of config2 reg */ 
    config = read_c0_config1();
a0003974:	40038001 	mfc0	v1,c0_config1
    if (!(config & MIPS_CONF_M)) 
a0003978:	0461000a 	bgez	v1,a00039a4 <scache_linesize+0x60>
a000397c:	00001021 	move	v0,zero
        return 0;

    config2 = read_c0_config2();
a0003980:	40038002 	mfc0	v1,c0_config2
    tmp = (config2 >> 4) & 0x0f;
a0003984:	7c631900 	ext	v1,v1,0x4,0x4
    if (0 < tmp && tmp <= 7)
a0003988:	2464ffff 	addiu	a0,v1,-1
a000398c:	2c840007 	sltiu	a0,a0,7
a0003990:	10800005 	beqz	a0,a00039a8 <scache_linesize+0x64>
a0003994:	8fbf001c 	lw	ra,28(sp)
        linesize = 2 << tmp;
a0003998:	24020002 	li	v0,2
a000399c:	10000002 	b	a00039a8 <scache_linesize+0x64>
a00039a0:	00621004 	sllv	v0,v0,v1
    else 
        return 0;
    
    return linesize; 
}
a00039a4:	8fbf001c 	lw	ra,28(sp)
a00039a8:	03e00008 	jr	ra
a00039ac:	27bd0020 	addiu	sp,sp,32

a00039b0 <init_icache>:


void init_icache()
{
a00039b0:	3c1c0000 	lui	gp,0x0
a00039b4:	279c1f90 	addiu	gp,gp,8080
a00039b8:	0399e021 	addu	gp,gp,t9
a00039bc:	27bdffd8 	addiu	sp,sp,-40
    u32 lsize = icache_line_size();
a00039c0:	8f9900c8 	lw	t9,200(gp)
    return linesize; 
}


void init_icache()
{
a00039c4:	afbf0024 	sw	ra,36(sp)
a00039c8:	afbc0010 	sw	gp,16(sp)
a00039cc:	afb10020 	sw	s1,32(sp)
    u32 lsize = icache_line_size();
a00039d0:	afb0001c 	sw	s0,28(sp)
a00039d4:	0320f809 	jalr	t9
a00039d8:	3c118000 	lui	s1,0x8000
a00039dc:	8fbc0010 	lw	gp,16(sp)
    u32 start_addr  = KSEG0;
	u32 aend  = KSEG0  + (icache_lines()*lsize);
a00039e0:	8f9900cc 	lw	t9,204(gp)
a00039e4:	0320f809 	jalr	t9
a00039e8:	00408021 	move	s0,v0
a00039ec:	70501802 	mul	v1,v0,s0
a00039f0:	8fbc0010 	lw	gp,16(sp)
	u32 cpu_id = get_cpu_id();    
a00039f4:	8f990070 	lw	t9,112(gp)
a00039f8:	0320f809 	jalr	t9
a00039fc:	00718821 	addu	s1,v1,s1
    u32 addr;
 
	write_c0_taglo(0); 
a0003a00:	4080e000 	mtc0	zero,c0_taglo
	//write_c0_taghi(0); /*not applicable to 4kec, 24kec and 34kc, will add if it is needed in the future*/
    for(addr=start_addr;addr<aend; addr+=lsize){
a0003a04:	3c038000 	lui	v1,0x8000
a0003a08:	0071102b 	sltu	v0,v1,s1
a0003a0c:	10400004 	beqz	v0,a0003a20 <init_icache+0x70>
a0003a10:	8fbf0024 	lw	ra,36(sp)
        cache_op(Index_Store_Tag_I, addr);
a0003a14:	bc680000 	cache	0x8,0(v1)
	u32 cpu_id = get_cpu_id();    
    u32 addr;
 
	write_c0_taglo(0); 
	//write_c0_taghi(0); /*not applicable to 4kec, 24kec and 34kc, will add if it is needed in the future*/
    for(addr=start_addr;addr<aend; addr+=lsize){
a0003a18:	1000fffb 	b	a0003a08 <init_icache+0x58>
a0003a1c:	00701821 	addu	v1,v1,s0
        cache_op(Index_Store_Tag_I, addr);
	}
}
a0003a20:	8fb10020 	lw	s1,32(sp)
a0003a24:	8fb0001c 	lw	s0,28(sp)
a0003a28:	03e00008 	jr	ra
a0003a2c:	27bd0028 	addiu	sp,sp,40

a0003a30 <lock_icache>:


void lock_icache()
{
a0003a30:	3c1c0000 	lui	gp,0x0
a0003a34:	279c1f10 	addiu	gp,gp,7952
a0003a38:	0399e021 	addu	gp,gp,t9
a0003a3c:	27bdffd8 	addiu	sp,sp,-40
    u32 lsize = icache_line_size();
a0003a40:	8f9900c8 	lw	t9,200(gp)
	}
}


void lock_icache()
{
a0003a44:	afbf0024 	sw	ra,36(sp)
a0003a48:	afbc0010 	sw	gp,16(sp)
a0003a4c:	afb10020 	sw	s1,32(sp)
    u32 lsize = icache_line_size();
a0003a50:	afb0001c 	sw	s0,28(sp)
a0003a54:	0320f809 	jalr	t9
a0003a58:	3c119fc0 	lui	s1,0x9fc0
a0003a5c:	8fbc0010 	lw	gp,16(sp)
    u32 start_addr  = 0x9fc00000;
    u32 aend  = 0x9fc00000 + (icache_lines()*lsize);
a0003a60:	8f9900cc 	lw	t9,204(gp)
a0003a64:	0320f809 	jalr	t9
a0003a68:	00408021 	move	s0,v0
a0003a6c:	70501802 	mul	v1,v0,s0
a0003a70:	8fbc0010 	lw	gp,16(sp)
    u32 cpu_id = get_cpu_id();
a0003a74:	8f990070 	lw	t9,112(gp)
a0003a78:	0320f809 	jalr	t9
a0003a7c:	00718821 	addu	s1,v1,s1
    u32 addr;

    for(addr=start_addr;addr<=aend; addr+=lsize){
a0003a80:	3c039fc0 	lui	v1,0x9fc0
a0003a84:	0223102b 	sltu	v0,s1,v1
a0003a88:	14400004 	bnez	v0,a0003a9c <lock_icache+0x6c>
a0003a8c:	8fbf0024 	lw	ra,36(sp)
	       cache_op(ICACHE_ADDR_FETCH_LOCK, addr);
a0003a90:	bc7c0000 	cache	0x1c,0(v1)
    u32 start_addr  = 0x9fc00000;
    u32 aend  = 0x9fc00000 + (icache_lines()*lsize);
    u32 cpu_id = get_cpu_id();
    u32 addr;

    for(addr=start_addr;addr<=aend; addr+=lsize){
a0003a94:	1000fffb 	b	a0003a84 <lock_icache+0x54>
a0003a98:	00701821 	addu	v1,v1,s0
	       cache_op(ICACHE_ADDR_FETCH_LOCK, addr);
      }
}
a0003a9c:	8fb10020 	lw	s1,32(sp)
a0003aa0:	8fb0001c 	lw	s0,28(sp)
a0003aa4:	03e00008 	jr	ra
a0003aa8:	27bd0028 	addiu	sp,sp,40

a0003aac <init_dcache>:

void init_dcache()
{
a0003aac:	3c1c0000 	lui	gp,0x0
a0003ab0:	279c1e94 	addiu	gp,gp,7828
a0003ab4:	0399e021 	addu	gp,gp,t9
a0003ab8:	27bdffd8 	addiu	sp,sp,-40
     u32 lsize = dcache_line_size();
a0003abc:	8f9900d0 	lw	t9,208(gp)
	       cache_op(ICACHE_ADDR_FETCH_LOCK, addr);
      }
}

void init_dcache()
{
a0003ac0:	afbf0024 	sw	ra,36(sp)
a0003ac4:	afbc0010 	sw	gp,16(sp)
a0003ac8:	afb10020 	sw	s1,32(sp)
     u32 lsize = dcache_line_size();
a0003acc:	afb0001c 	sw	s0,28(sp)
a0003ad0:	0320f809 	jalr	t9
a0003ad4:	3c119fc0 	lui	s1,0x9fc0
a0003ad8:	8fbc0010 	lw	gp,16(sp)
	 u32 start_addr  = 0x9fc00000;
	 u32 aend  = 0x9fc00000 + (dcache_lines()*lsize);
a0003adc:	8f9900d4 	lw	t9,212(gp)
a0003ae0:	0320f809 	jalr	t9
a0003ae4:	00408021 	move	s0,v0
a0003ae8:	70501802 	mul	v1,v0,s0
a0003aec:	8fbc0010 	lw	gp,16(sp)
	 u32 cpu_id = get_cpu_id();
a0003af0:	8f990070 	lw	t9,112(gp)
a0003af4:	0320f809 	jalr	t9
a0003af8:	00718821 	addu	s1,v1,s1
	 u32 addr;

     write_c0_dtaglo(0);
a0003afc:	4080e002 	mtc0	zero,c0_taglo1
    //write_c0_taghi(0); /*not applicable to 4kec, 24kec and 34kc, will add if it is needed in the future*/
    for(addr=start_addr;addr<aend; addr+=lsize){
a0003b00:	3c039fc0 	lui	v1,0x9fc0
a0003b04:	0071102b 	sltu	v0,v1,s1
a0003b08:	10400004 	beqz	v0,a0003b1c <init_dcache+0x70>
a0003b0c:	8fbf0024 	lw	ra,36(sp)
        cache_op(Index_Store_Tag_D, addr);
a0003b10:	bc690000 	cache	0x9,0(v1)
	 u32 cpu_id = get_cpu_id();
	 u32 addr;

     write_c0_dtaglo(0);
    //write_c0_taghi(0); /*not applicable to 4kec, 24kec and 34kc, will add if it is needed in the future*/
    for(addr=start_addr;addr<aend; addr+=lsize){
a0003b14:	1000fffb 	b	a0003b04 <init_dcache+0x58>
a0003b18:	00701821 	addu	v1,v1,s0
        cache_op(Index_Store_Tag_D, addr);
     }
}
a0003b1c:	8fb10020 	lw	s1,32(sp)
a0003b20:	8fb0001c 	lw	s0,28(sp)
a0003b24:	03e00008 	jr	ra
a0003b28:	27bd0028 	addiu	sp,sp,40

a0003b2c <lock_dcache>:

void lock_dcache()
{
a0003b2c:	3c1c0000 	lui	gp,0x0
a0003b30:	279c1e14 	addiu	gp,gp,7700
a0003b34:	0399e021 	addu	gp,gp,t9
a0003b38:	27bdffd8 	addiu	sp,sp,-40
    u32 lsize = dcache_line_size();
a0003b3c:	8f9900d0 	lw	t9,208(gp)
        cache_op(Index_Store_Tag_D, addr);
     }
}

void lock_dcache()
{
a0003b40:	afbf0024 	sw	ra,36(sp)
a0003b44:	afbc0010 	sw	gp,16(sp)
a0003b48:	afb10020 	sw	s1,32(sp)
    u32 lsize = dcache_line_size();
a0003b4c:	afb0001c 	sw	s0,28(sp)
a0003b50:	0320f809 	jalr	t9
a0003b54:	3c119fc0 	lui	s1,0x9fc0
a0003b58:	8fbc0010 	lw	gp,16(sp)
    u32 start_addr  = 0x9fc00000;
    u32 aend  = 0x9fc00000 + (dcache_lines()*lsize);
a0003b5c:	8f9900d4 	lw	t9,212(gp)
a0003b60:	0320f809 	jalr	t9
a0003b64:	00408021 	move	s0,v0
a0003b68:	70501802 	mul	v1,v0,s0
a0003b6c:	8fbc0010 	lw	gp,16(sp)
    u32 cpu_id = get_cpu_id();
a0003b70:	8f990070 	lw	t9,112(gp)
a0003b74:	0320f809 	jalr	t9
a0003b78:	00718821 	addu	s1,v1,s1
    u32 addr;

    for(addr=start_addr;addr<=aend; addr+=lsize){
a0003b7c:	3c039fc0 	lui	v1,0x9fc0
a0003b80:	0223102b 	sltu	v0,s1,v1
a0003b84:	14400004 	bnez	v0,a0003b98 <lock_dcache+0x6c>
a0003b88:	8fbf0024 	lw	ra,36(sp)
    	cache_op(DCACHE_ADDR_FETCH_LOCK, addr);
a0003b8c:	bc7d0000 	cache	0x1d,0(v1)
    u32 start_addr  = 0x9fc00000;
    u32 aend  = 0x9fc00000 + (dcache_lines()*lsize);
    u32 cpu_id = get_cpu_id();
    u32 addr;

    for(addr=start_addr;addr<=aend; addr+=lsize){
a0003b90:	1000fffb 	b	a0003b80 <lock_dcache+0x54>
a0003b94:	00701821 	addu	v1,v1,s0
    	cache_op(DCACHE_ADDR_FETCH_LOCK, addr);
	}
}
a0003b98:	8fb10020 	lw	s1,32(sp)
a0003b9c:	8fb0001c 	lw	s0,28(sp)
a0003ba0:	03e00008 	jr	ra
a0003ba4:	27bd0028 	addiu	sp,sp,40

a0003ba8 <init_scache>:
								 
void init_scache()
{
a0003ba8:	3c1c0000 	lui	gp,0x0
a0003bac:	279c1d98 	addiu	gp,gp,7576
a0003bb0:	0399e021 	addu	gp,gp,t9
a0003bb4:	27bdffd8 	addiu	sp,sp,-40
	u32 cpu_id = get_cpu_id();    
a0003bb8:	8f990070 	lw	t9,112(gp)
    	cache_op(DCACHE_ADDR_FETCH_LOCK, addr);
	}
}
								 
void init_scache()
{
a0003bbc:	afbf0024 	sw	ra,36(sp)
a0003bc0:	afbc0010 	sw	gp,16(sp)
a0003bc4:	afb10020 	sw	s1,32(sp)
	u32 cpu_id = get_cpu_id();    
a0003bc8:	0320f809 	jalr	t9
a0003bcc:	afb0001c 	sw	s0,28(sp)
a0003bd0:	8fbc0010 	lw	gp,16(sp)
    u32 lsize = scache_linesize();
a0003bd4:	8f9900d8 	lw	t9,216(gp)
a0003bd8:	0320f809 	jalr	t9
a0003bdc:	00408821 	move	s1,v0
a0003be0:	8fbc0010 	lw	gp,16(sp)
    u32 start_addr = 0x80000000;
    u32 aend = 0x80000000 + (scache_lines() * lsize);
a0003be4:	8f9900dc 	lw	t9,220(gp)
a0003be8:	0320f809 	jalr	t9
a0003bec:	00408021 	move	s0,v0
a0003bf0:	70502002 	mul	a0,v0,s0
a0003bf4:	3c038000 	lui	v1,0x8000
a0003bf8:	00831021 	addu	v0,a0,v1
	u32 addr;

    if (cpu_id == CPU_4KEC)
a0003bfc:	24030090 	li	v1,144
a0003c00:	12230009 	beq	s1,v1,a0003c28 <init_scache+0x80>
a0003c04:	8fbf0024 	lw	ra,36(sp)
        return;

    write_c0_staglo(0);
a0003c08:	4080e004 	mtc0	zero,c0_taglo2
    for (addr = start_addr; addr < aend; addr += lsize)
a0003c0c:	3c038000 	lui	v1,0x8000
a0003c10:	0062202b 	sltu	a0,v1,v0
a0003c14:	10800004 	beqz	a0,a0003c28 <init_scache+0x80>
a0003c18:	8fbf0024 	lw	ra,36(sp)
        cache_op(Index_Store_Tag_SD, addr);
a0003c1c:	bc6b0000 	cache	0xb,0(v1)

    if (cpu_id == CPU_4KEC)
        return;

    write_c0_staglo(0);
    for (addr = start_addr; addr < aend; addr += lsize)
a0003c20:	1000fffb 	b	a0003c10 <init_scache+0x68>
a0003c24:	00701821 	addu	v1,v1,s0
        cache_op(Index_Store_Tag_SD, addr);

}
a0003c28:	8fb10020 	lw	s1,32(sp)
a0003c2c:	8fb0001c 	lw	s0,28(sp)
a0003c30:	03e00008 	jr	ra
a0003c34:	27bd0028 	addiu	sp,sp,40

a0003c38 <flush_cache>:

void flush_cache(ulong start_addr, ulong size)
{
a0003c38:	3c1c0000 	lui	gp,0x0
a0003c3c:	279c1d08 	addiu	gp,gp,7432
a0003c40:	0399e021 	addu	gp,gp,t9
a0003c44:	27bdffd0 	addiu	sp,sp,-48
	unsigned long lsize = dcache_line_size();
a0003c48:	8f9900d0 	lw	t9,208(gp)
        cache_op(Index_Store_Tag_SD, addr);

}

void flush_cache(ulong start_addr, ulong size)
{
a0003c4c:	afbc0010 	sw	gp,16(sp)
a0003c50:	afbf002c 	sw	ra,44(sp)
a0003c54:	afb30028 	sw	s3,40(sp)
a0003c58:	afb20024 	sw	s2,36(sp)
a0003c5c:	afb10020 	sw	s1,32(sp)
a0003c60:	afb0001c 	sw	s0,28(sp)
a0003c64:	00808821 	move	s1,a0
	unsigned long lsize = dcache_line_size();
a0003c68:	0320f809 	jalr	t9
a0003c6c:	00a09821 	move	s3,a1
a0003c70:	8fbc0010 	lw	gp,16(sp)
a0003c74:	00409021 	move	s2,v0
	unsigned long addr = start_addr & ~(lsize - 1);
	unsigned long aend = (start_addr + size - 1) & ~(lsize - 1);
a0003c78:	2673ffff 	addiu	s3,s3,-1
}

void flush_cache(ulong start_addr, ulong size)
{
	unsigned long lsize = dcache_line_size();
	unsigned long addr = start_addr & ~(lsize - 1);
a0003c7c:	00021023 	negu	v0,v0
	unsigned long aend = (start_addr + size - 1) & ~(lsize - 1);
	u32 cpu_id = get_cpu_id();    
a0003c80:	8f990070 	lw	t9,112(gp)
}

void flush_cache(ulong start_addr, ulong size)
{
	unsigned long lsize = dcache_line_size();
	unsigned long addr = start_addr & ~(lsize - 1);
a0003c84:	00518024 	and	s0,v0,s1
	unsigned long aend = (start_addr + size - 1) & ~(lsize - 1);
a0003c88:	02718821 	addu	s1,s3,s1
	u32 cpu_id = get_cpu_id();    
a0003c8c:	0320f809 	jalr	t9
a0003c90:	00518824 	and	s1,v0,s1

	while (1) {
		if (cpu_id == CPU_INTERAPTIV) 
a0003c94:	240300a1 	li	v1,161
a0003c98:	14430002 	bne	v0,v1,a0003ca4 <flush_cache+0x6c>
a0003c9c:	00000000 	nop
			cache_op(Hit_Writeback_Inv_SD, addr);
a0003ca0:	be170000 	cache	0x17,0(s0)
		cache_op(Hit_Writeback_Inv_D, addr);
a0003ca4:	be150000 	cache	0x15,0(s0)
		cache_op(Hit_Invalidate_I, addr);
a0003ca8:	be100000 	cache	0x10,0(s0)
		if (addr == aend)
a0003cac:	1611fffa 	bne	s0,s1,a0003c98 <flush_cache+0x60>
a0003cb0:	02128021 	addu	s0,s0,s2
			break;
		addr += lsize;
	}
}
a0003cb4:	8fbf002c 	lw	ra,44(sp)
a0003cb8:	8fb30028 	lw	s3,40(sp)
a0003cbc:	8fb20024 	lw	s2,36(sp)
a0003cc0:	8fb10020 	lw	s1,32(sp)
a0003cc4:	8fb0001c 	lw	s0,28(sp)
a0003cc8:	03e00008 	jr	ra
a0003ccc:	27bd0030 	addiu	sp,sp,48

a0003cd0 <flush_dcache_range>:

void flush_dcache_range(ulong start_addr, ulong stop)
{
a0003cd0:	3c1c0000 	lui	gp,0x0
a0003cd4:	279c1c70 	addiu	gp,gp,7280
a0003cd8:	0399e021 	addu	gp,gp,t9
a0003cdc:	27bdffd8 	addiu	sp,sp,-40
	unsigned long lsize = dcache_line_size();
a0003ce0:	8f9900d0 	lw	t9,208(gp)
		addr += lsize;
	}
}

void flush_dcache_range(ulong start_addr, ulong stop)
{
a0003ce4:	afb10020 	sw	s1,32(sp)
a0003ce8:	afb0001c 	sw	s0,28(sp)
a0003cec:	afbc0010 	sw	gp,16(sp)
a0003cf0:	afbf0024 	sw	ra,36(sp)
a0003cf4:	00808021 	move	s0,a0
	unsigned long lsize = dcache_line_size();
a0003cf8:	0320f809 	jalr	t9
a0003cfc:	00a08821 	move	s1,a1
	unsigned long addr = start_addr & ~(lsize - 1);
a0003d00:	00021823 	negu	v1,v0
	unsigned long aend = (stop - 1) & ~(lsize - 1);
a0003d04:	2631ffff 	addiu	s1,s1,-1
}

void flush_dcache_range(ulong start_addr, ulong stop)
{
	unsigned long lsize = dcache_line_size();
	unsigned long addr = start_addr & ~(lsize - 1);
a0003d08:	00702024 	and	a0,v1,s0
	unsigned long aend = (stop - 1) & ~(lsize - 1);
a0003d0c:	00711824 	and	v1,v1,s1

	while (1) {
		cache_op(Hit_Writeback_Inv_D, addr);
a0003d10:	bc950000 	cache	0x15,0(a0)
		if (addr == aend)
a0003d14:	1483fffe 	bne	a0,v1,a0003d10 <flush_dcache_range+0x40>
a0003d18:	00822021 	addu	a0,a0,v0
			break;
		addr += lsize;
	}
}
a0003d1c:	8fbf0024 	lw	ra,36(sp)
a0003d20:	8fb10020 	lw	s1,32(sp)
a0003d24:	8fb0001c 	lw	s0,28(sp)
a0003d28:	03e00008 	jr	ra
a0003d2c:	27bd0028 	addiu	sp,sp,40

a0003d30 <flush_scache_range>:

void flush_scache_range(ulong start_addr, ulong stop)
{
a0003d30:	3c1c0000 	lui	gp,0x0
a0003d34:	279c1c10 	addiu	gp,gp,7184
a0003d38:	0399e021 	addu	gp,gp,t9
a0003d3c:	27bdffd8 	addiu	sp,sp,-40
	unsigned long lsize = scache_linesize();
a0003d40:	8f9900d8 	lw	t9,216(gp)
		addr += lsize;
	}
}

void flush_scache_range(ulong start_addr, ulong stop)
{
a0003d44:	afbc0010 	sw	gp,16(sp)
a0003d48:	afbf0024 	sw	ra,36(sp)
a0003d4c:	afb20020 	sw	s2,32(sp)
a0003d50:	afb1001c 	sw	s1,28(sp)
a0003d54:	afb00018 	sw	s0,24(sp)
a0003d58:	00a09021 	move	s2,a1
	unsigned long lsize = scache_linesize();
a0003d5c:	0320f809 	jalr	t9
a0003d60:	00808021 	move	s0,a0
a0003d64:	8fbc0010 	lw	gp,16(sp)
a0003d68:	00408821 	move	s1,v0
	unsigned long addr = start_addr & ~(lsize - 1);
	unsigned long aend = (stop - 1) & ~(lsize - 1);
a0003d6c:	2652ffff 	addiu	s2,s2,-1
	u32 cpu_id = get_cpu_id();    
a0003d70:	8f990070 	lw	t9,112(gp)
}

void flush_scache_range(ulong start_addr, ulong stop)
{
	unsigned long lsize = scache_linesize();
	unsigned long addr = start_addr & ~(lsize - 1);
a0003d74:	00021023 	negu	v0,v0
a0003d78:	00508024 	and	s0,v0,s0
	unsigned long aend = (stop - 1) & ~(lsize - 1);
	u32 cpu_id = get_cpu_id();    
a0003d7c:	0320f809 	jalr	t9
a0003d80:	00529024 	and	s2,v0,s2

	if (cpu_id == CPU_4KEC)
a0003d84:	24030090 	li	v1,144
a0003d88:	10430005 	beq	v0,v1,a0003da0 <flush_scache_range+0x70>
a0003d8c:	8fbf0024 	lw	ra,36(sp)
		return;

	while (1) {
		cache_op(Hit_Writeback_Inv_SD, addr);
a0003d90:	be170000 	cache	0x17,0(s0)
		if (addr == aend)
a0003d94:	1612fffe 	bne	s0,s2,a0003d90 <flush_scache_range+0x60>
a0003d98:	02118021 	addu	s0,s0,s1
			break;
		addr += lsize;
	}
}
a0003d9c:	8fbf0024 	lw	ra,36(sp)
a0003da0:	8fb20020 	lw	s2,32(sp)
a0003da4:	8fb1001c 	lw	s1,28(sp)
a0003da8:	8fb00018 	lw	s0,24(sp)
a0003dac:	03e00008 	jr	ra
a0003db0:	27bd0028 	addiu	sp,sp,40

a0003db4 <invalidate_dcache_range>:

void invalidate_dcache_range(ulong start_addr, ulong stop)
{
a0003db4:	3c1c0000 	lui	gp,0x0
a0003db8:	279c1b8c 	addiu	gp,gp,7052
a0003dbc:	0399e021 	addu	gp,gp,t9
a0003dc0:	27bdffd8 	addiu	sp,sp,-40
	unsigned long lsize = dcache_line_size();
a0003dc4:	8f9900d0 	lw	t9,208(gp)
		addr += lsize;
	}
}

void invalidate_dcache_range(ulong start_addr, ulong stop)
{
a0003dc8:	afb10020 	sw	s1,32(sp)
a0003dcc:	afb0001c 	sw	s0,28(sp)
a0003dd0:	afbc0010 	sw	gp,16(sp)
a0003dd4:	afbf0024 	sw	ra,36(sp)
a0003dd8:	00808021 	move	s0,a0
	unsigned long lsize = dcache_line_size();
a0003ddc:	0320f809 	jalr	t9
a0003de0:	00a08821 	move	s1,a1
	unsigned long addr = start_addr & ~(lsize - 1);
a0003de4:	00021823 	negu	v1,v0
	unsigned long aend = (stop - 1) & ~(lsize - 1);
a0003de8:	2631ffff 	addiu	s1,s1,-1
}

void invalidate_dcache_range(ulong start_addr, ulong stop)
{
	unsigned long lsize = dcache_line_size();
	unsigned long addr = start_addr & ~(lsize - 1);
a0003dec:	00702024 	and	a0,v1,s0
	unsigned long aend = (stop - 1) & ~(lsize - 1);
a0003df0:	00711824 	and	v1,v1,s1

	while (1) {
		cache_op(Hit_Invalidate_D, addr);
a0003df4:	bc910000 	cache	0x11,0(a0)
		if (addr == aend)
a0003df8:	1483fffe 	bne	a0,v1,a0003df4 <invalidate_dcache_range+0x40>
a0003dfc:	00822021 	addu	a0,a0,v0
			break;
		addr += lsize;
	}
}
a0003e00:	8fbf0024 	lw	ra,36(sp)
a0003e04:	8fb10020 	lw	s1,32(sp)
a0003e08:	8fb0001c 	lw	s0,28(sp)
a0003e0c:	03e00008 	jr	ra
a0003e10:	27bd0028 	addiu	sp,sp,40

a0003e14 <invalidate_scache_range>:

void invalidate_scache_range(ulong start_addr, ulong stop)
{
a0003e14:	3c1c0000 	lui	gp,0x0
a0003e18:	279c1b2c 	addiu	gp,gp,6956
a0003e1c:	0399e021 	addu	gp,gp,t9
a0003e20:	27bdffd8 	addiu	sp,sp,-40
	unsigned long lsize = scache_linesize();
a0003e24:	8f9900d8 	lw	t9,216(gp)
		addr += lsize;
	}
}

void invalidate_scache_range(ulong start_addr, ulong stop)
{
a0003e28:	afbc0010 	sw	gp,16(sp)
a0003e2c:	afbf0024 	sw	ra,36(sp)
a0003e30:	afb20020 	sw	s2,32(sp)
a0003e34:	afb1001c 	sw	s1,28(sp)
a0003e38:	afb00018 	sw	s0,24(sp)
a0003e3c:	00a09021 	move	s2,a1
	unsigned long lsize = scache_linesize();
a0003e40:	0320f809 	jalr	t9
a0003e44:	00808021 	move	s0,a0
a0003e48:	8fbc0010 	lw	gp,16(sp)
a0003e4c:	00408821 	move	s1,v0
	unsigned long addr = start_addr & ~(lsize - 1);
	unsigned long aend = (stop - 1) & ~(lsize - 1);
a0003e50:	2652ffff 	addiu	s2,s2,-1
	u32 cpu_id = get_cpu_id();    
a0003e54:	8f990070 	lw	t9,112(gp)
}

void invalidate_scache_range(ulong start_addr, ulong stop)
{
	unsigned long lsize = scache_linesize();
	unsigned long addr = start_addr & ~(lsize - 1);
a0003e58:	00021023 	negu	v0,v0
a0003e5c:	00508024 	and	s0,v0,s0
	unsigned long aend = (stop - 1) & ~(lsize - 1);
	u32 cpu_id = get_cpu_id();    
a0003e60:	0320f809 	jalr	t9
a0003e64:	00529024 	and	s2,v0,s2
	
	if (cpu_id == CPU_4KEC)
a0003e68:	24030090 	li	v1,144
a0003e6c:	10430005 	beq	v0,v1,a0003e84 <invalidate_scache_range+0x70>
a0003e70:	8fbf0024 	lw	ra,36(sp)
		return;

	while (1) {
		cache_op(Hit_Invalidate_SD, addr);
a0003e74:	be130000 	cache	0x13,0(s0)
		if (addr == aend)
a0003e78:	1612fffe 	bne	s0,s2,a0003e74 <invalidate_scache_range+0x60>
a0003e7c:	02118021 	addu	s0,s0,s1
			break;
		addr += lsize;
	}
}
a0003e80:	8fbf0024 	lw	ra,36(sp)
a0003e84:	8fb20020 	lw	s2,32(sp)
a0003e88:	8fb1001c 	lw	s1,28(sp)
a0003e8c:	8fb00018 	lw	s0,24(sp)
a0003e90:	03e00008 	jr	ra
a0003e94:	27bd0028 	addiu	sp,sp,40

a0003e98 <write_one_tlb>:

void write_one_tlb(int index, u32 pagemask, u32 hi, u32 low0, u32 low1)
{
	write_c0_entrylo0(low0);
a0003e98:	40871000 	mtc0	a3,c0_entrylo0
	write_c0_pagemask(pagemask);
a0003e9c:	40852800 	mtc0	a1,c0_pagemask
	write_c0_entrylo1(low1);
a0003ea0:	8fa20010 	lw	v0,16(sp)
a0003ea4:	40821800 	mtc0	v0,c0_entrylo1
	write_c0_entryhi(hi);
a0003ea8:	40865000 	mtc0	a2,c0_entryhi
	write_c0_index(index);
a0003eac:	40840000 	mtc0	a0,c0_index
#endif
}

static inline void tlb_write_indexed(void)
{
	__asm__ __volatile__(
a0003eb0:	42000002 	tlbwi
a0003eb4:	03e00008 	jr	ra
a0003eb8:	00000000 	nop
a0003ebc:	00000000 	nop

a0003ec0 <permission_wr>:
#include <common.h>

u32 permission_wr(u32 addr, u32 val){
    REG32(addr) = val;
a0003ec0:	ac850000 	sw	a1,0(a0)
   
    return 0;
}
a0003ec4:	03e00008 	jr	ra
a0003ec8:	00001021 	move	v0,zero

a0003ecc <set_permission>:

void set_permission(void)
{
a0003ecc:	3c1c0000 	lui	gp,0x0
a0003ed0:	279c1a74 	addiu	gp,gp,6772
a0003ed4:	0399e021 	addu	gp,gp,t9
a0003ed8:	27bdffc8 	addiu	sp,sp,-56
	  int i;
		i = 0;
    i += permission_wr(0xb3f81458, 0x1f); 	//ssb6:ln60
a0003edc:	8f9900e0 	lw	t9,224(gp)
   
    return 0;
}

void set_permission(void)
{
a0003ee0:	afb30028 	sw	s3,40(sp)
	  int i;
		i = 0;
    i += permission_wr(0xb3f81458, 0x1f); 	//ssb6:ln60
a0003ee4:	3c13b3f8 	lui	s3,0xb3f8
   
    return 0;
}

void set_permission(void)
{
a0003ee8:	afbf0034 	sw	ra,52(sp)
a0003eec:	afbc0010 	sw	gp,16(sp)
a0003ef0:	afb50030 	sw	s5,48(sp)
a0003ef4:	afb4002c 	sw	s4,44(sp)
a0003ef8:	afb20024 	sw	s2,36(sp)
a0003efc:	afb10020 	sw	s1,32(sp)
a0003f00:	afb0001c 	sw	s0,28(sp)
	  int i;
		i = 0;
    i += permission_wr(0xb3f81458, 0x1f); 	//ssb6:ln60
a0003f04:	26641458 	addiu	a0,s3,5208
a0003f08:	0320f809 	jalr	t9
a0003f0c:	2405001f 	li	a1,31
a0003f10:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f81450, 0x1f); 
a0003f14:	26641450 	addiu	a0,s3,5200
a0003f18:	2405001f 	li	a1,31
a0003f1c:	8f9900e0 	lw	t9,224(gp)
a0003f20:	0320f809 	jalr	t9
a0003f24:	3c10bff8 	lui	s0,0xbff8
a0003f28:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80858, 0x7f); 	//ssb6:ddr,memmax ,vector 0, 0x7f
a0003f2c:	26640858 	addiu	a0,s3,2136
a0003f30:	2405007f 	li	a1,127
a0003f34:	8f9900e0 	lw	t9,224(gp)
a0003f38:	0320f809 	jalr	t9
a0003f3c:	3c15bdf8 	lui	s5,0xbdf8
a0003f40:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80850, 0x7f);    
a0003f44:	26640850 	addiu	a0,s3,2128
a0003f48:	2405007f 	li	a1,127
a0003f4c:	8f9900e0 	lw	t9,224(gp)
a0003f50:	0320f809 	jalr	t9
a0003f54:	3c14bbf8 	lui	s4,0xbbf8
a0003f58:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80878, 0x7f); 	//ssb6:ddr,memmax ,vector 1 
a0003f5c:	26640878 	addiu	a0,s3,2168
a0003f60:	2405007f 	li	a1,127
a0003f64:	8f9900e0 	lw	t9,224(gp)
a0003f68:	0320f809 	jalr	t9
a0003f6c:	3c12b9f8 	lui	s2,0xb9f8
a0003f70:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80870, 0x7f);    
a0003f74:	26640870 	addiu	a0,s3,2160
a0003f78:	2405007f 	li	a1,127
a0003f7c:	8f9900e0 	lw	t9,224(gp)
a0003f80:	0320f809 	jalr	t9
a0003f84:	3c11b7f8 	lui	s1,0xb7f8
a0003f88:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80898, 0x7f); 	//ssb6:ddr,memmax ,vector 2
a0003f8c:	26640898 	addiu	a0,s3,2200
a0003f90:	8f9900e0 	lw	t9,224(gp)
a0003f94:	0320f809 	jalr	t9
a0003f98:	2405007f 	li	a1,127
a0003f9c:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80890, 0x7f);    
a0003fa0:	26640890 	addiu	a0,s3,2192
a0003fa4:	8f9900e0 	lw	t9,224(gp)
a0003fa8:	0320f809 	jalr	t9
a0003fac:	2405007f 	li	a1,127
a0003fb0:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f808b8, 0x7f); 	//ssb6:ddr,memmax ,vector 3
a0003fb4:	266408b8 	addiu	a0,s3,2232
a0003fb8:	8f9900e0 	lw	t9,224(gp)
a0003fbc:	0320f809 	jalr	t9
a0003fc0:	2405007f 	li	a1,127
a0003fc4:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f808b0, 0x7f);    
a0003fc8:	266408b0 	addiu	a0,s3,2224
a0003fcc:	8f9900e0 	lw	t9,224(gp)
a0003fd0:	0320f809 	jalr	t9
a0003fd4:	2405007f 	li	a1,127
a0003fd8:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f808d8, 0x7f); 	//ssb6:ddr,memmax ,vector 4
a0003fdc:	266408d8 	addiu	a0,s3,2264
a0003fe0:	8f9900e0 	lw	t9,224(gp)
a0003fe4:	0320f809 	jalr	t9
a0003fe8:	2405007f 	li	a1,127
a0003fec:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f808d0, 0x7f);    
a0003ff0:	266408d0 	addiu	a0,s3,2256
a0003ff4:	8f9900e0 	lw	t9,224(gp)
a0003ff8:	0320f809 	jalr	t9
a0003ffc:	2405007f 	li	a1,127
a0004000:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f808f8, 0x7f); 	//ssb6:ddr,memmax ,vector 5
a0004004:	266408f8 	addiu	a0,s3,2296
a0004008:	8f9900e0 	lw	t9,224(gp)
a000400c:	0320f809 	jalr	t9
a0004010:	2405007f 	li	a1,127
a0004014:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f808f0, 0x7f);    
a0004018:	266408f0 	addiu	a0,s3,2288
a000401c:	8f9900e0 	lw	t9,224(gp)
a0004020:	0320f809 	jalr	t9
a0004024:	2405007f 	li	a1,127
a0004028:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80918, 0x7f); 	//ssb6:ddr,memmax ,vector 6
a000402c:	26640918 	addiu	a0,s3,2328
a0004030:	8f9900e0 	lw	t9,224(gp)
a0004034:	0320f809 	jalr	t9
a0004038:	2405007f 	li	a1,127
a000403c:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80910, 0x7f);    
a0004040:	26640910 	addiu	a0,s3,2320
a0004044:	8f9900e0 	lw	t9,224(gp)
a0004048:	0320f809 	jalr	t9
a000404c:	2405007f 	li	a1,127
a0004050:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80938, 0x7f); 	//ssb6:ddr,memmax ,vector 7
a0004054:	26640938 	addiu	a0,s3,2360
a0004058:	8f9900e0 	lw	t9,224(gp)
a000405c:	0320f809 	jalr	t9
a0004060:	2405007f 	li	a1,127
a0004064:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80930, 0x7f);    
a0004068:	26640930 	addiu	a0,s3,2352
a000406c:	8f9900e0 	lw	t9,224(gp)
a0004070:	0320f809 	jalr	t9
a0004074:	2405007f 	li	a1,127
a0004078:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80c58, 0x1f); 	//ssb6:ddr,upctl 
a000407c:	26640c58 	addiu	a0,s3,3160
a0004080:	8f9900e0 	lw	t9,224(gp)
a0004084:	0320f809 	jalr	t9
a0004088:	2405001f 	li	a1,31
a000408c:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80c50, 0x1f);
a0004090:	26640c50 	addiu	a0,s3,3152
a0004094:	8f9900e0 	lw	t9,224(gp)
a0004098:	0320f809 	jalr	t9
a000409c:	2405001f 	li	a1,31
a00040a0:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f81058, 0x1f); 	//ssb6:ddr,phy
a00040a4:	26641058 	addiu	a0,s3,4184
a00040a8:	8f9900e0 	lw	t9,224(gp)
a00040ac:	0320f809 	jalr	t9
a00040b0:	2405001f 	li	a1,31
a00040b4:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f81050, 0x1f);
a00040b8:	26641050 	addiu	a0,s3,4176
a00040bc:	8f9900e0 	lw	t9,224(gp)
a00040c0:	0320f809 	jalr	t9
a00040c4:	2405001f 	li	a1,31
a00040c8:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80458, 0x3); 	//ssb6:iocu (2-bit)
a00040cc:	26640458 	addiu	a0,s3,1112
a00040d0:	8f9900e0 	lw	t9,224(gp)
a00040d4:	0320f809 	jalr	t9
a00040d8:	24050003 	li	a1,3
a00040dc:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80450, 0x3);
a00040e0:	26640450 	addiu	a0,s3,1104
a00040e4:	8f9900e0 	lw	t9,224(gp)
a00040e8:	0320f809 	jalr	t9
a00040ec:	24050003 	li	a1,3
a00040f0:	8fbc0010 	lw	gp,16(sp)
  

/* SSX0 FOR OTHER MASTER TO ACCESS BOOTROM, OTP, SSBRAM */	
	i = 0;
    i += permission_wr(0xbff80058, 0x1f); 	//regs
a00040f4:	26040058 	addiu	a0,s0,88
a00040f8:	8f9900e0 	lw	t9,224(gp)
a00040fc:	0320f809 	jalr	t9
a0004100:	2405001f 	li	a1,31
a0004104:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff80050, 0x1f);
a0004108:	26040050 	addiu	a0,s0,80
a000410c:	8f9900e0 	lw	t9,224(gp)
a0004110:	0320f809 	jalr	t9
a0004114:	2405001f 	li	a1,31
a0004118:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbdf80058, 0x1f); 	//regs
a000411c:	26a40058 	addiu	a0,s5,88
a0004120:	8f9900e0 	lw	t9,224(gp)
a0004124:	0320f809 	jalr	t9
a0004128:	2405001f 	li	a1,31
a000412c:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbdf80050, 0x1f);
a0004130:	26a40050 	addiu	a0,s5,80
a0004134:	8f9900e0 	lw	t9,224(gp)
a0004138:	0320f809 	jalr	t9
a000413c:	2405001f 	li	a1,31
a0004140:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbbf80058, 0x1f); 	//regs
a0004144:	26840058 	addiu	a0,s4,88
a0004148:	8f9900e0 	lw	t9,224(gp)
a000414c:	0320f809 	jalr	t9
a0004150:	2405001f 	li	a1,31
a0004154:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbbf80050, 0x1f);
a0004158:	26840050 	addiu	a0,s4,80
a000415c:	8f9900e0 	lw	t9,224(gp)
a0004160:	0320f809 	jalr	t9
a0004164:	2405001f 	li	a1,31
a0004168:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb9f80058, 0x1f); 	//regs
a000416c:	26440058 	addiu	a0,s2,88
a0004170:	8f9900e0 	lw	t9,224(gp)
a0004174:	0320f809 	jalr	t9
a0004178:	2405001f 	li	a1,31
a000417c:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb9f80050, 0x1f);
a0004180:	26440050 	addiu	a0,s2,80
a0004184:	8f9900e0 	lw	t9,224(gp)
a0004188:	0320f809 	jalr	t9
a000418c:	2405001f 	li	a1,31
a0004190:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb7f80058, 0x1f); 	//regs
a0004194:	26240058 	addiu	a0,s1,88
a0004198:	8f9900e0 	lw	t9,224(gp)
a000419c:	0320f809 	jalr	t9
a00041a0:	2405001f 	li	a1,31
a00041a4:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb7f80050, 0x1f);
a00041a8:	26240050 	addiu	a0,s1,80
a00041ac:	8f9900e0 	lw	t9,224(gp)
a00041b0:	0320f809 	jalr	t9
a00041b4:	2405001f 	li	a1,31
a00041b8:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80058, 0x1f); 	//regs
a00041bc:	26640058 	addiu	a0,s3,88
a00041c0:	8f9900e0 	lw	t9,224(gp)
a00041c4:	0320f809 	jalr	t9
a00041c8:	2405001f 	li	a1,31
a00041cc:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb3f80050, 0x1f);
a00041d0:	26640050 	addiu	a0,s3,80
a00041d4:	8f9900e0 	lw	t9,224(gp)
a00041d8:	0320f809 	jalr	t9
a00041dc:	2405001f 	li	a1,31
a00041e0:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff82858, 0x1f); 	//ss0:ln01
a00041e4:	26042858 	addiu	a0,s0,10328
a00041e8:	8f9900e0 	lw	t9,224(gp)
a00041ec:	0320f809 	jalr	t9
a00041f0:	2405001f 	li	a1,31
a00041f4:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff82850, 0x1f); 
a00041f8:	26042850 	addiu	a0,s0,10320
a00041fc:	8f9900e0 	lw	t9,224(gp)
a0004200:	0320f809 	jalr	t9
a0004204:	2405001f 	li	a1,31
a0004208:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff82C58, 0x1f); 	//ss0:ln02
a000420c:	26042c58 	addiu	a0,s0,11352
a0004210:	8f9900e0 	lw	t9,224(gp)
a0004214:	0320f809 	jalr	t9
a0004218:	2405001f 	li	a1,31
a000421c:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff82C50, 0x1f); 
a0004220:	26042c50 	addiu	a0,s0,11344
a0004224:	8f9900e0 	lw	t9,224(gp)
a0004228:	0320f809 	jalr	t9
a000422c:	2405001f 	li	a1,31
a0004230:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff83058, 0x1f); 	//ss0:ln03
a0004234:	26043058 	addiu	a0,s0,12376
a0004238:	8f9900e0 	lw	t9,224(gp)
a000423c:	0320f809 	jalr	t9
a0004240:	2405001f 	li	a1,31
a0004244:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff83050, 0x1f); 
a0004248:	26043050 	addiu	a0,s0,12368
a000424c:	8f9900e0 	lw	t9,224(gp)
a0004250:	0320f809 	jalr	t9
a0004254:	2405001f 	li	a1,31
a0004258:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff83458, 0x1f); 	//ss0:ex04
a000425c:	26043458 	addiu	a0,s0,13400
a0004260:	8f9900e0 	lw	t9,224(gp)
a0004264:	0320f809 	jalr	t9
a0004268:	2405001f 	li	a1,31
a000426c:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff83450, 0x1f); 
a0004270:	26043450 	addiu	a0,s0,13392
a0004274:	8f9900e0 	lw	t9,224(gp)
a0004278:	0320f809 	jalr	t9
a000427c:	2405001f 	li	a1,31
a0004280:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff83858, 0x1f); 	//ss0:ex05
a0004284:	26043858 	addiu	a0,s0,14424
a0004288:	8f9900e0 	lw	t9,224(gp)
a000428c:	0320f809 	jalr	t9
a0004290:	2405001f 	li	a1,31
a0004294:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff83850, 0x1f); 
a0004298:	26043850 	addiu	a0,s0,14416
a000429c:	8f9900e0 	lw	t9,224(gp)
a00042a0:	0320f809 	jalr	t9
a00042a4:	2405001f 	li	a1,31
a00042a8:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff80858, 0x1f); 	//ss0:rom
a00042ac:	26040858 	addiu	a0,s0,2136
a00042b0:	8f9900e0 	lw	t9,224(gp)
a00042b4:	0320f809 	jalr	t9
a00042b8:	2405001f 	li	a1,31
a00042bc:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff80850, 0x1f); 
a00042c0:	26040850 	addiu	a0,s0,2128
a00042c4:	8f9900e0 	lw	t9,224(gp)
a00042c8:	0320f809 	jalr	t9
a00042cc:	2405001f 	li	a1,31
a00042d0:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff80c58, 0x1f); 	//ss0:otp
a00042d4:	26040c58 	addiu	a0,s0,3160
a00042d8:	8f9900e0 	lw	t9,224(gp)
a00042dc:	0320f809 	jalr	t9
a00042e0:	2405001f 	li	a1,31
a00042e4:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff80c50, 0x1f); 
a00042e8:	26040c50 	addiu	a0,s0,3152
a00042ec:	8f9900e0 	lw	t9,224(gp)
a00042f0:	0320f809 	jalr	t9
a00042f4:	2405001f 	li	a1,31
a00042f8:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff80458, 0x1f); 	//ss0:ssb, region 0
a00042fc:	26040458 	addiu	a0,s0,1112
a0004300:	8f9900e0 	lw	t9,224(gp)
a0004304:	0320f809 	jalr	t9
a0004308:	2405001f 	li	a1,31
a000430c:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff80450, 0x1f); 
a0004310:	26040450 	addiu	a0,s0,1104
a0004314:	8f9900e0 	lw	t9,224(gp)
a0004318:	0320f809 	jalr	t9
a000431c:	2405001f 	li	a1,31
a0004320:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff80478, 0x01);   //ss0:ssb, region 1 (1, from S1.3)
a0004324:	26040478 	addiu	a0,s0,1144
a0004328:	8f9900e0 	lw	t9,224(gp)
a000432c:	0320f809 	jalr	t9
a0004330:	24050001 	li	a1,1
a0004334:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff80470, 0x01);
a0004338:	26040470 	addiu	a0,s0,1136
a000433c:	8f9900e0 	lw	t9,224(gp)
a0004340:	0320f809 	jalr	t9
a0004344:	24050001 	li	a1,1
a0004348:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff80498, 0x01);   //ss0:ssb, region 2 (1, from S1.3)
a000434c:	26040498 	addiu	a0,s0,1176
a0004350:	8f9900e0 	lw	t9,224(gp)
a0004354:	0320f809 	jalr	t9
a0004358:	24050001 	li	a1,1
a000435c:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff80490, 0x01);
a0004360:	26040490 	addiu	a0,s0,1168
a0004364:	8f9900e0 	lw	t9,224(gp)
a0004368:	0320f809 	jalr	t9
a000436c:	24050001 	li	a1,1
a0004370:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff804b8, 0x01);   //ss0:ssb, region 3 (1, from S1.3)
a0004374:	260404b8 	addiu	a0,s0,1208
a0004378:	8f9900e0 	lw	t9,224(gp)
a000437c:	0320f809 	jalr	t9
a0004380:	24050001 	li	a1,1
a0004384:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff804b0, 0x01);
a0004388:	260404b0 	addiu	a0,s0,1200
a000438c:	8f9900e0 	lw	t9,224(gp)
a0004390:	0320f809 	jalr	t9
a0004394:	24050001 	li	a1,1
a0004398:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff81058, 0x1f);   //ssx0, cbm1
a000439c:	26041058 	addiu	a0,s0,4184
a00043a0:	8f9900e0 	lw	t9,224(gp)
a00043a4:	0320f809 	jalr	t9
a00043a8:	2405001f 	li	a1,31
a00043ac:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff81050, 0x1f);
a00043b0:	26041050 	addiu	a0,s0,4176
a00043b4:	8f9900e0 	lw	t9,224(gp)
a00043b8:	0320f809 	jalr	t9
a00043bc:	2405001f 	li	a1,31
a00043c0:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff81458, 0x1f);   //ssx0, cbm2
a00043c4:	26041458 	addiu	a0,s0,5208
a00043c8:	8f9900e0 	lw	t9,224(gp)
a00043cc:	0320f809 	jalr	t9
a00043d0:	2405001f 	li	a1,31
a00043d4:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff81450, 0x1f);
a00043d8:	26041450 	addiu	a0,s0,5200
a00043dc:	8f9900e0 	lw	t9,224(gp)
a00043e0:	0320f809 	jalr	t9
a00043e4:	2405001f 	li	a1,31
a00043e8:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff82058, 0x1f);   //ssx0, dma3
a00043ec:	26042058 	addiu	a0,s0,8280
a00043f0:	8f9900e0 	lw	t9,224(gp)
a00043f4:	0320f809 	jalr	t9
a00043f8:	2405001f 	li	a1,31
a00043fc:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff82050, 0x1f);
a0004400:	26042050 	addiu	a0,s0,8272
a0004404:	8f9900e0 	lw	t9,224(gp)
a0004408:	0320f809 	jalr	t9
a000440c:	2405001f 	li	a1,31
a0004410:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff82458, 0x1f);   //ssx0, dma4
a0004414:	26042458 	addiu	a0,s0,9304
a0004418:	8f9900e0 	lw	t9,224(gp)
a000441c:	0320f809 	jalr	t9
a0004420:	2405001f 	li	a1,31
a0004424:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff82450, 0x1f);
a0004428:	26042450 	addiu	a0,s0,9296
a000442c:	8f9900e0 	lw	t9,224(gp)
a0004430:	0320f809 	jalr	t9
a0004434:	2405001f 	li	a1,31
a0004438:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff81858, 0x1f);   //ssx0, eip97 (only 4kec should access)
a000443c:	26041858 	addiu	a0,s0,6232
a0004440:	8f9900e0 	lw	t9,224(gp)
a0004444:	0320f809 	jalr	t9
a0004448:	2405001f 	li	a1,31
a000444c:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff81850, 0x1f);
a0004450:	26041850 	addiu	a0,s0,6224
a0004454:	8f9900e0 	lw	t9,224(gp)
a0004458:	0320f809 	jalr	t9
a000445c:	2405001f 	li	a1,31
a0004460:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff81C58, 0x1f);   //ssx0, eip123 (only 4kec should access)
a0004464:	26041c58 	addiu	a0,s0,7256
a0004468:	8f9900e0 	lw	t9,224(gp)
a000446c:	0320f809 	jalr	t9
a0004470:	2405001f 	li	a1,31
a0004474:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbff81C50, 0x1f);
a0004478:	26041c50 	addiu	a0,s0,7248
a000447c:	8f9900e0 	lw	t9,224(gp)
a0004480:	0320f809 	jalr	t9
a0004484:	2405001f 	li	a1,31
a0004488:	8fbc0010 	lw	gp,16(sp)


	
/* SSX4 - FOR OTHER MASTER TO ACCESS PERIPHERALS */
	i = 0;
    i += permission_wr(0xb7f82058, 0x1f); 	//ssb4:asc0
a000448c:	26242058 	addiu	a0,s1,8280
a0004490:	8f9900e0 	lw	t9,224(gp)
a0004494:	0320f809 	jalr	t9
a0004498:	2405001f 	li	a1,31
a000449c:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb7f82050, 0x1f); 
a00044a0:	26242050 	addiu	a0,s1,8272
a00044a4:	8f9900e0 	lw	t9,224(gp)
a00044a8:	0320f809 	jalr	t9
a00044ac:	2405001f 	li	a1,31
a00044b0:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb7f82458, 0x1f); 	//ssb4:asc1
a00044b4:	26242458 	addiu	a0,s1,9304
a00044b8:	8f9900e0 	lw	t9,224(gp)
a00044bc:	0320f809 	jalr	t9
a00044c0:	2405001f 	li	a1,31
a00044c4:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb7f82450, 0x1f); 
a00044c8:	26242450 	addiu	a0,s1,9296
a00044cc:	8f9900e0 	lw	t9,224(gp)
a00044d0:	0320f809 	jalr	t9
a00044d4:	2405001f 	li	a1,31
a00044d8:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb7f81858, 0x1f); 	//ssb4:ledc
a00044dc:	26241858 	addiu	a0,s1,6232
a00044e0:	8f9900e0 	lw	t9,224(gp)
a00044e4:	0320f809 	jalr	t9
a00044e8:	2405001f 	li	a1,31
a00044ec:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb7f81850, 0x1f);
a00044f0:	26241850 	addiu	a0,s1,6224
a00044f4:	8f9900e0 	lw	t9,224(gp)
a00044f8:	0320f809 	jalr	t9
a00044fc:	2405001f 	li	a1,31
a0004500:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xb7f81458, 0x1f); 	//ssb4:gpio (0x1 for only 4KEc)
a0004504:	26241458 	addiu	a0,s1,5208
a0004508:	8f9900e0 	lw	t9,224(gp)
a000450c:	0320f809 	jalr	t9
a0004510:	2405001f 	li	a1,31
a0004514:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f81450, 0x1f);
a0004518:	26241450 	addiu	a0,s1,5200
a000451c:	8f9900e0 	lw	t9,224(gp)
a0004520:	0320f809 	jalr	t9
a0004524:	2405001f 	li	a1,31
a0004528:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f81C58, 0x1f); 	//ssb4:i2c
a000452c:	26241c58 	addiu	a0,s1,7256
a0004530:	8f9900e0 	lw	t9,224(gp)
a0004534:	0320f809 	jalr	t9
a0004538:	2405001f 	li	a1,31
a000453c:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f81C50, 0x1f);
a0004540:	26241c50 	addiu	a0,s1,7248
a0004544:	8f9900e0 	lw	t9,224(gp)
a0004548:	0320f809 	jalr	t9
a000454c:	2405001f 	li	a1,31
a0004550:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f83858, 0x1f); 	//ssb4:ebu
a0004554:	26243858 	addiu	a0,s1,14424
a0004558:	8f9900e0 	lw	t9,224(gp)
a000455c:	0320f809 	jalr	t9
a0004560:	2405001f 	li	a1,31
a0004564:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f83850, 0x1f);
a0004568:	26243850 	addiu	a0,s1,14416
a000456c:	8f9900e0 	lw	t9,224(gp)
a0004570:	0320f809 	jalr	t9
a0004574:	2405001f 	li	a1,31
a0004578:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f82858, 0x1f); 	//ssb4:gptc0
a000457c:	26242858 	addiu	a0,s1,10328
a0004580:	8f9900e0 	lw	t9,224(gp)
a0004584:	0320f809 	jalr	t9
a0004588:	2405001f 	li	a1,31
a000458c:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f82850, 0x1f);
a0004590:	26242850 	addiu	a0,s1,10320
a0004594:	8f9900e0 	lw	t9,224(gp)
a0004598:	0320f809 	jalr	t9
a000459c:	2405001f 	li	a1,31
a00045a0:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f83C58, 0x1f); 	//ssb4:gptc1
a00045a4:	26243c58 	addiu	a0,s1,15448
a00045a8:	8f9900e0 	lw	t9,224(gp)
a00045ac:	0320f809 	jalr	t9
a00045b0:	2405001f 	li	a1,31
a00045b4:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f83C50, 0x1f);
a00045b8:	26243c50 	addiu	a0,s1,15440
a00045bc:	8f9900e0 	lw	t9,224(gp)
a00045c0:	0320f809 	jalr	t9
a00045c4:	2405001f 	li	a1,31
a00045c8:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f84058, 0x1f); 	//ssb4:gptc2
a00045cc:	26244058 	addiu	a0,s1,16472
a00045d0:	8f9900e0 	lw	t9,224(gp)
a00045d4:	0320f809 	jalr	t9
a00045d8:	2405001f 	li	a1,31
a00045dc:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f84050, 0x1f);
a00045e0:	26244050 	addiu	a0,s1,16464
a00045e4:	8f9900e0 	lw	t9,224(gp)
a00045e8:	0320f809 	jalr	t9
a00045ec:	2405001f 	li	a1,31
a00045f0:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f80458, 0x1f);	//ssx4, cgu
a00045f4:	26240458 	addiu	a0,s1,1112
a00045f8:	8f9900e0 	lw	t9,224(gp)
a00045fc:	0320f809 	jalr	t9
a0004600:	2405001f 	li	a1,31
a0004604:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f80450, 0x1f);
a0004608:	26240450 	addiu	a0,s1,1104
a000460c:	8f9900e0 	lw	t9,224(gp)
a0004610:	0320f809 	jalr	t9
a0004614:	2405001f 	li	a1,31
a0004618:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f80858, 0x1f);	//ssx4, rcu
a000461c:	26240858 	addiu	a0,s1,2136
a0004620:	8f9900e0 	lw	t9,224(gp)
a0004624:	0320f809 	jalr	t9
a0004628:	2405001f 	li	a1,31
a000462c:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f80850, 0x1f);
a0004630:	26240850 	addiu	a0,s1,2128
a0004634:	8f9900e0 	lw	t9,224(gp)
a0004638:	0320f809 	jalr	t9
a000463c:	2405001f 	li	a1,31
a0004640:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f80C58, 0x1f);	//ssx4, pmu
a0004644:	26240c58 	addiu	a0,s1,3160
a0004648:	8f9900e0 	lw	t9,224(gp)
a000464c:	0320f809 	jalr	t9
a0004650:	2405001f 	li	a1,31
a0004654:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f80C50, 0x1f);
a0004658:	26240c50 	addiu	a0,s1,3152
a000465c:	8f9900e0 	lw	t9,224(gp)
a0004660:	0320f809 	jalr	t9
a0004664:	2405001f 	li	a1,31
a0004668:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f81058, 0x1f);	//ssx4, pcm
a000466c:	26241058 	addiu	a0,s1,4184
a0004670:	8f9900e0 	lw	t9,224(gp)
a0004674:	0320f809 	jalr	t9
a0004678:	2405001f 	li	a1,31
a000467c:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f81050, 0x1f);
a0004680:	26241050 	addiu	a0,s1,4176
a0004684:	8f9900e0 	lw	t9,224(gp)
a0004688:	0320f809 	jalr	t9
a000468c:	2405001f 	li	a1,31
a0004690:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f82C58, 0x1f);	//ssx4, spi0
a0004694:	26242c58 	addiu	a0,s1,11352
a0004698:	8f9900e0 	lw	t9,224(gp)
a000469c:	0320f809 	jalr	t9
a00046a0:	2405001f 	li	a1,31
a00046a4:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f82C50, 0x1f);
a00046a8:	26242c50 	addiu	a0,s1,11344
a00046ac:	8f9900e0 	lw	t9,224(gp)
a00046b0:	0320f809 	jalr	t9
a00046b4:	2405001f 	li	a1,31
a00046b8:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f83058, 0x1f);	//ssx4, spi1
a00046bc:	26243058 	addiu	a0,s1,12376
a00046c0:	8f9900e0 	lw	t9,224(gp)
a00046c4:	0320f809 	jalr	t9
a00046c8:	2405001f 	li	a1,31
a00046cc:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f83050, 0x1f);
a00046d0:	26243050 	addiu	a0,s1,12368
a00046d4:	8f9900e0 	lw	t9,224(gp)
a00046d8:	0320f809 	jalr	t9
a00046dc:	2405001f 	li	a1,31
a00046e0:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f83458, 0x1f);	//ssx4, dma0
a00046e4:	26243458 	addiu	a0,s1,13400
a00046e8:	8f9900e0 	lw	t9,224(gp)
a00046ec:	0320f809 	jalr	t9
a00046f0:	2405001f 	li	a1,31
a00046f4:	8fbc0010 	lw	gp,16(sp)
	i += permission_wr(0xb7f83450, 0x1f);
a00046f8:	26243450 	addiu	a0,s1,13392
a00046fc:	8f9900e0 	lw	t9,224(gp)
a0004700:	0320f809 	jalr	t9
a0004704:	2405001f 	li	a1,31
a0004708:	8fbc0010 	lw	gp,16(sp)
	

/* SSX1 */
        i = 0;
    i += permission_wr(0xbdf80058, 0x1f);       //ssx1, reg1-r0 (only 4kec should access reg1-r0)
a000470c:	36a40058 	ori	a0,s5,0x58
a0004710:	8f9900e0 	lw	t9,224(gp)
a0004714:	0320f809 	jalr	t9
a0004718:	2405001f 	li	a1,31
a000471c:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbdf80050, 0x1f);
a0004720:	36a40050 	ori	a0,s5,0x50
a0004724:	8f9900e0 	lw	t9,224(gp)
a0004728:	0320f809 	jalr	t9
a000472c:	2405001f 	li	a1,31
a0004730:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbdf80078, 0x1f);   //ssx1, reg1-r1 (only 4kec should access reg1-r1)
a0004734:	26a40078 	addiu	a0,s5,120
a0004738:	8f9900e0 	lw	t9,224(gp)
a000473c:	0320f809 	jalr	t9
a0004740:	2405001f 	li	a1,31
a0004744:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbdf80070, 0x1f);
a0004748:	26a40070 	addiu	a0,s5,112
a000474c:	8f9900e0 	lw	t9,224(gp)
a0004750:	0320f809 	jalr	t9
a0004754:	2405001f 	li	a1,31
a0004758:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbdf80c58, 0x1f);       //ssx1:gswipl_pm
a000475c:	26a40c58 	addiu	a0,s5,3160
a0004760:	8f9900e0 	lw	t9,224(gp)
a0004764:	0320f809 	jalr	t9
a0004768:	2405001f 	li	a1,31
a000476c:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbdf80c50, 0x1f);
a0004770:	26a40c50 	addiu	a0,s5,3152
a0004774:	8f9900e0 	lw	t9,224(gp)
a0004778:	0320f809 	jalr	t9
a000477c:	2405001f 	li	a1,31
a0004780:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbdf80458, 0x1f);       //ssx1:dm2r, Vector 0
a0004784:	26a40458 	addiu	a0,s5,1112
a0004788:	8f9900e0 	lw	t9,224(gp)
a000478c:	0320f809 	jalr	t9
a0004790:	2405001f 	li	a1,31
a0004794:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbdf80450, 0x1f);
a0004798:	26a40450 	addiu	a0,s5,1104
a000479c:	8f9900e0 	lw	t9,224(gp)
a00047a0:	0320f809 	jalr	t9
a00047a4:	2405001f 	li	a1,31
a00047a8:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbdf80858, 0x1f);       //ssx1:dm2t, Vector 0
a00047ac:	26a40858 	addiu	a0,s5,2136
a00047b0:	8f9900e0 	lw	t9,224(gp)
a00047b4:	0320f809 	jalr	t9
a00047b8:	2405001f 	li	a1,31
a00047bc:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbdf80850, 0x1f);
a00047c0:	26a40850 	addiu	a0,s5,2128
a00047c4:	8f9900e0 	lw	t9,224(gp)
a00047c8:	0320f809 	jalr	t9
a00047cc:	2405001f 	li	a1,31
a00047d0:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbdf81058, 0x1);        //ssx1:ln10, 1 bit for all
a00047d4:	26a41058 	addiu	a0,s5,4184
a00047d8:	8f9900e0 	lw	t9,224(gp)
a00047dc:	0320f809 	jalr	t9
a00047e0:	24050001 	li	a1,1
a00047e4:	8fbc0010 	lw	gp,16(sp)
    i += permission_wr(0xbdf81050, 0x1);
a00047e8:	26a41050 	addiu	a0,s5,4176
a00047ec:	8f9900e0 	lw	t9,224(gp)
a00047f0:	0320f809 	jalr	t9
a00047f4:	24050001 	li	a1,1
a00047f8:	8fbc0010 	lw	gp,16(sp)

/*ssx2*/
#if 1
        i += permission_wr(0xbbf80058, 0x1f);   //ssx2, reg2-r0 (only 4kec should access reg2-r0)
a00047fc:	36840058 	ori	a0,s4,0x58
a0004800:	8f9900e0 	lw	t9,224(gp)
a0004804:	0320f809 	jalr	t9
a0004808:	2405001f 	li	a1,31
a000480c:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf80050, 0x1f);
a0004810:	36840050 	ori	a0,s4,0x50
a0004814:	8f9900e0 	lw	t9,224(gp)
a0004818:	0320f809 	jalr	t9
a000481c:	2405001f 	li	a1,31
a0004820:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf80078, 0x1f);   //ssx2, reg2-r1 (only 4kec should access reg2-r1)
a0004824:	26840078 	addiu	a0,s4,120
a0004828:	8f9900e0 	lw	t9,224(gp)
a000482c:	0320f809 	jalr	t9
a0004830:	2405001f 	li	a1,31
a0004834:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf80070, 0x1f);
a0004838:	26840070 	addiu	a0,s4,112
a000483c:	8f9900e0 	lw	t9,224(gp)
a0004840:	0320f809 	jalr	t9
a0004844:	2405001f 	li	a1,31
a0004848:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf81C58, 0x1f);   //ssx2, gswip-r
a000484c:	26841c58 	addiu	a0,s4,7256
a0004850:	8f9900e0 	lw	t9,224(gp)
a0004854:	0320f809 	jalr	t9
a0004858:	2405001f 	li	a1,31
a000485c:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf81C50, 0x1f);
a0004860:	26841c50 	addiu	a0,s4,7248
a0004864:	8f9900e0 	lw	t9,224(gp)
a0004868:	0320f809 	jalr	t9
a000486c:	2405001f 	li	a1,31
a0004870:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf81858, 0x1f);   //ssx2, dma1tx
a0004874:	26841858 	addiu	a0,s4,6232
a0004878:	8f9900e0 	lw	t9,224(gp)
a000487c:	0320f809 	jalr	t9
a0004880:	2405001f 	li	a1,31
a0004884:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf81850, 0x1f);
a0004888:	26841850 	addiu	a0,s4,6224
a000488c:	8f9900e0 	lw	t9,224(gp)
a0004890:	0320f809 	jalr	t9
a0004894:	2405001f 	li	a1,31
a0004898:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf81458, 0x1f);   //ssx2, dma1rx
a000489c:	26841458 	addiu	a0,s4,5208
a00048a0:	8f9900e0 	lw	t9,224(gp)
a00048a4:	0320f809 	jalr	t9
a00048a8:	2405001f 	li	a1,31
a00048ac:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf81450, 0x1f);
a00048b0:	26841450 	addiu	a0,s4,5200
a00048b4:	8f9900e0 	lw	t9,224(gp)
a00048b8:	0320f809 	jalr	t9
a00048bc:	2405001f 	li	a1,31
a00048c0:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf80458, 0x1f);   //ssx2, usb0
a00048c4:	26840458 	addiu	a0,s4,1112
a00048c8:	8f9900e0 	lw	t9,224(gp)
a00048cc:	0320f809 	jalr	t9
a00048d0:	2405001f 	li	a1,31
a00048d4:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf80450, 0x1f);
a00048d8:	26840450 	addiu	a0,s4,1104
a00048dc:	8f9900e0 	lw	t9,224(gp)
a00048e0:	0320f809 	jalr	t9
a00048e4:	2405001f 	li	a1,31
a00048e8:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf80858, 0x1f);   //ssx2, usb0c
a00048ec:	26840858 	addiu	a0,s4,2136
a00048f0:	8f9900e0 	lw	t9,224(gp)
a00048f4:	0320f809 	jalr	t9
a00048f8:	2405001f 	li	a1,31
a00048fc:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf80850, 0x1f);
a0004900:	26840850 	addiu	a0,s4,2128
a0004904:	8f9900e0 	lw	t9,224(gp)
a0004908:	0320f809 	jalr	t9
a000490c:	2405001f 	li	a1,31
a0004910:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf80C58, 0x1f);   //ssx2, usb1
a0004914:	26840c58 	addiu	a0,s4,3160
a0004918:	8f9900e0 	lw	t9,224(gp)
a000491c:	0320f809 	jalr	t9
a0004920:	2405001f 	li	a1,31
a0004924:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf80C50, 0x1f);
a0004928:	26840c50 	addiu	a0,s4,3152
a000492c:	8f9900e0 	lw	t9,224(gp)
a0004930:	0320f809 	jalr	t9
a0004934:	2405001f 	li	a1,31
a0004938:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf81058, 0x1f);   //ssx2, usb1c
a000493c:	26841058 	addiu	a0,s4,4184
a0004940:	8f9900e0 	lw	t9,224(gp)
a0004944:	0320f809 	jalr	t9
a0004948:	2405001f 	li	a1,31
a000494c:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf81050, 0x1f);
a0004950:	26841050 	addiu	a0,s4,4176
a0004954:	8f9900e0 	lw	t9,224(gp)
a0004958:	0320f809 	jalr	t9
a000495c:	2405001f 	li	a1,31
a0004960:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf82058, 0x1);    //ssx2, ln20, 1 bit for all
a0004964:	26842058 	addiu	a0,s4,8280
a0004968:	8f9900e0 	lw	t9,224(gp)
a000496c:	0320f809 	jalr	t9
a0004970:	24050001 	li	a1,1
a0004974:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xbbf82050, 0x1);
a0004978:	26842050 	addiu	a0,s4,8272
a000497c:	8f9900e0 	lw	t9,224(gp)
a0004980:	0320f809 	jalr	t9
a0004984:	24050001 	li	a1,1
a0004988:	8fbc0010 	lw	gp,16(sp)
#endif

/*ssx3*/
#if 1
        i += permission_wr(0xb9f80058, 0x1f);   //ssx3, reg3-r0 (only 4kec should access reg3-r0)
a000498c:	36440058 	ori	a0,s2,0x58
a0004990:	8f9900e0 	lw	t9,224(gp)
a0004994:	0320f809 	jalr	t9
a0004998:	2405001f 	li	a1,31
a000499c:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f80050, 0x1f);
a00049a0:	36440050 	ori	a0,s2,0x50
a00049a4:	8f9900e0 	lw	t9,224(gp)
a00049a8:	0320f809 	jalr	t9
a00049ac:	2405001f 	li	a1,31
a00049b0:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f80078, 0x1f);   //ssx3, reg3-r1 (only 4kec should access reg3-r1)
a00049b4:	26440078 	addiu	a0,s2,120
a00049b8:	8f9900e0 	lw	t9,224(gp)
a00049bc:	0320f809 	jalr	t9
a00049c0:	2405001f 	li	a1,31
a00049c4:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f80070, 0x1f);
a00049c8:	26440070 	addiu	a0,s2,112
a00049cc:	8f9900e0 	lw	t9,224(gp)
a00049d0:	0320f809 	jalr	t9
a00049d4:	2405001f 	li	a1,31
a00049d8:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f81458, 0x1f);   //ssx3, pcie1
a00049dc:	26441458 	addiu	a0,s2,5208
a00049e0:	8f9900e0 	lw	t9,224(gp)
a00049e4:	0320f809 	jalr	t9
a00049e8:	2405001f 	li	a1,31
a00049ec:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f81450, 0x1f);
a00049f0:	26441450 	addiu	a0,s2,5200
a00049f4:	8f9900e0 	lw	t9,224(gp)
a00049f8:	0320f809 	jalr	t9
a00049fc:	2405001f 	li	a1,31
a0004a00:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f81858, 0x1f);   //ssx3, pcie1a
a0004a04:	26441858 	addiu	a0,s2,6232
a0004a08:	8f9900e0 	lw	t9,224(gp)
a0004a0c:	0320f809 	jalr	t9
a0004a10:	2405001f 	li	a1,31
a0004a14:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f81850, 0x1f);
a0004a18:	26441850 	addiu	a0,s2,6224
a0004a1c:	8f9900e0 	lw	t9,224(gp)
a0004a20:	0320f809 	jalr	t9
a0004a24:	2405001f 	li	a1,31
a0004a28:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f81C58, 0x1f);   //ssx3, pcie1c
a0004a2c:	26441c58 	addiu	a0,s2,7256
a0004a30:	8f9900e0 	lw	t9,224(gp)
a0004a34:	0320f809 	jalr	t9
a0004a38:	2405001f 	li	a1,31
a0004a3c:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f81C50, 0x1f);
a0004a40:	26441c50 	addiu	a0,s2,7248
a0004a44:	8f9900e0 	lw	t9,224(gp)
a0004a48:	0320f809 	jalr	t9
a0004a4c:	2405001f 	li	a1,31
a0004a50:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f82058, 0x1f);   //ssx3, msi1
a0004a54:	26442058 	addiu	a0,s2,8280
a0004a58:	8f9900e0 	lw	t9,224(gp)
a0004a5c:	0320f809 	jalr	t9
a0004a60:	2405001f 	li	a1,31
a0004a64:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f82050, 0x1f);
a0004a68:	26442050 	addiu	a0,s2,8272
a0004a6c:	8f9900e0 	lw	t9,224(gp)
a0004a70:	0320f809 	jalr	t9
a0004a74:	2405001f 	li	a1,31
a0004a78:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f82458, 0x1f);   //ssx3, pcie2
a0004a7c:	26442458 	addiu	a0,s2,9304
a0004a80:	8f9900e0 	lw	t9,224(gp)
a0004a84:	0320f809 	jalr	t9
a0004a88:	2405001f 	li	a1,31
a0004a8c:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f82450, 0x1f);
a0004a90:	26442450 	addiu	a0,s2,9296
a0004a94:	8f9900e0 	lw	t9,224(gp)
a0004a98:	0320f809 	jalr	t9
a0004a9c:	2405001f 	li	a1,31
a0004aa0:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f82858, 0x1f);   //ssx3, pcie2a
a0004aa4:	26442858 	addiu	a0,s2,10328
a0004aa8:	8f9900e0 	lw	t9,224(gp)
a0004aac:	0320f809 	jalr	t9
a0004ab0:	2405001f 	li	a1,31
a0004ab4:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f82850, 0x1f);
a0004ab8:	26442850 	addiu	a0,s2,10320
a0004abc:	8f9900e0 	lw	t9,224(gp)
a0004ac0:	0320f809 	jalr	t9
a0004ac4:	2405001f 	li	a1,31
a0004ac8:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f82C58, 0x1f);   //ssx3, pcie2c
a0004acc:	26442c58 	addiu	a0,s2,11352
a0004ad0:	8f9900e0 	lw	t9,224(gp)
a0004ad4:	0320f809 	jalr	t9
a0004ad8:	2405001f 	li	a1,31
a0004adc:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f82C50, 0x1f);
a0004ae0:	26442c50 	addiu	a0,s2,11344
a0004ae4:	8f9900e0 	lw	t9,224(gp)
a0004ae8:	0320f809 	jalr	t9
a0004aec:	2405001f 	li	a1,31
a0004af0:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f83058, 0x1f);   //ssx3, msi2
a0004af4:	26443058 	addiu	a0,s2,12376
a0004af8:	8f9900e0 	lw	t9,224(gp)
a0004afc:	0320f809 	jalr	t9
a0004b00:	2405001f 	li	a1,31
a0004b04:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f83050, 0x1f);
a0004b08:	26443050 	addiu	a0,s2,12368
a0004b0c:	8f9900e0 	lw	t9,224(gp)
a0004b10:	0320f809 	jalr	t9
a0004b14:	2405001f 	li	a1,31
a0004b18:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f80458, 0x1f);   //ssx3, pcie3
a0004b1c:	26440458 	addiu	a0,s2,1112
a0004b20:	8f9900e0 	lw	t9,224(gp)
a0004b24:	0320f809 	jalr	t9
a0004b28:	2405001f 	li	a1,31
a0004b2c:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f80450, 0x1f);
a0004b30:	26440450 	addiu	a0,s2,1104
a0004b34:	8f9900e0 	lw	t9,224(gp)
a0004b38:	0320f809 	jalr	t9
a0004b3c:	2405001f 	li	a1,31
a0004b40:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f80858, 0x1f);   //ssx3, pcie3a
a0004b44:	26440858 	addiu	a0,s2,2136
a0004b48:	8f9900e0 	lw	t9,224(gp)
a0004b4c:	0320f809 	jalr	t9
a0004b50:	2405001f 	li	a1,31
a0004b54:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f80850, 0x1f);
a0004b58:	26440850 	addiu	a0,s2,2128
a0004b5c:	8f9900e0 	lw	t9,224(gp)
a0004b60:	0320f809 	jalr	t9
a0004b64:	2405001f 	li	a1,31
a0004b68:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f80C58, 0x1f);   //ssx3, pcie3c
a0004b6c:	26440c58 	addiu	a0,s2,3160
a0004b70:	8f9900e0 	lw	t9,224(gp)
a0004b74:	0320f809 	jalr	t9
a0004b78:	2405001f 	li	a1,31
a0004b7c:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f80C50, 0x1f);
a0004b80:	26440c50 	addiu	a0,s2,3152
a0004b84:	8f9900e0 	lw	t9,224(gp)
a0004b88:	0320f809 	jalr	t9
a0004b8c:	2405001f 	li	a1,31
a0004b90:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f81058, 0x1f);   //ssx3, msi3
a0004b94:	26441058 	addiu	a0,s2,4184
a0004b98:	8f9900e0 	lw	t9,224(gp)
a0004b9c:	0320f809 	jalr	t9
a0004ba0:	2405001f 	li	a1,31
a0004ba4:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f81050, 0x1f);
a0004ba8:	26441050 	addiu	a0,s2,4176
a0004bac:	8f9900e0 	lw	t9,224(gp)
a0004bb0:	0320f809 	jalr	t9
a0004bb4:	2405001f 	li	a1,31
a0004bb8:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f83458, 0x1);    //ssx3, ln30, 1 bit for all
a0004bbc:	26443458 	addiu	a0,s2,13400
a0004bc0:	8f9900e0 	lw	t9,224(gp)
a0004bc4:	0320f809 	jalr	t9
a0004bc8:	24050001 	li	a1,1
a0004bcc:	8fbc0010 	lw	gp,16(sp)
        i += permission_wr(0xb9f83450, 0x1);
#endif	
}
a0004bd0:	8fbf0034 	lw	ra,52(sp)
a0004bd4:	8fb50030 	lw	s5,48(sp)
a0004bd8:	8fb4002c 	lw	s4,44(sp)
a0004bdc:	8fb30028 	lw	s3,40(sp)
a0004be0:	8fb10020 	lw	s1,32(sp)
a0004be4:	8fb0001c 	lw	s0,28(sp)
        i += permission_wr(0xb9f80C58, 0x1f);   //ssx3, pcie3c
        i += permission_wr(0xb9f80C50, 0x1f);
        i += permission_wr(0xb9f81058, 0x1f);   //ssx3, msi3
        i += permission_wr(0xb9f81050, 0x1f);
        i += permission_wr(0xb9f83458, 0x1);    //ssx3, ln30, 1 bit for all
        i += permission_wr(0xb9f83450, 0x1);
a0004be8:	26443450 	addiu	a0,s2,13392
a0004bec:	8f9900e0 	lw	t9,224(gp)
#endif	
}
a0004bf0:	8fb20024 	lw	s2,36(sp)
        i += permission_wr(0xb9f80C58, 0x1f);   //ssx3, pcie3c
        i += permission_wr(0xb9f80C50, 0x1f);
        i += permission_wr(0xb9f81058, 0x1f);   //ssx3, msi3
        i += permission_wr(0xb9f81050, 0x1f);
        i += permission_wr(0xb9f83458, 0x1);    //ssx3, ln30, 1 bit for all
        i += permission_wr(0xb9f83450, 0x1);
a0004bf4:	24050001 	li	a1,1
a0004bf8:	03200008 	jr	t9
a0004bfc:	27bd0038 	addiu	sp,sp,56

a0004c00 <start_interaptiv>:
#endif	
}


void start_interaptiv(u32 addr)
{
a0004c00:	3c1c0000 	lui	gp,0x0
a0004c04:	279c0d40 	addiu	gp,gp,3392
a0004c08:	0399e021 	addu	gp,gp,t9
a0004c0c:	27bdffe0 	addiu	sp,sp,-32
   u32 i;
   
   set_permission();
a0004c10:	8f9900e4 	lw	t9,228(gp)
#endif	
}


void start_interaptiv(u32 addr)
{
a0004c14:	afb00018 	sw	s0,24(sp)
a0004c18:	afbc0010 	sw	gp,16(sp)
a0004c1c:	afbf001c 	sw	ra,28(sp)
   u32 i;
   
   set_permission();
a0004c20:	0320f809 	jalr	t9
a0004c24:	00808021 	move	s0,a0


    /* wait until reset finished */
   i = REG32(0xb6000014) & REG32(0xb6000024);      // Dummy command for Read Only Reset Register
a0004c28:	3c02b600 	lui	v0,0xb600
a0004c2c:	8c430014 	lw	v1,20(v0)
a0004c30:	8c430024 	lw	v1,36(v0)
   if ((REG32(0xb6000014) & 4) == 0){                      // Read status if InterAptiv Cluster in reset?
a0004c34:	8c430014 	lw	v1,20(v0)
a0004c38:	30630004 	andi	v1,v1,0x4
a0004c3c:	1060001a 	beqz	v1,a0004ca8 <start_interaptiv+0xa8>
a0004c40:	24030004 	li	v1,4
          REG32(0xb6000010) = 0x00000004;                 // If not in reset, reset it
          while ((REG32(0xb6000014) & 8) == 0);   // Wait until InterAptiv Cluster back in reset
   }

   REG32(0xb608004c) |= 0x01;                                                       
a0004c44:	3c02b608 	lui	v0,0xb608
a0004c48:	8c43004c 	lw	v1,76(v0)
a0004c4c:	34630001 	ori	v1,v1,0x1
a0004c50:	ac43004c 	sw	v1,76(v0)
   REG32(0xb608005c) |= 0xdfffff;
a0004c54:	8c44005c 	lw	a0,92(v0)
a0004c58:	3c0300df 	lui	v1,0xdf
a0004c5c:	3463ffff 	ori	v1,v1,0xffff
a0004c60:	00831825 	or	v1,a0,v1
a0004c64:	ac43005c 	sw	v1,92(v0)

   
   REG32(0xbf2001e0) = addr; // pointer to interaptiv normal entry program
   REG32(0xbf2001f4) = 0x56701dcb; // RVEC_INSTALLED
a0004c68:	3c035670 	lui	v1,0x5670
a0004c6c:	24631dcb 	addiu	v1,v1,7627

   REG32(0xb608004c) |= 0x01;                                                       
   REG32(0xb608005c) |= 0xdfffff;

   
   REG32(0xbf2001e0) = addr; // pointer to interaptiv normal entry program
a0004c70:	3c02bf20 	lui	v0,0xbf20
a0004c74:	ac5001e0 	sw	s0,480(v0)
   REG32(0xbf2001f4) = 0x56701dcb; // RVEC_INSTALLED
a0004c78:	ac4301f4 	sw	v1,500(v0)

   REG32(0xbf2001e4) = addr; // pointer to interaptiv nmi handling program
   REG32(0xbf2001f8) = 0x45601CBA; // NVEC_INSTALLED
a0004c7c:	3c034560 	lui	v1,0x4560
a0004c80:	24631cba 	addiu	v1,v1,7354

   
   REG32(0xbf2001e0) = addr; // pointer to interaptiv normal entry program
   REG32(0xbf2001f4) = 0x56701dcb; // RVEC_INSTALLED

   REG32(0xbf2001e4) = addr; // pointer to interaptiv nmi handling program
a0004c84:	ac5001e4 	sw	s0,484(v0)
   REG32(0xbf2001f8) = 0x45601CBA; // NVEC_INSTALLED
a0004c88:	ac4301f8 	sw	v1,504(v0)


   REG32(0xb6000010) = 0x00000008;  // Bring InterAptiv Cluster out of reset
a0004c8c:	24030008 	li	v1,8
a0004c90:	3c02b600 	lui	v0,0xb600
a0004c94:	ac430010 	sw	v1,16(v0)

   return;
}
a0004c98:	8fbf001c 	lw	ra,28(sp)
a0004c9c:	8fb00018 	lw	s0,24(sp)
a0004ca0:	03e00008 	jr	ra
a0004ca4:	27bd0020 	addiu	sp,sp,32


    /* wait until reset finished */
   i = REG32(0xb6000014) & REG32(0xb6000024);      // Dummy command for Read Only Reset Register
   if ((REG32(0xb6000014) & 4) == 0){                      // Read status if InterAptiv Cluster in reset?
          REG32(0xb6000010) = 0x00000004;                 // If not in reset, reset it
a0004ca8:	ac430010 	sw	v1,16(v0)
          while ((REG32(0xb6000014) & 8) == 0);   // Wait until InterAptiv Cluster back in reset
a0004cac:	3c03b600 	lui	v1,0xb600
a0004cb0:	8c620014 	lw	v0,20(v1)
a0004cb4:	30420008 	andi	v0,v0,0x8
a0004cb8:	1040fffd 	beqz	v0,a0004cb0 <start_interaptiv+0xb0>
a0004cbc:	3c02b608 	lui	v0,0xb608
a0004cc0:	1000ffe1 	b	a0004c48 <start_interaptiv+0x48>
a0004cc4:	00000000 	nop
	...

a0004cd0 <r4k_wait_irqoff>:
#define write_c0_gp(val)   __write_32bit_c0_register($28, 0, val)


void r4k_wait_irqoff(void)
{
                __asm__ __volatile__(
a0004cd0:	42000020 	wait
a0004cd4:	03e00008 	jr	ra
a0004cd8:	00000000 	nop

a0004cdc <gic_send_ipi>:
#define FW_VMB_IPI2             88
#define FW_VMB_IPI3             110

void gic_send_ipi(unsigned int intr)
{
	(GIC_SH_WEDGE_REG) = (0x80000000 | intr);
a0004cdc:	3c028000 	lui	v0,0x8000
a0004ce0:	00822025 	or	a0,a0,v0
a0004ce4:	3c03b232 	lui	v1,0xb232
a0004ce8:	ac640280 	sw	a0,640(v1)
a0004cec:	03e00008 	jr	ra
a0004cf0:	00000000 	nop

a0004cf4 <gic_clear_ipi>:
}

void gic_clear_ipi(unsigned int intr)
{
	(GIC_SH_WEDGE_REG) = (0x00000000 | intr);
a0004cf4:	3c02b232 	lui	v0,0xb232
a0004cf8:	ac440280 	sw	a0,640(v0)
a0004cfc:	03e00008 	jr	ra
a0004d00:	00000000 	nop

a0004d04 <print_u8>:
#elif CONFIG_BOOT_FROM_SPI
#define CONFIG_TEXT_BASE_ADDR	CONFIG_SFDDR_TEXT_BASE
#endif

void print_u8(u8 data)
{
a0004d04:	3c1c0000 	lui	gp,0x0
a0004d08:	279c0c3c 	addiu	gp,gp,3132
a0004d0c:	0399e021 	addu	gp,gp,t9
a0004d10:	27bdffc8 	addiu	sp,sp,-56
   char string[3]={0,0,0};
   char ascii[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
a0004d14:	8f850058 	lw	a1,88(gp)
a0004d18:	27a30018 	addiu	v1,sp,24
a0004d1c:	8f99005c 	lw	t9,92(gp)
a0004d20:	24a558c0 	addiu	a1,a1,22720
#elif CONFIG_BOOT_FROM_SPI
#define CONFIG_TEXT_BASE_ADDR	CONFIG_SFDDR_TEXT_BASE
#endif

void print_u8(u8 data)
{
a0004d24:	afbf0034 	sw	ra,52(sp)
a0004d28:	afb00030 	sw	s0,48(sp)
a0004d2c:	afbc0010 	sw	gp,16(sp)
a0004d30:	309000ff 	andi	s0,a0,0xff
   char string[3]={0,0,0};
   char ascii[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
a0004d34:	24060010 	li	a2,16
#define CONFIG_TEXT_BASE_ADDR	CONFIG_SFDDR_TEXT_BASE
#endif

void print_u8(u8 data)
{
   char string[3]={0,0,0};
a0004d38:	a3a0002a 	sb	zero,42(sp)
   char ascii[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
a0004d3c:	0320f809 	jalr	t9
a0004d40:	00602021 	move	a0,v1
a0004d44:	00401821 	move	v1,v0

   string[0]=ascii[(data&0xf0)>>4];
a0004d48:	00101102 	srl	v0,s0,0x4
a0004d4c:	00621021 	addu	v0,v1,v0
   string[1]=ascii[data&0xf];
a0004d50:	3210000f 	andi	s0,s0,0xf
void print_u8(u8 data)
{
   char string[3]={0,0,0};
   char ascii[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

   string[0]=ascii[(data&0xf0)>>4];
a0004d54:	90420000 	lbu	v0,0(v0)
   string[1]=ascii[data&0xf];
a0004d58:	00701821 	addu	v1,v1,s0
#endif

void print_u8(u8 data)
{
   char string[3]={0,0,0};
   char ascii[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
a0004d5c:	8fbc0010 	lw	gp,16(sp)

   string[0]=ascii[(data&0xf0)>>4];
a0004d60:	a3a20028 	sb	v0,40(sp)
   string[1]=ascii[data&0xf];
a0004d64:	90620000 	lbu	v0,0(v1)

   asc_puts(string);
a0004d68:	8f9900e8 	lw	t9,232(gp)
a0004d6c:	27a40028 	addiu	a0,sp,40
a0004d70:	0320f809 	jalr	t9
a0004d74:	a3a20029 	sb	v0,41(sp)
}
a0004d78:	8fbf0034 	lw	ra,52(sp)
a0004d7c:	8fb00030 	lw	s0,48(sp)
a0004d80:	03e00008 	jr	ra
a0004d84:	27bd0038 	addiu	sp,sp,56

a0004d88 <print_u32>:

void print_u32(u32 data)
{
a0004d88:	3c1c0000 	lui	gp,0x0
a0004d8c:	279c0bb8 	addiu	gp,gp,3000
a0004d90:	0399e021 	addu	gp,gp,t9
a0004d94:	27bdffe0 	addiu	sp,sp,-32
   print_u8( (u8) (data>>24)&0xff);
a0004d98:	8f9900ec 	lw	t9,236(gp)

   asc_puts(string);
}

void print_u32(u32 data)
{
a0004d9c:	afbf001c 	sw	ra,28(sp)
a0004da0:	afbc0010 	sw	gp,16(sp)
a0004da4:	afb00018 	sw	s0,24(sp)
a0004da8:	00808021 	move	s0,a0
   print_u8( (u8) (data>>24)&0xff);
a0004dac:	0320f809 	jalr	t9
a0004db0:	00042602 	srl	a0,a0,0x18
a0004db4:	8fbc0010 	lw	gp,16(sp)
   print_u8( (u8) (data>>16)&0xff);
a0004db8:	8f9900ec 	lw	t9,236(gp)
a0004dbc:	0320f809 	jalr	t9
a0004dc0:	7e043c00 	ext	a0,s0,0x10,0x8
a0004dc4:	8fbc0010 	lw	gp,16(sp)
   print_u8( (u8) (data>>8)&0xff);
a0004dc8:	8f9900ec 	lw	t9,236(gp)
a0004dcc:	0320f809 	jalr	t9
a0004dd0:	7e043a00 	ext	a0,s0,0x8,0x8
a0004dd4:	8fbc0010 	lw	gp,16(sp)
   print_u8( (u8) (data>>0)&0xff);
}
a0004dd8:	8fbf001c 	lw	ra,28(sp)
void print_u32(u32 data)
{
   print_u8( (u8) (data>>24)&0xff);
   print_u8( (u8) (data>>16)&0xff);
   print_u8( (u8) (data>>8)&0xff);
   print_u8( (u8) (data>>0)&0xff);
a0004ddc:	320400ff 	andi	a0,s0,0xff
a0004de0:	8f9900ec 	lw	t9,236(gp)
}
a0004de4:	8fb00018 	lw	s0,24(sp)
void print_u32(u32 data)
{
   print_u8( (u8) (data>>24)&0xff);
   print_u8( (u8) (data>>16)&0xff);
   print_u8( (u8) (data>>8)&0xff);
   print_u8( (u8) (data>>0)&0xff);
a0004de8:	03200008 	jr	t9
a0004dec:	27bd0020 	addiu	sp,sp,32

a0004df0 <set_tc_policy>:
}

void set_tc_policy(int tc_num, int group)
{
    write_c0_mvpcontrol((read_c0_mvpcontrol() & ~MVPCONTROL_EVP) | MVPCONTROL_VPC);
a0004df0:	40030001 	mfc0	v1,c0_mvpcontrol
a0004df4:	2402fffc 	li	v0,-4
a0004df8:	00621024 	and	v0,v1,v0
a0004dfc:	34420002 	ori	v0,v0,0x2
a0004e00:	40820001 	mtc0	v0,c0_mvpcontrol
    settc(tc_num);
a0004e04:	40030801 	mfc0	v1,c0_vpecontrol
a0004e08:	2402ff00 	li	v0,-256
a0004e0c:	00621024 	and	v0,v1,v0
a0004e10:	00442025 	or	a0,v0,a0
a0004e14:	40840801 	mtc0	a0,c0_vpecontrol
		__raw_emt();
}

static inline void ehb(void)
{
	__asm__ __volatile__(
a0004e18:	000000c0 	ehb
a0004e1c:	41020806 	mftc0	at,c0_tcschedule
    write_tc_c0_tcschedule(read_tc_c0_tcschedule()| (group & 0x3));
a0004e20:	00201821 	move	v1,at
a0004e24:	30a20003 	andi	v0,a1,0x3
a0004e28:	00622825 	or	a1,v1,v0
a0004e2c:	00a00821 	move	at,a1
a0004e30:	41811006 	mttc0	at,c0_tcschedule
    write_c0_mvpcontrol((read_c0_mvpcontrol() & ~MVPCONTROL_VPC) | MVPCONTROL_EVP);
a0004e34:	40030001 	mfc0	v1,c0_mvpcontrol
a0004e38:	2402fffc 	li	v0,-4
a0004e3c:	00621024 	and	v0,v1,v0
a0004e40:	34420001 	ori	v0,v0,0x1
a0004e44:	03e00008 	jr	ra
a0004e48:	40820001 	mtc0	v0,c0_mvpcontrol

a0004e4c <VMB_get_msg_addr>:
void *VMB_get_msg_addr (int cpu, int direction) {

        void *msg_t =  (void *)(CPU_LAUNCH);

        /* VMB --> FW : VMB_fw_msg_t structure */
        if (direction == 0)
a0004e4c:	14a00007 	bnez	a1,a0004e6c <VMB_get_msg_addr+0x20>
a0004e50:	240300b0 	li	v1,176
                msg_t = msg_t + (vmb_msg_size * cpu) + sizeof(FW_vmb_msg_t);
a0004e54:	240200b0 	li	v0,176
a0004e58:	70822002 	mul	a0,a0,v0
a0004e5c:	3c02a000 	lui	v0,0xa000
a0004e60:	24840008 	addiu	a0,a0,8
a0004e64:	03e00008 	jr	ra
a0004e68:	00441021 	addu	v0,v0,a0
        else
                msg_t = msg_t + (vmb_msg_size * cpu);
a0004e6c:	70832802 	mul	a1,a0,v1
a0004e70:	3c02a000 	lui	v0,0xa000

        return (msg_t);
}
a0004e74:	03e00008 	jr	ra
a0004e78:	00a21021 	addu	v0,a1,v0

a0004e7c <vpe_launch>:
        return (msg_t);
}
#endif

void vpe_launch(int cpu, int c_id, int vpe_id, CPU_launch_t cpu_launch, TC_launch_t tc_launch[])
{
a0004e7c:	3c1c0000 	lui	gp,0x0
a0004e80:	279c0ac4 	addiu	gp,gp,2756
a0004e84:	0399e021 	addu	gp,gp,t9
	u32  vmbfw = 0, addr = 0, fwvmb = 0, RxTx = 0, tcinfo = 0;
	u32 ibl_loadaddr = CONFIG_TEXT_BASE_ADDR;
a0004e88:	3c02a000 	lui	v0,0xa000
a0004e8c:	24421000 	addiu	v0,v0,4096
        return (msg_t);
}
#endif

void vpe_launch(int cpu, int c_id, int vpe_id, CPU_launch_t cpu_launch, TC_launch_t tc_launch[])
{
a0004e90:	27bdffb8 	addiu	sp,sp,-72
	u32  vmbfw = 0, addr = 0, fwvmb = 0, RxTx = 0, tcinfo = 0;
	u32 ibl_loadaddr = CONFIG_TEXT_BASE_ADDR;

	vmbfw = ((unsigned long)(VMB_get_msg_addr(cpu, 0)) & 0xffff);
a0004e94:	8f9900f0 	lw	t9,240(gp)
a0004e98:	00002821 	move	a1,zero
        return (msg_t);
}
#endif

void vpe_launch(int cpu, int c_id, int vpe_id, CPU_launch_t cpu_launch, TC_launch_t tc_launch[])
{
a0004e9c:	afbc0010 	sw	gp,16(sp)
a0004ea0:	afb60040 	sw	s6,64(sp)
a0004ea4:	afb5003c 	sw	s5,60(sp)
a0004ea8:	afb40038 	sw	s4,56(sp)
a0004eac:	afb30034 	sw	s3,52(sp)
a0004eb0:	afb20030 	sw	s2,48(sp)
a0004eb4:	afb1002c 	sw	s1,44(sp)
a0004eb8:	afb00028 	sw	s0,40(sp)
a0004ebc:	00808821 	move	s1,a0
a0004ec0:	afbf0044 	sw	ra,68(sp)
a0004ec4:	afa70054 	sw	a3,84(sp)
	u32  vmbfw = 0, addr = 0, fwvmb = 0, RxTx = 0, tcinfo = 0;
a0004ec8:	afa00024 	sw	zero,36(sp)
a0004ecc:	afa00020 	sw	zero,32(sp)
a0004ed0:	afa0001c 	sw	zero,28(sp)
	u32 ibl_loadaddr = CONFIG_TEXT_BASE_ADDR;
a0004ed4:	afa20018 	sw	v0,24(sp)

	vmbfw = ((unsigned long)(VMB_get_msg_addr(cpu, 0)) & 0xffff);
a0004ed8:	0320f809 	jalr	t9
a0004edc:	7c119420 	seb	s2,s1
}

static u32 tc_getinfo(int8_t cpu, TC_launch_t tc_launch[]) {
	u32 tcmask = 0 , i = 0;

	tcmask = tcmask | (0x1 << (cpu % 2));
a0004ee0:	24030002 	li	v1,2
a0004ee4:	0243001a 	div	zero,s2,v1
a0004ee8:	006001f4 	teq	v1,zero,0x7
void vpe_launch(int cpu, int c_id, int vpe_id, CPU_launch_t cpu_launch, TC_launch_t tc_launch[])
{
	u32  vmbfw = 0, addr = 0, fwvmb = 0, RxTx = 0, tcinfo = 0;
	u32 ibl_loadaddr = CONFIG_TEXT_BASE_ADDR;

	vmbfw = ((unsigned long)(VMB_get_msg_addr(cpu, 0)) & 0xffff);
a0004eec:	3054ffff 	andi	s4,v0,0xffff
}

static u32 tc_getinfo(int8_t cpu, TC_launch_t tc_launch[]) {
	u32 tcmask = 0 , i = 0;

	tcmask = tcmask | (0x1 << (cpu % 2));
a0004ef0:	24120001 	li	s2,1
void vpe_launch(int cpu, int c_id, int vpe_id, CPU_launch_t cpu_launch, TC_launch_t tc_launch[])
{
	u32  vmbfw = 0, addr = 0, fwvmb = 0, RxTx = 0, tcinfo = 0;
	u32 ibl_loadaddr = CONFIG_TEXT_BASE_ADDR;

	vmbfw = ((unsigned long)(VMB_get_msg_addr(cpu, 0)) & 0xffff);
a0004ef4:	8fbc0010 	lw	gp,16(sp)
a0004ef8:	8fb00074 	lw	s0,116(sp)
static u32 tc_getinfo(int8_t cpu, TC_launch_t tc_launch[]) {
	u32 tcmask = 0 , i = 0;

	tcmask = tcmask | (0x1 << (cpu % 2));

	for (i=0; i < MAX_TCS; i++) {
a0004efc:	00009821 	move	s3,zero
		if ((tc_launch[i].tc_num > 0) && (tc_launch[i].tc_num < MAX_TC)){
			tcmask = tcmask | (0x1 << tc_launch[i].tc_num);
a0004f00:	24160001 	li	s6,1
static u32 tc_getinfo(int8_t cpu, TC_launch_t tc_launch[]) {
	u32 tcmask = 0 , i = 0;

	tcmask = tcmask | (0x1 << (cpu % 2));

	for (i=0; i < MAX_TCS; i++) {
a0004f04:	24150004 	li	s5,4
}

static u32 tc_getinfo(int8_t cpu, TC_launch_t tc_launch[]) {
	u32 tcmask = 0 , i = 0;

	tcmask = tcmask | (0x1 << (cpu % 2));
a0004f08:	00001010 	mfhi	v0
a0004f0c:	00529004 	sllv	s2,s2,v0

	for (i=0; i < MAX_TCS; i++) {
		if ((tc_launch[i].tc_num > 0) && (tc_launch[i].tc_num < MAX_TC)){
a0004f10:	8e040000 	lw	a0,0(s0)
a0004f14:	2482ffff 	addiu	v0,a0,-1
a0004f18:	2c420005 	sltiu	v0,v0,5
a0004f1c:	50400008 	beqzl	v0,a0004f40 <vpe_launch+0xc4>
a0004f20:	26730001 	addiu	s3,s3,1
			tcmask = tcmask | (0x1 << tc_launch[i].tc_num);
                        set_tc_policy(tc_launch[i].tc_num, tc_launch[i].mt_group);
a0004f24:	8f9900f4 	lw	t9,244(gp)
a0004f28:	8e050004 	lw	a1,4(s0)

	tcmask = tcmask | (0x1 << (cpu % 2));

	for (i=0; i < MAX_TCS; i++) {
		if ((tc_launch[i].tc_num > 0) && (tc_launch[i].tc_num < MAX_TC)){
			tcmask = tcmask | (0x1 << tc_launch[i].tc_num);
a0004f2c:	00961004 	sllv	v0,s6,a0
                        set_tc_policy(tc_launch[i].tc_num, tc_launch[i].mt_group);
a0004f30:	0320f809 	jalr	t9
a0004f34:	02429025 	or	s2,s2,v0
a0004f38:	8fbc0010 	lw	gp,16(sp)
static u32 tc_getinfo(int8_t cpu, TC_launch_t tc_launch[]) {
	u32 tcmask = 0 , i = 0;

	tcmask = tcmask | (0x1 << (cpu % 2));

	for (i=0; i < MAX_TCS; i++) {
a0004f3c:	26730001 	addiu	s3,s3,1
a0004f40:	1675fff3 	bne	s3,s5,a0004f10 <vpe_launch+0x94>
a0004f44:	26100020 	addiu	s0,s0,32
{
	u32  vmbfw = 0, addr = 0, fwvmb = 0, RxTx = 0, tcinfo = 0;
	u32 ibl_loadaddr = CONFIG_TEXT_BASE_ADDR;

	vmbfw = ((unsigned long)(VMB_get_msg_addr(cpu, 0)) & 0xffff);
	tcinfo = tc_getinfo(cpu, tc_launch);
a0004f48:	afb2001c 	sw	s2,28(sp)


      __write_32bit_c0_register($11, 0, (__read_32bit_c0_register($9, 0) + 1000));
a0004f4c:	40024800 	mfc0	v0,c0_count
a0004f50:	244203e8 	addiu	v0,v0,1000
a0004f54:	40825800 	mtc0	v0,c0_compare
        asm volatile ("ehb");
a0004f58:	000000c0 	ehb

	/* a2 */
	fwvmb = ((unsigned long)(VMB_get_msg_addr(cpu, 1)) & 0xffff);
a0004f5c:	8f9900f0 	lw	t9,240(gp)
a0004f60:	02202021 	move	a0,s1
a0004f64:	0320f809 	jalr	t9
a0004f68:	24050001 	li	a1,1
	addr = (fwvmb << 16) | vmbfw;
a0004f6c:	00021400 	sll	v0,v0,0x10
a0004f70:	0054a025 	or	s4,v0,s4

      __write_32bit_c0_register($11, 0, (__read_32bit_c0_register($9, 0) + 1000));
        asm volatile ("ehb");

	/* a2 */
	fwvmb = ((unsigned long)(VMB_get_msg_addr(cpu, 1)) & 0xffff);
a0004f74:	8fbc0010 	lw	gp,16(sp)
	addr = (fwvmb << 16) | vmbfw;
a0004f78:	afb40024 	sw	s4,36(sp)
	//asc_puts("\naddr "); print_u32(addr); 

       asm volatile ("lw $6, %0" : : "m" ((unsigned long)addr));
a0004f7c:	8fa60024 	lw	a2,36(sp)
       asm volatile ("ehb");
a0004f80:	000000c0 	ehb
a0004f84:	2631ffff 	addiu	s1,s1,-1
a0004f88:	323100ff 	andi	s1,s1,0xff
a0004f8c:	2e230003 	sltiu	v1,s1,3

	return(tcmask);
}

static u32 Rx_Tx_IPI(int8_t cpu) {
	switch(cpu) {
a0004f90:	10600006 	beqz	v1,a0004fac <vpe_launch+0x130>
a0004f94:	00001021 	move	v0,zero
a0004f98:	8f820058 	lw	v0,88(gp)
a0004f9c:	00118880 	sll	s1,s1,0x2
a0004fa0:	244258d0 	addiu	v0,v0,22736
a0004fa4:	02228821 	addu	s1,s1,v0
a0004fa8:	8e220000 	lw	v0,0(s1)

       asm volatile ("lw $6, %0" : : "m" ((unsigned long)addr));
       asm volatile ("ehb");

	/* a3 */
	RxTx = Rx_Tx_IPI(cpu);
a0004fac:	afa20020 	sw	v0,32(sp)
       asm volatile ("lw $7, %0" : : "m" ((unsigned long)RxTx));
a0004fb0:	8fa70020 	lw	a3,32(sp)
       asm volatile ("ehb");
a0004fb4:	000000c0 	ehb
	//asc_puts("\nRxTx "); print_u32(RxTx);

	   /* s1 */
       tcinfo = ((tcinfo << 16) | (unsigned long)cpu_launch.yield_res); 
a0004fb8:	8fa2001c 	lw	v0,28(sp)
a0004fbc:	8fa3006c 	lw	v1,108(sp)
a0004fc0:	00021400 	sll	v0,v0,0x10
a0004fc4:	00431025 	or	v0,v0,v1
a0004fc8:	afa2001c 	sw	v0,28(sp)
       asm volatile ("lw $17, %0" : : "m" (tcinfo));
a0004fcc:	8fb1001c 	lw	s1,28(sp)
       asm volatile ("ehb");
a0004fd0:	000000c0 	ehb
	  //asc_puts("\ntcinfo "); print_u32(tcinfo);

        /* a0 */
       asm volatile ("lw $4, %0" : : "m" ((unsigned long)cpu_launch.a0));
a0004fd4:	8fa40060 	lw	a0,96(sp)
       asm volatile ("ehb");
a0004fd8:	000000c0 	ehb

        /* a1 */
       asm volatile ("lw $5, %0" : : "m" ((unsigned long)cpu_launch.priv_info));
a0004fdc:	8fa50070 	lw	a1,112(sp)
       asm volatile ("ehb");
a0004fe0:	000000c0 	ehb

	/* s0 */
       asm volatile ("lw $16, %0" : : "m" ((unsigned long)ibl_loadaddr));
a0004fe4:	8fb00018 	lw	s0,24(sp)
       asm volatile ("ehb");
a0004fe8:	000000c0 	ehb

       asm volatile ("lw $28, %0" : : "m" ((unsigned long)cpu_launch.gp));
a0004fec:	8fbc005c 	lw	gp,92(sp)
       asm volatile ("ehb");
a0004ff0:	000000c0 	ehb

       asm volatile ("lw $t9, %0" : : "m" ((unsigned long)cpu_launch.start_addr));
a0004ff4:	8fb90054 	lw	t9,84(sp)
       asm volatile ("ehb");
a0004ff8:	000000c0 	ehb

      asm volatile ("lw $29, %0" : : "m" ((unsigned long)cpu_launch.sp));
a0004ffc:	8fbd0058 	lw	sp,88(sp)
       asm volatile ("ehb");
a0005000:	000000c0 	ehb

       asm volatile ("ei");
a0005004:	41606020 	ei
       asm volatile ("ehb");

       asm volatile ("jr $t9");
a0005008:	03200008 	jr	t9
a000500c:	000000c0 	ehb

}
a0005010:	8fbf0044 	lw	ra,68(sp)
a0005014:	8fb60040 	lw	s6,64(sp)
a0005018:	8fb5003c 	lw	s5,60(sp)
a000501c:	8fb40038 	lw	s4,56(sp)
a0005020:	8fb30034 	lw	s3,52(sp)
a0005024:	8fb20030 	lw	s2,48(sp)
a0005028:	8fb1002c 	lw	s1,44(sp)
a000502c:	8fb00028 	lw	s0,40(sp)
a0005030:	03e00008 	jr	ra
a0005034:	27bd0048 	addiu	sp,sp,72

a0005038 <ibl>:


/* Boot routine for Core 0/1, Vpe 0/1 */
void ibl(u32 cpu_num, u32 core_num, u32 vpe_num)
{
a0005038:	3c1c0000 	lui	gp,0x0
a000503c:	279c0908 	addiu	gp,gp,2312
a0005040:	0399e021 	addu	gp,gp,t9
a0005044:	27bdfef8 	addiu	sp,sp,-264
        int i;
       FW_vmb_msg_t *fw_vmb;

       //asc_puts("\nGRX500 cpu "); print_u8(cpu_num);asc_puts("\n");

       fw_vmb = (FW_vmb_msg_t *)VMB_get_msg_addr(cpu_num, 1);
a0005048:	8f9900f0 	lw	t9,240(gp)
a000504c:	24050001 	li	a1,1
}


/* Boot routine for Core 0/1, Vpe 0/1 */
void ibl(u32 cpu_num, u32 core_num, u32 vpe_num)
{
a0005050:	afbc0030 	sw	gp,48(sp)
a0005054:	afb100e4 	sw	s1,228(sp)
a0005058:	afb000e0 	sw	s0,224(sp)
a000505c:	afbf0104 	sw	ra,260(sp)
a0005060:	afbe0100 	sw	s8,256(sp)
a0005064:	afb700fc 	sw	s7,252(sp)
a0005068:	afb600f8 	sw	s6,248(sp)
a000506c:	afb500f4 	sw	s5,244(sp)
a0005070:	afb400f0 	sw	s4,240(sp)
a0005074:	afb300ec 	sw	s3,236(sp)
a0005078:	afb200e8 	sw	s2,232(sp)
        int i;
       FW_vmb_msg_t *fw_vmb;

       //asc_puts("\nGRX500 cpu "); print_u8(cpu_num);asc_puts("\n");

       fw_vmb = (FW_vmb_msg_t *)VMB_get_msg_addr(cpu_num, 1);
a000507c:	0320f809 	jalr	t9
a0005080:	00808021 	move	s0,a0

       fw_vmb->status = (unsigned int)IBL_IN_WAIT;
a0005084:	24030008 	li	v1,8
        int i;
       FW_vmb_msg_t *fw_vmb;

       //asc_puts("\nGRX500 cpu "); print_u8(cpu_num);asc_puts("\n");

       fw_vmb = (FW_vmb_msg_t *)VMB_get_msg_addr(cpu_num, 1);
a0005088:	8fbc0030 	lw	gp,48(sp)

       fw_vmb->status = (unsigned int)IBL_IN_WAIT;
       fw_vmb->priv_info = (unsigned int)0;

       /* TODO : Generate an IPI to Core0/VPE0 to update VMB as IBL_IN_WAIT */
		gic_trigger(cpu_num);
a000508c:	7c108c20 	seb	s1,s0

       //asc_puts("\nGRX500 cpu "); print_u8(cpu_num);asc_puts("\n");

       fw_vmb = (FW_vmb_msg_t *)VMB_get_msg_addr(cpu_num, 1);

       fw_vmb->status = (unsigned int)IBL_IN_WAIT;
a0005090:	ac430000 	sw	v1,0(v0)
       fw_vmb->priv_info = (unsigned int)0;
a0005094:	ac400004 	sw	zero,4(v0)
/*
   This function is needed to trigger GIC IPI Interrupt .
*/

static void gic_trigger(int8_t cpu) {
        switch(cpu) {
a0005098:	24020002 	li	v0,2
a000509c:	12220007 	beq	s1,v0,a00050bc <ibl+0x84>
a00050a0:	24020003 	li	v0,3
a00050a4:	12220007 	beq	s1,v0,a00050c4 <ibl+0x8c>
a00050a8:	24020001 	li	v0,1
a00050ac:	1622000a 	bne	s1,v0,a00050d8 <ibl+0xa0>
a00050b0:	24040057 	li	a0,87
                        break;
                case 2:
                        gic_send_ipi(FW_VMB_IPI2);
                        break;
                case 3:
                        gic_send_ipi(FW_VMB_IPI3);
a00050b4:	10000005 	b	a00050cc <ibl+0x94>
a00050b8:	8f9900f8 	lw	t9,248(gp)
        switch(cpu) {
                case 1:
                        gic_send_ipi(FW_VMB_IPI1);
                        break;
                case 2:
                        gic_send_ipi(FW_VMB_IPI2);
a00050bc:	10000002 	b	a00050c8 <ibl+0x90>
a00050c0:	24040058 	li	a0,88
                        break;
                case 3:
                        gic_send_ipi(FW_VMB_IPI3);
a00050c4:	2404006e 	li	a0,110
a00050c8:	8f9900f8 	lw	t9,248(gp)
a00050cc:	0320f809 	jalr	t9
a00050d0:	00000000 	nop
a00050d4:	8fbc0030 	lw	gp,48(sp)
		gic_trigger(cpu_num);

      //asc_puts("\nFW_VMB cpu "); print_u8((unsigned long)fw_vmb);

    
	asm volatile ("ei");  
a00050d8:	41606020 	ei
        asm volatile ("ehb") ;
a00050dc:	000000c0 	ehb
	REG32(CPUMSG) += 1;
a00050e0:	3c02a000 	lui	v0,0xa000
a00050e4:	3442ff00 	ori	v0,v0,0xff00
		VMB_fw_msg_t *vmb_t, l_vmb_t;
		int v_id, c_id;

		asc_puts("\nOutside WAIT got IPI interrupt to launch from cpu "); print_u8(cpu_num);
		asc_puts("\n");
		REG32(INTMSG + cpu_num*4) = 0;
a00050e8:	3c132800 	lui	s3,0x2800
      //asc_puts("\nFW_VMB cpu "); print_u8((unsigned long)fw_vmb);

    
	asm volatile ("ei");  
        asm volatile ("ehb") ;
	REG32(CPUMSG) += 1;
a00050ec:	8c430000 	lw	v1,0(v0)
		VMB_fw_msg_t *vmb_t, l_vmb_t;
		int v_id, c_id;

		asc_puts("\nOutside WAIT got IPI interrupt to launch from cpu "); print_u8(cpu_num);
		asc_puts("\n");
		REG32(INTMSG + cpu_num*4) = 0;
a00050f0:	26733fc4 	addiu	s3,s3,16324
      //asc_puts("\nFW_VMB cpu "); print_u8((unsigned long)fw_vmb);

    
	asm volatile ("ei");  
        asm volatile ("ehb") ;
	REG32(CPUMSG) += 1;
a00050f4:	24630001 	addiu	v1,v1,1
               r4k_wait_irqoff();

		VMB_fw_msg_t *vmb_t, l_vmb_t;
		int v_id, c_id;

		asc_puts("\nOutside WAIT got IPI interrupt to launch from cpu "); print_u8(cpu_num);
a00050f8:	8f940058 	lw	s4,88(gp)
		asc_puts("\n");
a00050fc:	8f960058 	lw	s6,88(gp)
		v_id = vpe_in_core(cpu_num);
		
		vmb_t = (VMB_fw_msg_t *)VMB_get_msg_addr(cpu_num, 0);
		memcpy(&l_vmb_t, vmb_t, sizeof(VMB_fw_msg_t));

		asc_puts("\n MSG_ID = "); print_u8(l_vmb_t.msg_id);
a0005100:	8f9e0058 	lw	s8,88(gp)
		VMB_fw_msg_t *vmb_t, l_vmb_t;
		int v_id, c_id;

		asc_puts("\nOutside WAIT got IPI interrupt to launch from cpu "); print_u8(cpu_num);
		asc_puts("\n");
		REG32(INTMSG + cpu_num*4) = 0;
a0005104:	02139821 	addu	s3,s0,s3
      //asc_puts("\nFW_VMB cpu "); print_u8((unsigned long)fw_vmb);

    
	asm volatile ("ei");  
        asm volatile ("ehb") ;
	REG32(CPUMSG) += 1;
a0005108:	ac430000 	sw	v1,0(v0)
		VMB_fw_msg_t *vmb_t, l_vmb_t;
		int v_id, c_id;

		asc_puts("\nOutside WAIT got IPI interrupt to launch from cpu "); print_u8(cpu_num);
		asc_puts("\n");
		REG32(INTMSG + cpu_num*4) = 0;
a000510c:	00139880 	sll	s3,s3,0x2
		
		/* gets the DDR address of the structure to this CPU*/
		c_id = which_core(cpu_num);
a0005110:	00109042 	srl	s2,s0,0x1
               r4k_wait_irqoff();

		VMB_fw_msg_t *vmb_t, l_vmb_t;
		int v_id, c_id;

		asc_puts("\nOutside WAIT got IPI interrupt to launch from cpu "); print_u8(cpu_num);
a0005114:	269458f8 	addiu	s4,s4,22776
a0005118:	321500ff 	andi	s5,s0,0xff
		asc_puts("\n");
a000511c:	26d6592c 	addiu	s6,s6,22828
		/* gets the DDR address of the structure to this CPU*/
		c_id = which_core(cpu_num);
		v_id = vpe_in_core(cpu_num);
		
		vmb_t = (VMB_fw_msg_t *)VMB_get_msg_addr(cpu_num, 0);
		memcpy(&l_vmb_t, vmb_t, sizeof(VMB_fw_msg_t));
a0005120:	27b70038 	addiu	s7,sp,56

		asc_puts("\n MSG_ID = "); print_u8(l_vmb_t.msg_id);
a0005124:	27de5930 	addiu	s8,s8,22832
        asm volatile ("ehb") ;
	REG32(CPUMSG) += 1;

       while (1) {

               r4k_wait_irqoff();
a0005128:	8f9900fc 	lw	t9,252(gp)
a000512c:	0320f809 	jalr	t9
a0005130:	00000000 	nop
a0005134:	8fbc0030 	lw	gp,48(sp)

		VMB_fw_msg_t *vmb_t, l_vmb_t;
		int v_id, c_id;

		asc_puts("\nOutside WAIT got IPI interrupt to launch from cpu "); print_u8(cpu_num);
a0005138:	8f9900e8 	lw	t9,232(gp)
a000513c:	0320f809 	jalr	t9
a0005140:	02802021 	move	a0,s4
a0005144:	8fbc0030 	lw	gp,48(sp)
a0005148:	8f9900ec 	lw	t9,236(gp)
a000514c:	0320f809 	jalr	t9
a0005150:	02a02021 	move	a0,s5
a0005154:	8fbc0030 	lw	gp,48(sp)
		asc_puts("\n");
a0005158:	8f9900e8 	lw	t9,232(gp)
a000515c:	0320f809 	jalr	t9
a0005160:	02c02021 	move	a0,s6
a0005164:	8fbc0030 	lw	gp,48(sp)
		
		/* gets the DDR address of the structure to this CPU*/
		c_id = which_core(cpu_num);
		v_id = vpe_in_core(cpu_num);
		
		vmb_t = (VMB_fw_msg_t *)VMB_get_msg_addr(cpu_num, 0);
a0005168:	02002021 	move	a0,s0
a000516c:	00002821 	move	a1,zero
a0005170:	8f9900f0 	lw	t9,240(gp)
		VMB_fw_msg_t *vmb_t, l_vmb_t;
		int v_id, c_id;

		asc_puts("\nOutside WAIT got IPI interrupt to launch from cpu "); print_u8(cpu_num);
		asc_puts("\n");
		REG32(INTMSG + cpu_num*4) = 0;
a0005174:	ae600000 	sw	zero,0(s3)
		
		/* gets the DDR address of the structure to this CPU*/
		c_id = which_core(cpu_num);
		v_id = vpe_in_core(cpu_num);
		
		vmb_t = (VMB_fw_msg_t *)VMB_get_msg_addr(cpu_num, 0);
a0005178:	0320f809 	jalr	t9
a000517c:	00000000 	nop
a0005180:	8fbc0030 	lw	gp,48(sp)
		memcpy(&l_vmb_t, vmb_t, sizeof(VMB_fw_msg_t));
a0005184:	00402821 	move	a1,v0
a0005188:	240600a8 	li	a2,168
a000518c:	8f99005c 	lw	t9,92(gp)
a0005190:	0320f809 	jalr	t9
a0005194:	02e02021 	move	a0,s7
a0005198:	8fbc0030 	lw	gp,48(sp)

		asc_puts("\n MSG_ID = "); print_u8(l_vmb_t.msg_id);
a000519c:	8f9900e8 	lw	t9,232(gp)
a00051a0:	0320f809 	jalr	t9
a00051a4:	03c02021 	move	a0,s8
a00051a8:	8fbc0030 	lw	gp,48(sp)
a00051ac:	8f9900ec 	lw	t9,236(gp)
a00051b0:	0320f809 	jalr	t9
a00051b4:	93a4003b 	lbu	a0,59(sp)

        return;
}

static void gic_clear(int8_t cpu) {
	switch (cpu) {
a00051b8:	24020002 	li	v0,2
a00051bc:	12220008 	beq	s1,v0,a00051e0 <ibl+0x1a8>
a00051c0:	8fbc0030 	lw	gp,48(sp)
a00051c4:	24020003 	li	v0,3
a00051c8:	12220007 	beq	s1,v0,a00051e8 <ibl+0x1b0>
a00051cc:	24020001 	li	v0,1
a00051d0:	1622000a 	bne	s1,v0,a00051fc <ibl+0x1c4>
a00051d4:	24040014 	li	a0,20
		break;
	case 2:
		gic_clear_ipi(VMB_CPU_IPI2);
		break;
	case 3:
		gic_clear_ipi(VMB_CPU_IPI3);
a00051d8:	10000005 	b	a00051f0 <ibl+0x1b8>
a00051dc:	8f990100 	lw	t9,256(gp)
	switch (cpu) {
	case 1:
		gic_clear_ipi(VMB_CPU_IPI1);
		break;
	case 2:
		gic_clear_ipi(VMB_CPU_IPI2);
a00051e0:	10000002 	b	a00051ec <ibl+0x1b4>
a00051e4:	24040015 	li	a0,21
		break;
	case 3:
		gic_clear_ipi(VMB_CPU_IPI3);
a00051e8:	24040055 	li	a0,85
a00051ec:	8f990100 	lw	t9,256(gp)
a00051f0:	0320f809 	jalr	t9
a00051f4:	00000000 	nop
a00051f8:	8fbc0030 	lw	gp,48(sp)
		asc_puts("\n MSG_ID = "); print_u8(l_vmb_t.msg_id);
	
		/* Clear IPI Interupts */
		gic_clear(cpu_num);
	
		if (l_vmb_t.msg_id == VMB_CPU_START) {
a00051fc:	8fa30038 	lw	v1,56(sp)
a0005200:	24020001 	li	v0,1
a0005204:	1462ffc9 	bne	v1,v0,a000512c <ibl+0xf4>
a0005208:	8f9900fc 	lw	t9,252(gp)
			// memset(vmb_t, 0, sizeof(VMB_fw_msg_t)); // commented as per MPEFW
			vpe_launch(cpu_num, c_id, v_id, l_vmb_t.cpu_launch, l_vmb_t.tc_launch);
a000520c:	27a2005c 	addiu	v0,sp,92
		asc_puts("\n");
		REG32(INTMSG + cpu_num*4) = 0;
		
		/* gets the DDR address of the structure to this CPU*/
		c_id = which_core(cpu_num);
		v_id = vpe_in_core(cpu_num);
a0005210:	32060001 	andi	a2,s0,0x1
		/* Clear IPI Interupts */
		gic_clear(cpu_num);
	
		if (l_vmb_t.msg_id == VMB_CPU_START) {
			// memset(vmb_t, 0, sizeof(VMB_fw_msg_t)); // commented as per MPEFW
			vpe_launch(cpu_num, c_id, v_id, l_vmb_t.cpu_launch, l_vmb_t.tc_launch);
a0005214:	afa2002c 	sw	v0,44(sp)
a0005218:	27a40010 	addiu	a0,sp,16
a000521c:	00001021 	move	v0,zero
a0005220:	27a50040 	addiu	a1,sp,64
a0005224:	2c43001c 	sltiu	v1,v0,28
a0005228:	10600006 	beqz	v1,a0005244 <ibl+0x20c>
a000522c:	00a23821 	addu	a3,a1,v0
a0005230:	00821821 	addu	v1,a0,v0
a0005234:	90e70000 	lbu	a3,0(a3)
a0005238:	24420001 	addiu	v0,v0,1
a000523c:	1000fff9 	b	a0005224 <ibl+0x1ec>
a0005240:	a0670000 	sb	a3,0(v1)
a0005244:	8f990104 	lw	t9,260(gp)
a0005248:	8fa7003c 	lw	a3,60(sp)
a000524c:	02002021 	move	a0,s0
a0005250:	0320f809 	jalr	t9
a0005254:	02402821 	move	a1,s2
		}
       }
a0005258:	1000ffb3 	b	a0005128 <ibl+0xf0>
a000525c:	8fbc0030 	lw	gp,48(sp)

Disassembly of section .text.startup:

a0005260 <main>:
   REG32(0xbe003F10) = reg_val & 0xFFFFFF00;
}
#endif /* defined(CONFIG_LTQ_EIP123_IAP_ACCESS) && !defined(CONFIG_MANUBOOT) */

void main(u32 cpu_num, u32 core_num, u32 vpe_num)
{
a0005260:	3c1c0000 	lui	gp,0x0
a0005264:	279c06e0 	addiu	gp,gp,1760
a0005268:	0399e021 	addu	gp,gp,t9
a000526c:	27bdffe0 	addiu	sp,sp,-32
a0005270:	afbc0010 	sw	gp,16(sp)
a0005274:	afbf001c 	sw	ra,28(sp)
      int i;

      switch (cpu_num) {
a0005278:	1080000e 	beqz	a0,a00052b4 <main+0x54>
a000527c:	24030008 	li	v1,8
a0005280:	1483002c 	bne	a0,v1,a0005334 <main+0xd4>
a0005284:	8fbf001c 	lw	ra,28(sp)
        case 8:
#if !defined (CONFIG_GRX500_BOOT_4KEC_ONLY) /* IAP boot */
			/* Initialize flag */
			REG32(SRAMFLAG) = 0;
a0005288:	3c02bf80 	lui	v0,0xbf80
			/* trigger IAP to run */
			start_interaptiv(CONFIG_NAND_SPL_TEXT_BASE);
a000528c:	8f990078 	lw	t9,120(gp)
a0005290:	3c04a000 	lui	a0,0xa000

      switch (cpu_num) {
        case 8:
#if !defined (CONFIG_GRX500_BOOT_4KEC_ONLY) /* IAP boot */
			/* Initialize flag */
			REG32(SRAMFLAG) = 0;
a0005294:	ac407f00 	sw	zero,32512(v0)
			/* trigger IAP to run */
			start_interaptiv(CONFIG_NAND_SPL_TEXT_BASE);
a0005298:	0320f809 	jalr	t9
a000529c:	24841000 	addiu	a0,a0,4096
            #if defined(CONFIG_MANUBOOT_OTP_SUPPORT)
            wait:
            #endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) */
			/*wait until IAP release */
			while (REG32(SRAMFLAG) != IPCMAGIC); 
a00052a0:	3c02344b 	lui	v0,0x344b
        case 8:
#if !defined (CONFIG_GRX500_BOOT_4KEC_ONLY) /* IAP boot */
			/* Initialize flag */
			REG32(SRAMFLAG) = 0;
			/* trigger IAP to run */
			start_interaptiv(CONFIG_NAND_SPL_TEXT_BASE);
a00052a4:	8fbc0010 	lw	gp,16(sp)
            #if defined(CONFIG_MANUBOOT_OTP_SUPPORT)
            wait:
            #endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) */
			/*wait until IAP release */
			while (REG32(SRAMFLAG) != IPCMAGIC); 
a00052a8:	3c04bf80 	lui	a0,0xbf80
a00052ac:	10000014 	b	a0005300 <main+0xa0>
a00052b0:	24426563 	addiu	v0,v0,25955
           nand_boot();
           #endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) && !defined (CONFIG_GRX500_BOOT_4KEC_ONLY) */
           break;
        case 0:
            for (i=0; i<4; i++){                            //Reset All MSG
                REG32(CPUMSG + 4*i) = 0;
a00052b4:	3c02a000 	lui	v0,0xa000
a00052b8:	3442ff00 	ori	v0,v0,0xff00
a00052bc:	ac400000 	sw	zero,0(v0)
                REG32(INTMSG + 4*i) = 0;
a00052c0:	ac400010 	sw	zero,16(v0)
                REG32(JMPMSG + 4*i) = 0;
a00052c4:	ac400020 	sw	zero,32(v0)
           nand_boot();
           #endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) && !defined (CONFIG_GRX500_BOOT_4KEC_ONLY) */
           break;
        case 0:
            for (i=0; i<4; i++){                            //Reset All MSG
                REG32(CPUMSG + 4*i) = 0;
a00052c8:	ac400004 	sw	zero,4(v0)
                REG32(INTMSG + 4*i) = 0;
a00052cc:	ac400014 	sw	zero,20(v0)
                REG32(JMPMSG + 4*i) = 0;
a00052d0:	ac400024 	sw	zero,36(v0)
           nand_boot();
           #endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) && !defined (CONFIG_GRX500_BOOT_4KEC_ONLY) */
           break;
        case 0:
            for (i=0; i<4; i++){                            //Reset All MSG
                REG32(CPUMSG + 4*i) = 0;
a00052d4:	ac400008 	sw	zero,8(v0)
                REG32(INTMSG + 4*i) = 0;
a00052d8:	ac400018 	sw	zero,24(v0)
                REG32(JMPMSG + 4*i) = 0;
a00052dc:	ac400028 	sw	zero,40(v0)
           nand_boot();
           #endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) && !defined (CONFIG_GRX500_BOOT_4KEC_ONLY) */
           break;
        case 0:
            for (i=0; i<4; i++){                            //Reset All MSG
                REG32(CPUMSG + 4*i) = 0;
a00052e0:	ac40000c 	sw	zero,12(v0)
                REG32(INTMSG + 4*i) = 0;
a00052e4:	ac40001c 	sw	zero,28(v0)
                REG32(JMPMSG + 4*i) = 0;
a00052e8:	ac40002c 	sw	zero,44(v0)
            }

           REG32(CPUMSG)+=1; 
a00052ec:	8c430000 	lw	v1,0(v0)
a00052f0:	24630001 	addiu	v1,v1,1
a00052f4:	ac430000 	sw	v1,0(v0)
           otp_prog_execute();
           goto wait; /* back to wait magic */
           #else /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) && !defined (CONFIG_GRX500_BOOT_4KEC_ONLY) */
		   /* FMT settings */
           REG32(0xb49001d4) = CONFIG_FMT1_REG;
           nand_boot();
a00052f8:	1000000c 	b	a000532c <main+0xcc>
a00052fc:	8f99007c 	lw	t9,124(gp)
			start_interaptiv(CONFIG_NAND_SPL_TEXT_BASE);
            #if defined(CONFIG_MANUBOOT_OTP_SUPPORT)
            wait:
            #endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) */
			/*wait until IAP release */
			while (REG32(SRAMFLAG) != IPCMAGIC); 
a0005300:	8c837f00 	lw	v1,32512(a0)
a0005304:	1462fffe 	bne	v1,v0,a0005300 <main+0xa0>
a0005308:	8f990080 	lw	t9,128(gp)
			mdelay(200);
a000530c:	0320f809 	jalr	t9
a0005310:	240400c8 	li	a0,200
           /* and break the ability to load bootcore when RoT */
           otp_prog_execute();
           goto wait; /* back to wait magic */
           #else /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) && !defined (CONFIG_GRX500_BOOT_4KEC_ONLY) */
		   /* FMT settings */
           REG32(0xb49001d4) = CONFIG_FMT1_REG;
a0005314:	3c03f800 	lui	v1,0xf800
a0005318:	24633800 	addiu	v1,v1,14336
a000531c:	3c02b490 	lui	v0,0xb490
            #if defined(CONFIG_MANUBOOT_OTP_SUPPORT)
            wait:
            #endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) */
			/*wait until IAP release */
			while (REG32(SRAMFLAG) != IPCMAGIC); 
			mdelay(200);
a0005320:	8fbc0010 	lw	gp,16(sp)
           /* and break the ability to load bootcore when RoT */
           otp_prog_execute();
           goto wait; /* back to wait magic */
           #else /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) && !defined (CONFIG_GRX500_BOOT_4KEC_ONLY) */
		   /* FMT settings */
           REG32(0xb49001d4) = CONFIG_FMT1_REG;
a0005324:	ac4301d4 	sw	v1,468(v0)
           nand_boot();
a0005328:	8f99007c 	lw	t9,124(gp)
a000532c:	0320f809 	jalr	t9
a0005330:	00000000 	nop
           */
           //while(REG32(0xa0400000)!=0x88888888);
           nand_boot();
           break;
        default:
           ibl(cpu_num,core_num,vpe_num);
a0005334:	8f990084 	lw	t9,132(gp)
a0005338:	03200008 	jr	t9
a000533c:	27bd0020 	addiu	sp,sp,32
